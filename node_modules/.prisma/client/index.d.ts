
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model KYC
 * 
 */
export type KYC = $Result.DefaultSelection<Prisma.$KYCPayload>
/**
 * Model MT5Account
 * 
 */
export type MT5Account = $Result.DefaultSelection<Prisma.$MT5AccountPayload>
/**
 * Model MT5Transaction
 * 
 */
export type MT5Transaction = $Result.DefaultSelection<Prisma.$MT5TransactionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Deposit
 * 
 */
export type Deposit = $Result.DefaultSelection<Prisma.$DepositPayload>
/**
 * Model CregisDeposit
 * 
 */
export type CregisDeposit = $Result.DefaultSelection<Prisma.$CregisDepositPayload>
/**
 * Model Withdrawal
 * 
 */
export type Withdrawal = $Result.DefaultSelection<Prisma.$WithdrawalPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model DefaultMT5Account
 * 
 */
export type DefaultMT5Account = $Result.DefaultSelection<Prisma.$DefaultMT5AccountPayload>
/**
 * Model Instrument
 * 
 */
export type Instrument = $Result.DefaultSelection<Prisma.$InstrumentPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model UserFavorite
 * 
 */
export type UserFavorite = $Result.DefaultSelection<Prisma.$UserFavoritePayload>
/**
 * Model UserLoginLog
 * 
 */
export type UserLoginLog = $Result.DefaultSelection<Prisma.$UserLoginLogPayload>
/**
 * Model TerminalSettings
 * 
 */
export type TerminalSettings = $Result.DefaultSelection<Prisma.$TerminalSettingsPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model admin_login_log
 * 
 */
export type admin_login_log = $Result.DefaultSelection<Prisma.$admin_login_logPayload>
/**
 * Model balance_operation_history
 * 
 */
export type balance_operation_history = $Result.DefaultSelection<Prisma.$balance_operation_historyPayload>
/**
 * Model chat_conversations
 * 
 */
export type chat_conversations = $Result.DefaultSelection<Prisma.$chat_conversationsPayload>
/**
 * Model chat_messages
 * 
 */
export type chat_messages = $Result.DefaultSelection<Prisma.$chat_messagesPayload>
/**
 * Model chat_participants
 * 
 */
export type chat_participants = $Result.DefaultSelection<Prisma.$chat_participantsPayload>
/**
 * Model group_commission_structures
 * 
 */
export type group_commission_structures = $Result.DefaultSelection<Prisma.$group_commission_structuresPayload>
/**
 * Model ib_admin
 * 
 */
export type ib_admin = $Result.DefaultSelection<Prisma.$ib_adminPayload>
/**
 * Model ib_requests
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type ib_requests = $Result.DefaultSelection<Prisma.$ib_requestsPayload>
/**
 * Model manual_gateway
 * 
 */
export type manual_gateway = $Result.DefaultSelection<Prisma.$manual_gatewayPayload>
/**
 * Model mt5_groups
 * 
 */
export type mt5_groups = $Result.DefaultSelection<Prisma.$mt5_groupsPayload>
/**
 * Model payment_gateway
 * 
 */
export type payment_gateway = $Result.DefaultSelection<Prisma.$payment_gatewayPayload>
/**
 * Model symbols
 * 
 */
export type symbols = $Result.DefaultSelection<Prisma.$symbolsPayload>
/**
 * Model ib_group_assignments
 * 
 */
export type ib_group_assignments = $Result.DefaultSelection<Prisma.$ib_group_assignmentsPayload>
/**
 * Model ib_trade_history
 * 
 */
export type ib_trade_history = $Result.DefaultSelection<Prisma.$ib_trade_historyPayload>
/**
 * Model support_tickets
 * 
 */
export type support_tickets = $Result.DefaultSelection<Prisma.$support_ticketsPayload>
/**
 * Model support_ticket_replies
 * 
 */
export type support_ticket_replies = $Result.DefaultSelection<Prisma.$support_ticket_repliesPayload>
/**
 * Model support_articles
 * 
 */
export type support_articles = $Result.DefaultSelection<Prisma.$support_articlesPayload>
/**
 * Model support_faq
 * 
 */
export type support_faq = $Result.DefaultSelection<Prisma.$support_faqPayload>
/**
 * Model support_categories
 * 
 */
export type support_categories = $Result.DefaultSelection<Prisma.$support_categoriesPayload>
/**
 * Model support_replies
 * 
 */
export type support_replies = $Result.DefaultSelection<Prisma.$support_repliesPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model group_management
 * 
 */
export type group_management = $Result.DefaultSelection<Prisma.$group_managementPayload>
/**
 * Model SymbolGroupAccess
 * 
 */
export type SymbolGroupAccess = $Result.DefaultSelection<Prisma.$SymbolGroupAccessPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model admin_transactions
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type admin_transactions = $Result.DefaultSelection<Prisma.$admin_transactionsPayload>
/**
 * Model countries
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type countries = $Result.DefaultSelection<Prisma.$countriesPayload>
/**
 * Model country_admins
 * 
 */
export type country_admins = $Result.DefaultSelection<Prisma.$country_adminsPayload>
/**
 * Model email_templates
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type email_templates = $Result.DefaultSelection<Prisma.$email_templatesPayload>
/**
 * Model ib_client_linking
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type ib_client_linking = $Result.DefaultSelection<Prisma.$ib_client_linkingPayload>
/**
 * Model ib_client_linking_history
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type ib_client_linking_history = $Result.DefaultSelection<Prisma.$ib_client_linking_historyPayload>
/**
 * Model ib_commission
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ib_commission = $Result.DefaultSelection<Prisma.$ib_commissionPayload>
/**
 * Model ib_level_up_history
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ib_level_up_history = $Result.DefaultSelection<Prisma.$ib_level_up_historyPayload>
/**
 * Model ib_referrals
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type ib_referrals = $Result.DefaultSelection<Prisma.$ib_referralsPayload>
/**
 * Model ib_reward_claims
 * 
 */
export type ib_reward_claims = $Result.DefaultSelection<Prisma.$ib_reward_claimsPayload>
/**
 * Model ib_withdrawal_requests
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type ib_withdrawal_requests = $Result.DefaultSelection<Prisma.$ib_withdrawal_requestsPayload>
/**
 * Model sent_emails
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type sent_emails = $Result.DefaultSelection<Prisma.$sent_emailsPayload>
/**
 * Model symbols_with_categories
 * 
 */
export type symbols_with_categories = $Result.DefaultSelection<Prisma.$symbols_with_categoriesPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Suggestion
 * 
 */
export type Suggestion = $Result.DefaultSelection<Prisma.$SuggestionPayload>
/**
 * Model PriceAlert
 * 
 */
export type PriceAlert = $Result.DefaultSelection<Prisma.$PriceAlertPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYC`: Exposes CRUD operations for the **KYC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCS
    * const kYCS = await prisma.kYC.findMany()
    * ```
    */
  get kYC(): Prisma.KYCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mT5Account`: Exposes CRUD operations for the **MT5Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MT5Accounts
    * const mT5Accounts = await prisma.mT5Account.findMany()
    * ```
    */
  get mT5Account(): Prisma.MT5AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mT5Transaction`: Exposes CRUD operations for the **MT5Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MT5Transactions
    * const mT5Transactions = await prisma.mT5Transaction.findMany()
    * ```
    */
  get mT5Transaction(): Prisma.MT5TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposit`: Exposes CRUD operations for the **Deposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposits
    * const deposits = await prisma.deposit.findMany()
    * ```
    */
  get deposit(): Prisma.DepositDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cregisDeposit`: Exposes CRUD operations for the **CregisDeposit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CregisDeposits
    * const cregisDeposits = await prisma.cregisDeposit.findMany()
    * ```
    */
  get cregisDeposit(): Prisma.CregisDepositDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **Withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.WithdrawalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.defaultMT5Account`: Exposes CRUD operations for the **DefaultMT5Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefaultMT5Accounts
    * const defaultMT5Accounts = await prisma.defaultMT5Account.findMany()
    * ```
    */
  get defaultMT5Account(): Prisma.DefaultMT5AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instrument`: Exposes CRUD operations for the **Instrument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instruments
    * const instruments = await prisma.instrument.findMany()
    * ```
    */
  get instrument(): Prisma.InstrumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorite`: Exposes CRUD operations for the **UserFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorites
    * const userFavorites = await prisma.userFavorite.findMany()
    * ```
    */
  get userFavorite(): Prisma.UserFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLoginLog`: Exposes CRUD operations for the **UserLoginLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLoginLogs
    * const userLoginLogs = await prisma.userLoginLog.findMany()
    * ```
    */
  get userLoginLog(): Prisma.UserLoginLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.terminalSettings`: Exposes CRUD operations for the **TerminalSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TerminalSettings
    * const terminalSettings = await prisma.terminalSettings.findMany()
    * ```
    */
  get terminalSettings(): Prisma.TerminalSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin_login_log`: Exposes CRUD operations for the **admin_login_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_login_logs
    * const admin_login_logs = await prisma.admin_login_log.findMany()
    * ```
    */
  get admin_login_log(): Prisma.admin_login_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balance_operation_history`: Exposes CRUD operations for the **balance_operation_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balance_operation_histories
    * const balance_operation_histories = await prisma.balance_operation_history.findMany()
    * ```
    */
  get balance_operation_history(): Prisma.balance_operation_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_conversations`: Exposes CRUD operations for the **chat_conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_conversations
    * const chat_conversations = await prisma.chat_conversations.findMany()
    * ```
    */
  get chat_conversations(): Prisma.chat_conversationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_messages`: Exposes CRUD operations for the **chat_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_messages
    * const chat_messages = await prisma.chat_messages.findMany()
    * ```
    */
  get chat_messages(): Prisma.chat_messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_participants`: Exposes CRUD operations for the **chat_participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_participants
    * const chat_participants = await prisma.chat_participants.findMany()
    * ```
    */
  get chat_participants(): Prisma.chat_participantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group_commission_structures`: Exposes CRUD operations for the **group_commission_structures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_commission_structures
    * const group_commission_structures = await prisma.group_commission_structures.findMany()
    * ```
    */
  get group_commission_structures(): Prisma.group_commission_structuresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_admin`: Exposes CRUD operations for the **ib_admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_admins
    * const ib_admins = await prisma.ib_admin.findMany()
    * ```
    */
  get ib_admin(): Prisma.ib_adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_requests`: Exposes CRUD operations for the **ib_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_requests
    * const ib_requests = await prisma.ib_requests.findMany()
    * ```
    */
  get ib_requests(): Prisma.ib_requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manual_gateway`: Exposes CRUD operations for the **manual_gateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manual_gateways
    * const manual_gateways = await prisma.manual_gateway.findMany()
    * ```
    */
  get manual_gateway(): Prisma.manual_gatewayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mt5_groups`: Exposes CRUD operations for the **mt5_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mt5_groups
    * const mt5_groups = await prisma.mt5_groups.findMany()
    * ```
    */
  get mt5_groups(): Prisma.mt5_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_gateway`: Exposes CRUD operations for the **payment_gateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_gateways
    * const payment_gateways = await prisma.payment_gateway.findMany()
    * ```
    */
  get payment_gateway(): Prisma.payment_gatewayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symbols`: Exposes CRUD operations for the **symbols** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Symbols
    * const symbols = await prisma.symbols.findMany()
    * ```
    */
  get symbols(): Prisma.symbolsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_group_assignments`: Exposes CRUD operations for the **ib_group_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_group_assignments
    * const ib_group_assignments = await prisma.ib_group_assignments.findMany()
    * ```
    */
  get ib_group_assignments(): Prisma.ib_group_assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_trade_history`: Exposes CRUD operations for the **ib_trade_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_trade_histories
    * const ib_trade_histories = await prisma.ib_trade_history.findMany()
    * ```
    */
  get ib_trade_history(): Prisma.ib_trade_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_tickets`: Exposes CRUD operations for the **support_tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_tickets
    * const support_tickets = await prisma.support_tickets.findMany()
    * ```
    */
  get support_tickets(): Prisma.support_ticketsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_ticket_replies`: Exposes CRUD operations for the **support_ticket_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_ticket_replies
    * const support_ticket_replies = await prisma.support_ticket_replies.findMany()
    * ```
    */
  get support_ticket_replies(): Prisma.support_ticket_repliesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_articles`: Exposes CRUD operations for the **support_articles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_articles
    * const support_articles = await prisma.support_articles.findMany()
    * ```
    */
  get support_articles(): Prisma.support_articlesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_faq`: Exposes CRUD operations for the **support_faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_faqs
    * const support_faqs = await prisma.support_faq.findMany()
    * ```
    */
  get support_faq(): Prisma.support_faqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_categories`: Exposes CRUD operations for the **support_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_categories
    * const support_categories = await prisma.support_categories.findMany()
    * ```
    */
  get support_categories(): Prisma.support_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.support_replies`: Exposes CRUD operations for the **support_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Support_replies
    * const support_replies = await prisma.support_replies.findMany()
    * ```
    */
  get support_replies(): Prisma.support_repliesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group_management`: Exposes CRUD operations for the **group_management** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Group_managements
    * const group_managements = await prisma.group_management.findMany()
    * ```
    */
  get group_management(): Prisma.group_managementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symbolGroupAccess`: Exposes CRUD operations for the **SymbolGroupAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SymbolGroupAccesses
    * const symbolGroupAccesses = await prisma.symbolGroupAccess.findMany()
    * ```
    */
  get symbolGroupAccess(): Prisma.SymbolGroupAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin_transactions`: Exposes CRUD operations for the **admin_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_transactions
    * const admin_transactions = await prisma.admin_transactions.findMany()
    * ```
    */
  get admin_transactions(): Prisma.admin_transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.countriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country_admins`: Exposes CRUD operations for the **country_admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Country_admins
    * const country_admins = await prisma.country_admins.findMany()
    * ```
    */
  get country_admins(): Prisma.country_adminsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_templates`: Exposes CRUD operations for the **email_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_templates
    * const email_templates = await prisma.email_templates.findMany()
    * ```
    */
  get email_templates(): Prisma.email_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_client_linking`: Exposes CRUD operations for the **ib_client_linking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_client_linkings
    * const ib_client_linkings = await prisma.ib_client_linking.findMany()
    * ```
    */
  get ib_client_linking(): Prisma.ib_client_linkingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_client_linking_history`: Exposes CRUD operations for the **ib_client_linking_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_client_linking_histories
    * const ib_client_linking_histories = await prisma.ib_client_linking_history.findMany()
    * ```
    */
  get ib_client_linking_history(): Prisma.ib_client_linking_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_commission`: Exposes CRUD operations for the **ib_commission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_commissions
    * const ib_commissions = await prisma.ib_commission.findMany()
    * ```
    */
  get ib_commission(): Prisma.ib_commissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_level_up_history`: Exposes CRUD operations for the **ib_level_up_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_level_up_histories
    * const ib_level_up_histories = await prisma.ib_level_up_history.findMany()
    * ```
    */
  get ib_level_up_history(): Prisma.ib_level_up_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_referrals`: Exposes CRUD operations for the **ib_referrals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_referrals
    * const ib_referrals = await prisma.ib_referrals.findMany()
    * ```
    */
  get ib_referrals(): Prisma.ib_referralsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_reward_claims`: Exposes CRUD operations for the **ib_reward_claims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_reward_claims
    * const ib_reward_claims = await prisma.ib_reward_claims.findMany()
    * ```
    */
  get ib_reward_claims(): Prisma.ib_reward_claimsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ib_withdrawal_requests`: Exposes CRUD operations for the **ib_withdrawal_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ib_withdrawal_requests
    * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findMany()
    * ```
    */
  get ib_withdrawal_requests(): Prisma.ib_withdrawal_requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sent_emails`: Exposes CRUD operations for the **sent_emails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sent_emails
    * const sent_emails = await prisma.sent_emails.findMany()
    * ```
    */
  get sent_emails(): Prisma.sent_emailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symbols_with_categories`: Exposes CRUD operations for the **symbols_with_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Symbols_with_categories
    * const symbols_with_categories = await prisma.symbols_with_categories.findMany()
    * ```
    */
  get symbols_with_categories(): Prisma.symbols_with_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suggestion`: Exposes CRUD operations for the **Suggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suggestions
    * const suggestions = await prisma.suggestion.findMany()
    * ```
    */
  get suggestion(): Prisma.SuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceAlert`: Exposes CRUD operations for the **PriceAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceAlerts
    * const priceAlerts = await prisma.priceAlert.findMany()
    * ```
    */
  get priceAlert(): Prisma.PriceAlertDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    KYC: 'KYC',
    MT5Account: 'MT5Account',
    MT5Transaction: 'MT5Transaction',
    Account: 'Account',
    Deposit: 'Deposit',
    CregisDeposit: 'CregisDeposit',
    Withdrawal: 'Withdrawal',
    Wallet: 'Wallet',
    WalletTransaction: 'WalletTransaction',
    ActivityLog: 'ActivityLog',
    SystemSetting: 'SystemSetting',
    Role: 'Role',
    PaymentMethod: 'PaymentMethod',
    UserRole: 'UserRole',
    DefaultMT5Account: 'DefaultMT5Account',
    Instrument: 'Instrument',
    RefreshToken: 'RefreshToken',
    UserFavorite: 'UserFavorite',
    UserLoginLog: 'UserLoginLog',
    TerminalSettings: 'TerminalSettings',
    admin: 'admin',
    admin_login_log: 'admin_login_log',
    balance_operation_history: 'balance_operation_history',
    chat_conversations: 'chat_conversations',
    chat_messages: 'chat_messages',
    chat_participants: 'chat_participants',
    group_commission_structures: 'group_commission_structures',
    ib_admin: 'ib_admin',
    ib_requests: 'ib_requests',
    manual_gateway: 'manual_gateway',
    mt5_groups: 'mt5_groups',
    payment_gateway: 'payment_gateway',
    symbols: 'symbols',
    ib_group_assignments: 'ib_group_assignments',
    ib_trade_history: 'ib_trade_history',
    support_tickets: 'support_tickets',
    support_ticket_replies: 'support_ticket_replies',
    support_articles: 'support_articles',
    support_faq: 'support_faq',
    support_categories: 'support_categories',
    support_replies: 'support_replies',
    Notification: 'Notification',
    group_management: 'group_management',
    SymbolGroupAccess: 'SymbolGroupAccess',
    Transaction: 'Transaction',
    admin_transactions: 'admin_transactions',
    countries: 'countries',
    country_admins: 'country_admins',
    email_templates: 'email_templates',
    ib_client_linking: 'ib_client_linking',
    ib_client_linking_history: 'ib_client_linking_history',
    ib_commission: 'ib_commission',
    ib_level_up_history: 'ib_level_up_history',
    ib_referrals: 'ib_referrals',
    ib_reward_claims: 'ib_reward_claims',
    ib_withdrawal_requests: 'ib_withdrawal_requests',
    sent_emails: 'sent_emails',
    symbols_with_categories: 'symbols_with_categories',
    Country: 'Country',
    Suggestion: 'Suggestion',
    PriceAlert: 'PriceAlert'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "kYC" | "mT5Account" | "mT5Transaction" | "account" | "deposit" | "cregisDeposit" | "withdrawal" | "wallet" | "walletTransaction" | "activityLog" | "systemSetting" | "role" | "paymentMethod" | "userRole" | "defaultMT5Account" | "instrument" | "refreshToken" | "userFavorite" | "userLoginLog" | "terminalSettings" | "admin" | "admin_login_log" | "balance_operation_history" | "chat_conversations" | "chat_messages" | "chat_participants" | "group_commission_structures" | "ib_admin" | "ib_requests" | "manual_gateway" | "mt5_groups" | "payment_gateway" | "symbols" | "ib_group_assignments" | "ib_trade_history" | "support_tickets" | "support_ticket_replies" | "support_articles" | "support_faq" | "support_categories" | "support_replies" | "notification" | "group_management" | "symbolGroupAccess" | "transaction" | "admin_transactions" | "countries" | "country_admins" | "email_templates" | "ib_client_linking" | "ib_client_linking_history" | "ib_commission" | "ib_level_up_history" | "ib_referrals" | "ib_reward_claims" | "ib_withdrawal_requests" | "sent_emails" | "symbols_with_categories" | "country" | "suggestion" | "priceAlert"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      KYC: {
        payload: Prisma.$KYCPayload<ExtArgs>
        fields: Prisma.KYCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          findFirst: {
            args: Prisma.KYCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          findMany: {
            args: Prisma.KYCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          create: {
            args: Prisma.KYCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          createMany: {
            args: Prisma.KYCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          delete: {
            args: Prisma.KYCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          update: {
            args: Prisma.KYCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          deleteMany: {
            args: Prisma.KYCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          upsert: {
            args: Prisma.KYCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          aggregate: {
            args: Prisma.KYCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYC>
          }
          groupBy: {
            args: Prisma.KYCGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCCountArgs<ExtArgs>
            result: $Utils.Optional<KYCCountAggregateOutputType> | number
          }
        }
      }
      MT5Account: {
        payload: Prisma.$MT5AccountPayload<ExtArgs>
        fields: Prisma.MT5AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MT5AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MT5AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          findFirst: {
            args: Prisma.MT5AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MT5AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          findMany: {
            args: Prisma.MT5AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          create: {
            args: Prisma.MT5AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          createMany: {
            args: Prisma.MT5AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MT5AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          delete: {
            args: Prisma.MT5AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          update: {
            args: Prisma.MT5AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          deleteMany: {
            args: Prisma.MT5AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MT5AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MT5AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>[]
          }
          upsert: {
            args: Prisma.MT5AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5AccountPayload>
          }
          aggregate: {
            args: Prisma.MT5AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMT5Account>
          }
          groupBy: {
            args: Prisma.MT5AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.MT5AccountCountArgs<ExtArgs>
            result: $Utils.Optional<MT5AccountCountAggregateOutputType> | number
          }
        }
      }
      MT5Transaction: {
        payload: Prisma.$MT5TransactionPayload<ExtArgs>
        fields: Prisma.MT5TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MT5TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MT5TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          findFirst: {
            args: Prisma.MT5TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MT5TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          findMany: {
            args: Prisma.MT5TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>[]
          }
          create: {
            args: Prisma.MT5TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          createMany: {
            args: Prisma.MT5TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MT5TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>[]
          }
          delete: {
            args: Prisma.MT5TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          update: {
            args: Prisma.MT5TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          deleteMany: {
            args: Prisma.MT5TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MT5TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MT5TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>[]
          }
          upsert: {
            args: Prisma.MT5TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MT5TransactionPayload>
          }
          aggregate: {
            args: Prisma.MT5TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMT5Transaction>
          }
          groupBy: {
            args: Prisma.MT5TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MT5TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MT5TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<MT5TransactionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Deposit: {
        payload: Prisma.$DepositPayload<ExtArgs>
        fields: Prisma.DepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findFirst: {
            args: Prisma.DepositFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          findMany: {
            args: Prisma.DepositFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          create: {
            args: Prisma.DepositCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          createMany: {
            args: Prisma.DepositCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepositCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          delete: {
            args: Prisma.DepositDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          update: {
            args: Prisma.DepositUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          deleteMany: {
            args: Prisma.DepositDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepositUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>[]
          }
          upsert: {
            args: Prisma.DepositUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositPayload>
          }
          aggregate: {
            args: Prisma.DepositAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposit>
          }
          groupBy: {
            args: Prisma.DepositGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositCountArgs<ExtArgs>
            result: $Utils.Optional<DepositCountAggregateOutputType> | number
          }
        }
      }
      CregisDeposit: {
        payload: Prisma.$CregisDepositPayload<ExtArgs>
        fields: Prisma.CregisDepositFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CregisDepositFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CregisDepositFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>
          }
          findFirst: {
            args: Prisma.CregisDepositFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CregisDepositFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>
          }
          findMany: {
            args: Prisma.CregisDepositFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>[]
          }
          create: {
            args: Prisma.CregisDepositCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>
          }
          createMany: {
            args: Prisma.CregisDepositCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CregisDepositCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>[]
          }
          delete: {
            args: Prisma.CregisDepositDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>
          }
          update: {
            args: Prisma.CregisDepositUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>
          }
          deleteMany: {
            args: Prisma.CregisDepositDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CregisDepositUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CregisDepositUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>[]
          }
          upsert: {
            args: Prisma.CregisDepositUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CregisDepositPayload>
          }
          aggregate: {
            args: Prisma.CregisDepositAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCregisDeposit>
          }
          groupBy: {
            args: Prisma.CregisDepositGroupByArgs<ExtArgs>
            result: $Utils.Optional<CregisDepositGroupByOutputType>[]
          }
          count: {
            args: Prisma.CregisDepositCountArgs<ExtArgs>
            result: $Utils.Optional<CregisDepositCountAggregateOutputType> | number
          }
        }
      }
      Withdrawal: {
        payload: Prisma.$WithdrawalPayload<ExtArgs>
        fields: Prisma.WithdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findFirst: {
            args: Prisma.WithdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          findMany: {
            args: Prisma.WithdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          create: {
            args: Prisma.WithdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          createMany: {
            args: Prisma.WithdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WithdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          delete: {
            args: Prisma.WithdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          update: {
            args: Prisma.WithdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WithdrawalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>[]
          }
          upsert: {
            args: Prisma.WithdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawal>
          }
          groupBy: {
            args: Prisma.WithdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      DefaultMT5Account: {
        payload: Prisma.$DefaultMT5AccountPayload<ExtArgs>
        fields: Prisma.DefaultMT5AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefaultMT5AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefaultMT5AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          findFirst: {
            args: Prisma.DefaultMT5AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefaultMT5AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          findMany: {
            args: Prisma.DefaultMT5AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>[]
          }
          create: {
            args: Prisma.DefaultMT5AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          createMany: {
            args: Prisma.DefaultMT5AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DefaultMT5AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>[]
          }
          delete: {
            args: Prisma.DefaultMT5AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          update: {
            args: Prisma.DefaultMT5AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          deleteMany: {
            args: Prisma.DefaultMT5AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DefaultMT5AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DefaultMT5AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>[]
          }
          upsert: {
            args: Prisma.DefaultMT5AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DefaultMT5AccountPayload>
          }
          aggregate: {
            args: Prisma.DefaultMT5AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDefaultMT5Account>
          }
          groupBy: {
            args: Prisma.DefaultMT5AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DefaultMT5AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefaultMT5AccountCountArgs<ExtArgs>
            result: $Utils.Optional<DefaultMT5AccountCountAggregateOutputType> | number
          }
        }
      }
      Instrument: {
        payload: Prisma.$InstrumentPayload<ExtArgs>
        fields: Prisma.InstrumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstrumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstrumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          findFirst: {
            args: Prisma.InstrumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstrumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          findMany: {
            args: Prisma.InstrumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>[]
          }
          create: {
            args: Prisma.InstrumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          createMany: {
            args: Prisma.InstrumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstrumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>[]
          }
          delete: {
            args: Prisma.InstrumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          update: {
            args: Prisma.InstrumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          deleteMany: {
            args: Prisma.InstrumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstrumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstrumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>[]
          }
          upsert: {
            args: Prisma.InstrumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstrumentPayload>
          }
          aggregate: {
            args: Prisma.InstrumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstrument>
          }
          groupBy: {
            args: Prisma.InstrumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstrumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstrumentCountArgs<ExtArgs>
            result: $Utils.Optional<InstrumentCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      UserFavorite: {
        payload: Prisma.$UserFavoritePayload<ExtArgs>
        fields: Prisma.UserFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          update: {
            args: Prisma.UserFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorite>
          }
          groupBy: {
            args: Prisma.UserFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteCountAggregateOutputType> | number
          }
        }
      }
      UserLoginLog: {
        payload: Prisma.$UserLoginLogPayload<ExtArgs>
        fields: Prisma.UserLoginLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLoginLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLoginLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>
          }
          findFirst: {
            args: Prisma.UserLoginLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLoginLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>
          }
          findMany: {
            args: Prisma.UserLoginLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>[]
          }
          create: {
            args: Prisma.UserLoginLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>
          }
          createMany: {
            args: Prisma.UserLoginLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLoginLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>[]
          }
          delete: {
            args: Prisma.UserLoginLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>
          }
          update: {
            args: Prisma.UserLoginLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>
          }
          deleteMany: {
            args: Prisma.UserLoginLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLoginLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLoginLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>[]
          }
          upsert: {
            args: Prisma.UserLoginLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginLogPayload>
          }
          aggregate: {
            args: Prisma.UserLoginLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLoginLog>
          }
          groupBy: {
            args: Prisma.UserLoginLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLoginLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLoginLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserLoginLogCountAggregateOutputType> | number
          }
        }
      }
      TerminalSettings: {
        payload: Prisma.$TerminalSettingsPayload<ExtArgs>
        fields: Prisma.TerminalSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerminalSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerminalSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>
          }
          findFirst: {
            args: Prisma.TerminalSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerminalSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>
          }
          findMany: {
            args: Prisma.TerminalSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>[]
          }
          create: {
            args: Prisma.TerminalSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>
          }
          createMany: {
            args: Prisma.TerminalSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerminalSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>[]
          }
          delete: {
            args: Prisma.TerminalSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>
          }
          update: {
            args: Prisma.TerminalSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TerminalSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerminalSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TerminalSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>[]
          }
          upsert: {
            args: Prisma.TerminalSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSettingsPayload>
          }
          aggregate: {
            args: Prisma.TerminalSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerminalSettings>
          }
          groupBy: {
            args: Prisma.TerminalSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerminalSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerminalSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TerminalSettingsCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      admin_login_log: {
        payload: Prisma.$admin_login_logPayload<ExtArgs>
        fields: Prisma.admin_login_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_login_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_login_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          findFirst: {
            args: Prisma.admin_login_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_login_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          findMany: {
            args: Prisma.admin_login_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>[]
          }
          create: {
            args: Prisma.admin_login_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          createMany: {
            args: Prisma.admin_login_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_login_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>[]
          }
          delete: {
            args: Prisma.admin_login_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          update: {
            args: Prisma.admin_login_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          deleteMany: {
            args: Prisma.admin_login_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_login_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admin_login_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>[]
          }
          upsert: {
            args: Prisma.admin_login_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_login_logPayload>
          }
          aggregate: {
            args: Prisma.Admin_login_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_login_log>
          }
          groupBy: {
            args: Prisma.admin_login_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_login_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_login_logCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_login_logCountAggregateOutputType> | number
          }
        }
      }
      balance_operation_history: {
        payload: Prisma.$balance_operation_historyPayload<ExtArgs>
        fields: Prisma.balance_operation_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.balance_operation_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.balance_operation_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          findFirst: {
            args: Prisma.balance_operation_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.balance_operation_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          findMany: {
            args: Prisma.balance_operation_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>[]
          }
          create: {
            args: Prisma.balance_operation_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          createMany: {
            args: Prisma.balance_operation_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.balance_operation_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>[]
          }
          delete: {
            args: Prisma.balance_operation_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          update: {
            args: Prisma.balance_operation_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          deleteMany: {
            args: Prisma.balance_operation_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.balance_operation_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.balance_operation_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>[]
          }
          upsert: {
            args: Prisma.balance_operation_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balance_operation_historyPayload>
          }
          aggregate: {
            args: Prisma.Balance_operation_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance_operation_history>
          }
          groupBy: {
            args: Prisma.balance_operation_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Balance_operation_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.balance_operation_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Balance_operation_historyCountAggregateOutputType> | number
          }
        }
      }
      chat_conversations: {
        payload: Prisma.$chat_conversationsPayload<ExtArgs>
        fields: Prisma.chat_conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_conversationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_conversationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          findFirst: {
            args: Prisma.chat_conversationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_conversationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          findMany: {
            args: Prisma.chat_conversationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>[]
          }
          create: {
            args: Prisma.chat_conversationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          createMany: {
            args: Prisma.chat_conversationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_conversationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>[]
          }
          delete: {
            args: Prisma.chat_conversationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          update: {
            args: Prisma.chat_conversationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          deleteMany: {
            args: Prisma.chat_conversationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_conversationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_conversationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>[]
          }
          upsert: {
            args: Prisma.chat_conversationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_conversationsPayload>
          }
          aggregate: {
            args: Prisma.Chat_conversationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_conversations>
          }
          groupBy: {
            args: Prisma.chat_conversationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_conversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_conversationsCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_conversationsCountAggregateOutputType> | number
          }
        }
      }
      chat_messages: {
        payload: Prisma.$chat_messagesPayload<ExtArgs>
        fields: Prisma.chat_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findFirst: {
            args: Prisma.chat_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          findMany: {
            args: Prisma.chat_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          create: {
            args: Prisma.chat_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          createMany: {
            args: Prisma.chat_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          delete: {
            args: Prisma.chat_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          update: {
            args: Prisma.chat_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          deleteMany: {
            args: Prisma.chat_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>[]
          }
          upsert: {
            args: Prisma.chat_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_messagesPayload>
          }
          aggregate: {
            args: Prisma.Chat_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_messages>
          }
          groupBy: {
            args: Prisma.chat_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_messagesCountAggregateOutputType> | number
          }
        }
      }
      chat_participants: {
        payload: Prisma.$chat_participantsPayload<ExtArgs>
        fields: Prisma.chat_participantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_participantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_participantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          findFirst: {
            args: Prisma.chat_participantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_participantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          findMany: {
            args: Prisma.chat_participantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>[]
          }
          create: {
            args: Prisma.chat_participantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          createMany: {
            args: Prisma.chat_participantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_participantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>[]
          }
          delete: {
            args: Prisma.chat_participantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          update: {
            args: Prisma.chat_participantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          deleteMany: {
            args: Prisma.chat_participantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_participantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_participantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>[]
          }
          upsert: {
            args: Prisma.chat_participantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_participantsPayload>
          }
          aggregate: {
            args: Prisma.Chat_participantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_participants>
          }
          groupBy: {
            args: Prisma.chat_participantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_participantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_participantsCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_participantsCountAggregateOutputType> | number
          }
        }
      }
      group_commission_structures: {
        payload: Prisma.$group_commission_structuresPayload<ExtArgs>
        fields: Prisma.group_commission_structuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_commission_structuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_commission_structuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          findFirst: {
            args: Prisma.group_commission_structuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_commission_structuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          findMany: {
            args: Prisma.group_commission_structuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>[]
          }
          create: {
            args: Prisma.group_commission_structuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          createMany: {
            args: Prisma.group_commission_structuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.group_commission_structuresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>[]
          }
          delete: {
            args: Prisma.group_commission_structuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          update: {
            args: Prisma.group_commission_structuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          deleteMany: {
            args: Prisma.group_commission_structuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_commission_structuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.group_commission_structuresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>[]
          }
          upsert: {
            args: Prisma.group_commission_structuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_commission_structuresPayload>
          }
          aggregate: {
            args: Prisma.Group_commission_structuresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_commission_structures>
          }
          groupBy: {
            args: Prisma.group_commission_structuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_commission_structuresGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_commission_structuresCountArgs<ExtArgs>
            result: $Utils.Optional<Group_commission_structuresCountAggregateOutputType> | number
          }
        }
      }
      ib_admin: {
        payload: Prisma.$ib_adminPayload<ExtArgs>
        fields: Prisma.ib_adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          findFirst: {
            args: Prisma.ib_adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          findMany: {
            args: Prisma.ib_adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>[]
          }
          create: {
            args: Prisma.ib_adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          createMany: {
            args: Prisma.ib_adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>[]
          }
          delete: {
            args: Prisma.ib_adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          update: {
            args: Prisma.ib_adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          deleteMany: {
            args: Prisma.ib_adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>[]
          }
          upsert: {
            args: Prisma.ib_adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_adminPayload>
          }
          aggregate: {
            args: Prisma.Ib_adminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_admin>
          }
          groupBy: {
            args: Prisma.ib_adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_adminGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_adminCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_adminCountAggregateOutputType> | number
          }
        }
      }
      ib_requests: {
        payload: Prisma.$ib_requestsPayload<ExtArgs>
        fields: Prisma.ib_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          findFirst: {
            args: Prisma.ib_requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          findMany: {
            args: Prisma.ib_requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>[]
          }
          create: {
            args: Prisma.ib_requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          createMany: {
            args: Prisma.ib_requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_requestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>[]
          }
          delete: {
            args: Prisma.ib_requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          update: {
            args: Prisma.ib_requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          deleteMany: {
            args: Prisma.ib_requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_requestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>[]
          }
          upsert: {
            args: Prisma.ib_requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_requestsPayload>
          }
          aggregate: {
            args: Prisma.Ib_requestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_requests>
          }
          groupBy: {
            args: Prisma.ib_requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_requestsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_requestsCountAggregateOutputType> | number
          }
        }
      }
      manual_gateway: {
        payload: Prisma.$manual_gatewayPayload<ExtArgs>
        fields: Prisma.manual_gatewayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manual_gatewayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manual_gatewayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          findFirst: {
            args: Prisma.manual_gatewayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manual_gatewayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          findMany: {
            args: Prisma.manual_gatewayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>[]
          }
          create: {
            args: Prisma.manual_gatewayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          createMany: {
            args: Prisma.manual_gatewayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.manual_gatewayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>[]
          }
          delete: {
            args: Prisma.manual_gatewayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          update: {
            args: Prisma.manual_gatewayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          deleteMany: {
            args: Prisma.manual_gatewayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.manual_gatewayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.manual_gatewayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>[]
          }
          upsert: {
            args: Prisma.manual_gatewayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manual_gatewayPayload>
          }
          aggregate: {
            args: Prisma.Manual_gatewayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManual_gateway>
          }
          groupBy: {
            args: Prisma.manual_gatewayGroupByArgs<ExtArgs>
            result: $Utils.Optional<Manual_gatewayGroupByOutputType>[]
          }
          count: {
            args: Prisma.manual_gatewayCountArgs<ExtArgs>
            result: $Utils.Optional<Manual_gatewayCountAggregateOutputType> | number
          }
        }
      }
      mt5_groups: {
        payload: Prisma.$mt5_groupsPayload<ExtArgs>
        fields: Prisma.mt5_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mt5_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mt5_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          findFirst: {
            args: Prisma.mt5_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mt5_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          findMany: {
            args: Prisma.mt5_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>[]
          }
          create: {
            args: Prisma.mt5_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          createMany: {
            args: Prisma.mt5_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mt5_groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>[]
          }
          delete: {
            args: Prisma.mt5_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          update: {
            args: Prisma.mt5_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          deleteMany: {
            args: Prisma.mt5_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mt5_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mt5_groupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>[]
          }
          upsert: {
            args: Prisma.mt5_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mt5_groupsPayload>
          }
          aggregate: {
            args: Prisma.Mt5_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMt5_groups>
          }
          groupBy: {
            args: Prisma.mt5_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mt5_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mt5_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Mt5_groupsCountAggregateOutputType> | number
          }
        }
      }
      payment_gateway: {
        payload: Prisma.$payment_gatewayPayload<ExtArgs>
        fields: Prisma.payment_gatewayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_gatewayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_gatewayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          findFirst: {
            args: Prisma.payment_gatewayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_gatewayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          findMany: {
            args: Prisma.payment_gatewayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>[]
          }
          create: {
            args: Prisma.payment_gatewayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          createMany: {
            args: Prisma.payment_gatewayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_gatewayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>[]
          }
          delete: {
            args: Prisma.payment_gatewayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          update: {
            args: Prisma.payment_gatewayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          deleteMany: {
            args: Prisma.payment_gatewayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_gatewayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_gatewayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>[]
          }
          upsert: {
            args: Prisma.payment_gatewayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_gatewayPayload>
          }
          aggregate: {
            args: Prisma.Payment_gatewayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_gateway>
          }
          groupBy: {
            args: Prisma.payment_gatewayGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_gatewayGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_gatewayCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_gatewayCountAggregateOutputType> | number
          }
        }
      }
      symbols: {
        payload: Prisma.$symbolsPayload<ExtArgs>
        fields: Prisma.symbolsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.symbolsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.symbolsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          findFirst: {
            args: Prisma.symbolsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.symbolsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          findMany: {
            args: Prisma.symbolsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>[]
          }
          create: {
            args: Prisma.symbolsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          createMany: {
            args: Prisma.symbolsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.symbolsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>[]
          }
          delete: {
            args: Prisma.symbolsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          update: {
            args: Prisma.symbolsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          deleteMany: {
            args: Prisma.symbolsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.symbolsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.symbolsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>[]
          }
          upsert: {
            args: Prisma.symbolsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbolsPayload>
          }
          aggregate: {
            args: Prisma.SymbolsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymbols>
          }
          groupBy: {
            args: Prisma.symbolsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymbolsGroupByOutputType>[]
          }
          count: {
            args: Prisma.symbolsCountArgs<ExtArgs>
            result: $Utils.Optional<SymbolsCountAggregateOutputType> | number
          }
        }
      }
      ib_group_assignments: {
        payload: Prisma.$ib_group_assignmentsPayload<ExtArgs>
        fields: Prisma.ib_group_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_group_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_group_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.ib_group_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_group_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          findMany: {
            args: Prisma.ib_group_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>[]
          }
          create: {
            args: Prisma.ib_group_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          createMany: {
            args: Prisma.ib_group_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_group_assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>[]
          }
          delete: {
            args: Prisma.ib_group_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          update: {
            args: Prisma.ib_group_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.ib_group_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_group_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_group_assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.ib_group_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_group_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.Ib_group_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_group_assignments>
          }
          groupBy: {
            args: Prisma.ib_group_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_group_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_group_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_group_assignmentsCountAggregateOutputType> | number
          }
        }
      }
      ib_trade_history: {
        payload: Prisma.$ib_trade_historyPayload<ExtArgs>
        fields: Prisma.ib_trade_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_trade_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_trade_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          findFirst: {
            args: Prisma.ib_trade_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_trade_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          findMany: {
            args: Prisma.ib_trade_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>[]
          }
          create: {
            args: Prisma.ib_trade_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          createMany: {
            args: Prisma.ib_trade_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_trade_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>[]
          }
          delete: {
            args: Prisma.ib_trade_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          update: {
            args: Prisma.ib_trade_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          deleteMany: {
            args: Prisma.ib_trade_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_trade_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_trade_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>[]
          }
          upsert: {
            args: Prisma.ib_trade_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_trade_historyPayload>
          }
          aggregate: {
            args: Prisma.Ib_trade_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_trade_history>
          }
          groupBy: {
            args: Prisma.ib_trade_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_trade_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_trade_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_trade_historyCountAggregateOutputType> | number
          }
        }
      }
      support_tickets: {
        payload: Prisma.$support_ticketsPayload<ExtArgs>
        fields: Prisma.support_ticketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_ticketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_ticketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          findFirst: {
            args: Prisma.support_ticketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_ticketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          findMany: {
            args: Prisma.support_ticketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>[]
          }
          create: {
            args: Prisma.support_ticketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          createMany: {
            args: Prisma.support_ticketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_ticketsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>[]
          }
          delete: {
            args: Prisma.support_ticketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          update: {
            args: Prisma.support_ticketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          deleteMany: {
            args: Prisma.support_ticketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_ticketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_ticketsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>[]
          }
          upsert: {
            args: Prisma.support_ticketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticketsPayload>
          }
          aggregate: {
            args: Prisma.Support_ticketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_tickets>
          }
          groupBy: {
            args: Prisma.support_ticketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_ticketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_ticketsCountArgs<ExtArgs>
            result: $Utils.Optional<Support_ticketsCountAggregateOutputType> | number
          }
        }
      }
      support_ticket_replies: {
        payload: Prisma.$support_ticket_repliesPayload<ExtArgs>
        fields: Prisma.support_ticket_repliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_ticket_repliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_ticket_repliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          findFirst: {
            args: Prisma.support_ticket_repliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_ticket_repliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          findMany: {
            args: Prisma.support_ticket_repliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>[]
          }
          create: {
            args: Prisma.support_ticket_repliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          createMany: {
            args: Prisma.support_ticket_repliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_ticket_repliesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>[]
          }
          delete: {
            args: Prisma.support_ticket_repliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          update: {
            args: Prisma.support_ticket_repliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          deleteMany: {
            args: Prisma.support_ticket_repliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_ticket_repliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_ticket_repliesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>[]
          }
          upsert: {
            args: Prisma.support_ticket_repliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_ticket_repliesPayload>
          }
          aggregate: {
            args: Prisma.Support_ticket_repliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_ticket_replies>
          }
          groupBy: {
            args: Prisma.support_ticket_repliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_ticket_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_ticket_repliesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_ticket_repliesCountAggregateOutputType> | number
          }
        }
      }
      support_articles: {
        payload: Prisma.$support_articlesPayload<ExtArgs>
        fields: Prisma.support_articlesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_articlesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_articlesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          findFirst: {
            args: Prisma.support_articlesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_articlesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          findMany: {
            args: Prisma.support_articlesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>[]
          }
          create: {
            args: Prisma.support_articlesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          createMany: {
            args: Prisma.support_articlesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_articlesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>[]
          }
          delete: {
            args: Prisma.support_articlesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          update: {
            args: Prisma.support_articlesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          deleteMany: {
            args: Prisma.support_articlesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_articlesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_articlesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>[]
          }
          upsert: {
            args: Prisma.support_articlesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_articlesPayload>
          }
          aggregate: {
            args: Prisma.Support_articlesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_articles>
          }
          groupBy: {
            args: Prisma.support_articlesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_articlesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_articlesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_articlesCountAggregateOutputType> | number
          }
        }
      }
      support_faq: {
        payload: Prisma.$support_faqPayload<ExtArgs>
        fields: Prisma.support_faqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_faqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_faqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          findFirst: {
            args: Prisma.support_faqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_faqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          findMany: {
            args: Prisma.support_faqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>[]
          }
          create: {
            args: Prisma.support_faqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          createMany: {
            args: Prisma.support_faqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_faqCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>[]
          }
          delete: {
            args: Prisma.support_faqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          update: {
            args: Prisma.support_faqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          deleteMany: {
            args: Prisma.support_faqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_faqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_faqUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>[]
          }
          upsert: {
            args: Prisma.support_faqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_faqPayload>
          }
          aggregate: {
            args: Prisma.Support_faqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_faq>
          }
          groupBy: {
            args: Prisma.support_faqGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_faqGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_faqCountArgs<ExtArgs>
            result: $Utils.Optional<Support_faqCountAggregateOutputType> | number
          }
        }
      }
      support_categories: {
        payload: Prisma.$support_categoriesPayload<ExtArgs>
        fields: Prisma.support_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          findFirst: {
            args: Prisma.support_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          findMany: {
            args: Prisma.support_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>[]
          }
          create: {
            args: Prisma.support_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          createMany: {
            args: Prisma.support_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>[]
          }
          delete: {
            args: Prisma.support_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          update: {
            args: Prisma.support_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.support_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.support_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Support_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_categories>
          }
          groupBy: {
            args: Prisma.support_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_categoriesCountAggregateOutputType> | number
          }
        }
      }
      support_replies: {
        payload: Prisma.$support_repliesPayload<ExtArgs>
        fields: Prisma.support_repliesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.support_repliesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.support_repliesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          findFirst: {
            args: Prisma.support_repliesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.support_repliesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          findMany: {
            args: Prisma.support_repliesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>[]
          }
          create: {
            args: Prisma.support_repliesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          createMany: {
            args: Prisma.support_repliesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.support_repliesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>[]
          }
          delete: {
            args: Prisma.support_repliesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          update: {
            args: Prisma.support_repliesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          deleteMany: {
            args: Prisma.support_repliesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.support_repliesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.support_repliesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>[]
          }
          upsert: {
            args: Prisma.support_repliesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$support_repliesPayload>
          }
          aggregate: {
            args: Prisma.Support_repliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupport_replies>
          }
          groupBy: {
            args: Prisma.support_repliesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Support_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.support_repliesCountArgs<ExtArgs>
            result: $Utils.Optional<Support_repliesCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      group_management: {
        payload: Prisma.$group_managementPayload<ExtArgs>
        fields: Prisma.group_managementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.group_managementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.group_managementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>
          }
          findFirst: {
            args: Prisma.group_managementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.group_managementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>
          }
          findMany: {
            args: Prisma.group_managementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>[]
          }
          create: {
            args: Prisma.group_managementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>
          }
          createMany: {
            args: Prisma.group_managementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.group_managementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>[]
          }
          delete: {
            args: Prisma.group_managementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>
          }
          update: {
            args: Prisma.group_managementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>
          }
          deleteMany: {
            args: Prisma.group_managementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.group_managementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.group_managementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>[]
          }
          upsert: {
            args: Prisma.group_managementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$group_managementPayload>
          }
          aggregate: {
            args: Prisma.Group_managementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup_management>
          }
          groupBy: {
            args: Prisma.group_managementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Group_managementGroupByOutputType>[]
          }
          count: {
            args: Prisma.group_managementCountArgs<ExtArgs>
            result: $Utils.Optional<Group_managementCountAggregateOutputType> | number
          }
        }
      }
      SymbolGroupAccess: {
        payload: Prisma.$SymbolGroupAccessPayload<ExtArgs>
        fields: Prisma.SymbolGroupAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SymbolGroupAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SymbolGroupAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>
          }
          findFirst: {
            args: Prisma.SymbolGroupAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SymbolGroupAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>
          }
          findMany: {
            args: Prisma.SymbolGroupAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>[]
          }
          create: {
            args: Prisma.SymbolGroupAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>
          }
          createMany: {
            args: Prisma.SymbolGroupAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SymbolGroupAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>[]
          }
          delete: {
            args: Prisma.SymbolGroupAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>
          }
          update: {
            args: Prisma.SymbolGroupAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>
          }
          deleteMany: {
            args: Prisma.SymbolGroupAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SymbolGroupAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SymbolGroupAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>[]
          }
          upsert: {
            args: Prisma.SymbolGroupAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymbolGroupAccessPayload>
          }
          aggregate: {
            args: Prisma.SymbolGroupAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymbolGroupAccess>
          }
          groupBy: {
            args: Prisma.SymbolGroupAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymbolGroupAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.SymbolGroupAccessCountArgs<ExtArgs>
            result: $Utils.Optional<SymbolGroupAccessCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      admin_transactions: {
        payload: Prisma.$admin_transactionsPayload<ExtArgs>
        fields: Prisma.admin_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>
          }
          findFirst: {
            args: Prisma.admin_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>
          }
          findMany: {
            args: Prisma.admin_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>[]
          }
          create: {
            args: Prisma.admin_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>
          }
          createMany: {
            args: Prisma.admin_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>[]
          }
          delete: {
            args: Prisma.admin_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>
          }
          update: {
            args: Prisma.admin_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.admin_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admin_transactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>[]
          }
          upsert: {
            args: Prisma.admin_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Admin_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_transactions>
          }
          groupBy: {
            args: Prisma.admin_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_transactionsCountAggregateOutputType> | number
          }
        }
      }
      countries: {
        payload: Prisma.$countriesPayload<ExtArgs>
        fields: Prisma.countriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.countriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.countriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          findFirst: {
            args: Prisma.countriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.countriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          findMany: {
            args: Prisma.countriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>[]
          }
          create: {
            args: Prisma.countriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          createMany: {
            args: Prisma.countriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.countriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>[]
          }
          delete: {
            args: Prisma.countriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          update: {
            args: Prisma.countriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          deleteMany: {
            args: Prisma.countriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.countriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.countriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>[]
          }
          upsert: {
            args: Prisma.countriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          aggregate: {
            args: Prisma.CountriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountries>
          }
          groupBy: {
            args: Prisma.countriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.countriesCountArgs<ExtArgs>
            result: $Utils.Optional<CountriesCountAggregateOutputType> | number
          }
        }
      }
      country_admins: {
        payload: Prisma.$country_adminsPayload<ExtArgs>
        fields: Prisma.country_adminsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.country_adminsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.country_adminsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>
          }
          findFirst: {
            args: Prisma.country_adminsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.country_adminsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>
          }
          findMany: {
            args: Prisma.country_adminsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>[]
          }
          create: {
            args: Prisma.country_adminsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>
          }
          createMany: {
            args: Prisma.country_adminsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.country_adminsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>[]
          }
          delete: {
            args: Prisma.country_adminsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>
          }
          update: {
            args: Prisma.country_adminsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>
          }
          deleteMany: {
            args: Prisma.country_adminsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.country_adminsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.country_adminsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>[]
          }
          upsert: {
            args: Prisma.country_adminsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$country_adminsPayload>
          }
          aggregate: {
            args: Prisma.Country_adminsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry_admins>
          }
          groupBy: {
            args: Prisma.country_adminsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Country_adminsGroupByOutputType>[]
          }
          count: {
            args: Prisma.country_adminsCountArgs<ExtArgs>
            result: $Utils.Optional<Country_adminsCountAggregateOutputType> | number
          }
        }
      }
      email_templates: {
        payload: Prisma.$email_templatesPayload<ExtArgs>
        fields: Prisma.email_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          findFirst: {
            args: Prisma.email_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          findMany: {
            args: Prisma.email_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          create: {
            args: Prisma.email_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          createMany: {
            args: Prisma.email_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          delete: {
            args: Prisma.email_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          update: {
            args: Prisma.email_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          deleteMany: {
            args: Prisma.email_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          upsert: {
            args: Prisma.email_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          aggregate: {
            args: Prisma.Email_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_templates>
          }
          groupBy: {
            args: Prisma.email_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Email_templatesCountAggregateOutputType> | number
          }
        }
      }
      ib_client_linking: {
        payload: Prisma.$ib_client_linkingPayload<ExtArgs>
        fields: Prisma.ib_client_linkingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_client_linkingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_client_linkingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>
          }
          findFirst: {
            args: Prisma.ib_client_linkingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_client_linkingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>
          }
          findMany: {
            args: Prisma.ib_client_linkingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>[]
          }
          create: {
            args: Prisma.ib_client_linkingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>
          }
          createMany: {
            args: Prisma.ib_client_linkingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_client_linkingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>[]
          }
          delete: {
            args: Prisma.ib_client_linkingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>
          }
          update: {
            args: Prisma.ib_client_linkingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>
          }
          deleteMany: {
            args: Prisma.ib_client_linkingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_client_linkingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_client_linkingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>[]
          }
          upsert: {
            args: Prisma.ib_client_linkingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linkingPayload>
          }
          aggregate: {
            args: Prisma.Ib_client_linkingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_client_linking>
          }
          groupBy: {
            args: Prisma.ib_client_linkingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_client_linkingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_client_linkingCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_client_linkingCountAggregateOutputType> | number
          }
        }
      }
      ib_client_linking_history: {
        payload: Prisma.$ib_client_linking_historyPayload<ExtArgs>
        fields: Prisma.ib_client_linking_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_client_linking_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_client_linking_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>
          }
          findFirst: {
            args: Prisma.ib_client_linking_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_client_linking_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>
          }
          findMany: {
            args: Prisma.ib_client_linking_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>[]
          }
          create: {
            args: Prisma.ib_client_linking_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>
          }
          createMany: {
            args: Prisma.ib_client_linking_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_client_linking_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>[]
          }
          delete: {
            args: Prisma.ib_client_linking_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>
          }
          update: {
            args: Prisma.ib_client_linking_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>
          }
          deleteMany: {
            args: Prisma.ib_client_linking_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_client_linking_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_client_linking_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>[]
          }
          upsert: {
            args: Prisma.ib_client_linking_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_client_linking_historyPayload>
          }
          aggregate: {
            args: Prisma.Ib_client_linking_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_client_linking_history>
          }
          groupBy: {
            args: Prisma.ib_client_linking_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_client_linking_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_client_linking_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_client_linking_historyCountAggregateOutputType> | number
          }
        }
      }
      ib_commission: {
        payload: Prisma.$ib_commissionPayload<ExtArgs>
        fields: Prisma.ib_commissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_commissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_commissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>
          }
          findFirst: {
            args: Prisma.ib_commissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_commissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>
          }
          findMany: {
            args: Prisma.ib_commissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>[]
          }
          create: {
            args: Prisma.ib_commissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>
          }
          createMany: {
            args: Prisma.ib_commissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_commissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>[]
          }
          delete: {
            args: Prisma.ib_commissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>
          }
          update: {
            args: Prisma.ib_commissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>
          }
          deleteMany: {
            args: Prisma.ib_commissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_commissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_commissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>[]
          }
          upsert: {
            args: Prisma.ib_commissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_commissionPayload>
          }
          aggregate: {
            args: Prisma.Ib_commissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_commission>
          }
          groupBy: {
            args: Prisma.ib_commissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_commissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_commissionCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_commissionCountAggregateOutputType> | number
          }
        }
      }
      ib_level_up_history: {
        payload: Prisma.$ib_level_up_historyPayload<ExtArgs>
        fields: Prisma.ib_level_up_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_level_up_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_level_up_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>
          }
          findFirst: {
            args: Prisma.ib_level_up_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_level_up_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>
          }
          findMany: {
            args: Prisma.ib_level_up_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>[]
          }
          create: {
            args: Prisma.ib_level_up_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>
          }
          createMany: {
            args: Prisma.ib_level_up_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_level_up_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>[]
          }
          delete: {
            args: Prisma.ib_level_up_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>
          }
          update: {
            args: Prisma.ib_level_up_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>
          }
          deleteMany: {
            args: Prisma.ib_level_up_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_level_up_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_level_up_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>[]
          }
          upsert: {
            args: Prisma.ib_level_up_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_level_up_historyPayload>
          }
          aggregate: {
            args: Prisma.Ib_level_up_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_level_up_history>
          }
          groupBy: {
            args: Prisma.ib_level_up_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_level_up_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_level_up_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_level_up_historyCountAggregateOutputType> | number
          }
        }
      }
      ib_referrals: {
        payload: Prisma.$ib_referralsPayload<ExtArgs>
        fields: Prisma.ib_referralsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_referralsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_referralsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>
          }
          findFirst: {
            args: Prisma.ib_referralsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_referralsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>
          }
          findMany: {
            args: Prisma.ib_referralsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>[]
          }
          create: {
            args: Prisma.ib_referralsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>
          }
          createMany: {
            args: Prisma.ib_referralsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_referralsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>[]
          }
          delete: {
            args: Prisma.ib_referralsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>
          }
          update: {
            args: Prisma.ib_referralsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>
          }
          deleteMany: {
            args: Prisma.ib_referralsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_referralsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_referralsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>[]
          }
          upsert: {
            args: Prisma.ib_referralsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_referralsPayload>
          }
          aggregate: {
            args: Prisma.Ib_referralsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_referrals>
          }
          groupBy: {
            args: Prisma.ib_referralsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_referralsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_referralsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_referralsCountAggregateOutputType> | number
          }
        }
      }
      ib_reward_claims: {
        payload: Prisma.$ib_reward_claimsPayload<ExtArgs>
        fields: Prisma.ib_reward_claimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_reward_claimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_reward_claimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>
          }
          findFirst: {
            args: Prisma.ib_reward_claimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_reward_claimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>
          }
          findMany: {
            args: Prisma.ib_reward_claimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>[]
          }
          create: {
            args: Prisma.ib_reward_claimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>
          }
          createMany: {
            args: Prisma.ib_reward_claimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_reward_claimsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>[]
          }
          delete: {
            args: Prisma.ib_reward_claimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>
          }
          update: {
            args: Prisma.ib_reward_claimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>
          }
          deleteMany: {
            args: Prisma.ib_reward_claimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_reward_claimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_reward_claimsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>[]
          }
          upsert: {
            args: Prisma.ib_reward_claimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_reward_claimsPayload>
          }
          aggregate: {
            args: Prisma.Ib_reward_claimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_reward_claims>
          }
          groupBy: {
            args: Prisma.ib_reward_claimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_reward_claimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_reward_claimsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_reward_claimsCountAggregateOutputType> | number
          }
        }
      }
      ib_withdrawal_requests: {
        payload: Prisma.$ib_withdrawal_requestsPayload<ExtArgs>
        fields: Prisma.ib_withdrawal_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ib_withdrawal_requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ib_withdrawal_requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>
          }
          findFirst: {
            args: Prisma.ib_withdrawal_requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ib_withdrawal_requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>
          }
          findMany: {
            args: Prisma.ib_withdrawal_requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>[]
          }
          create: {
            args: Prisma.ib_withdrawal_requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>
          }
          createMany: {
            args: Prisma.ib_withdrawal_requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ib_withdrawal_requestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>[]
          }
          delete: {
            args: Prisma.ib_withdrawal_requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>
          }
          update: {
            args: Prisma.ib_withdrawal_requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>
          }
          deleteMany: {
            args: Prisma.ib_withdrawal_requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ib_withdrawal_requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ib_withdrawal_requestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>[]
          }
          upsert: {
            args: Prisma.ib_withdrawal_requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ib_withdrawal_requestsPayload>
          }
          aggregate: {
            args: Prisma.Ib_withdrawal_requestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIb_withdrawal_requests>
          }
          groupBy: {
            args: Prisma.ib_withdrawal_requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ib_withdrawal_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ib_withdrawal_requestsCountArgs<ExtArgs>
            result: $Utils.Optional<Ib_withdrawal_requestsCountAggregateOutputType> | number
          }
        }
      }
      sent_emails: {
        payload: Prisma.$sent_emailsPayload<ExtArgs>
        fields: Prisma.sent_emailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sent_emailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sent_emailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>
          }
          findFirst: {
            args: Prisma.sent_emailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sent_emailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>
          }
          findMany: {
            args: Prisma.sent_emailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>[]
          }
          create: {
            args: Prisma.sent_emailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>
          }
          createMany: {
            args: Prisma.sent_emailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sent_emailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>[]
          }
          delete: {
            args: Prisma.sent_emailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>
          }
          update: {
            args: Prisma.sent_emailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>
          }
          deleteMany: {
            args: Prisma.sent_emailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sent_emailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sent_emailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>[]
          }
          upsert: {
            args: Prisma.sent_emailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sent_emailsPayload>
          }
          aggregate: {
            args: Prisma.Sent_emailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSent_emails>
          }
          groupBy: {
            args: Prisma.sent_emailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sent_emailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sent_emailsCountArgs<ExtArgs>
            result: $Utils.Optional<Sent_emailsCountAggregateOutputType> | number
          }
        }
      }
      symbols_with_categories: {
        payload: Prisma.$symbols_with_categoriesPayload<ExtArgs>
        fields: Prisma.symbols_with_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.symbols_with_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.symbols_with_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>
          }
          findFirst: {
            args: Prisma.symbols_with_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.symbols_with_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>
          }
          findMany: {
            args: Prisma.symbols_with_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>[]
          }
          create: {
            args: Prisma.symbols_with_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>
          }
          createMany: {
            args: Prisma.symbols_with_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.symbols_with_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>[]
          }
          delete: {
            args: Prisma.symbols_with_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>
          }
          update: {
            args: Prisma.symbols_with_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.symbols_with_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.symbols_with_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.symbols_with_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.symbols_with_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$symbols_with_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Symbols_with_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymbols_with_categories>
          }
          groupBy: {
            args: Prisma.symbols_with_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Symbols_with_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.symbols_with_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Symbols_with_categoriesCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Suggestion: {
        payload: Prisma.$SuggestionPayload<ExtArgs>
        fields: Prisma.SuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          findFirst: {
            args: Prisma.SuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          findMany: {
            args: Prisma.SuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          create: {
            args: Prisma.SuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          createMany: {
            args: Prisma.SuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          delete: {
            args: Prisma.SuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          update: {
            args: Prisma.SuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          deleteMany: {
            args: Prisma.SuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          upsert: {
            args: Prisma.SuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          aggregate: {
            args: Prisma.SuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestion>
          }
          groupBy: {
            args: Prisma.SuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestionCountAggregateOutputType> | number
          }
        }
      }
      PriceAlert: {
        payload: Prisma.$PriceAlertPayload<ExtArgs>
        fields: Prisma.PriceAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          findFirst: {
            args: Prisma.PriceAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          findMany: {
            args: Prisma.PriceAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>[]
          }
          create: {
            args: Prisma.PriceAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          createMany: {
            args: Prisma.PriceAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>[]
          }
          delete: {
            args: Prisma.PriceAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          update: {
            args: Prisma.PriceAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          deleteMany: {
            args: Prisma.PriceAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>[]
          }
          upsert: {
            args: Prisma.PriceAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceAlertPayload>
          }
          aggregate: {
            args: Prisma.PriceAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceAlert>
          }
          groupBy: {
            args: Prisma.PriceAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceAlertCountArgs<ExtArgs>
            result: $Utils.Optional<PriceAlertCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    kYC?: KYCOmit
    mT5Account?: MT5AccountOmit
    mT5Transaction?: MT5TransactionOmit
    account?: AccountOmit
    deposit?: DepositOmit
    cregisDeposit?: CregisDepositOmit
    withdrawal?: WithdrawalOmit
    wallet?: WalletOmit
    walletTransaction?: WalletTransactionOmit
    activityLog?: ActivityLogOmit
    systemSetting?: SystemSettingOmit
    role?: RoleOmit
    paymentMethod?: PaymentMethodOmit
    userRole?: UserRoleOmit
    defaultMT5Account?: DefaultMT5AccountOmit
    instrument?: InstrumentOmit
    refreshToken?: RefreshTokenOmit
    userFavorite?: UserFavoriteOmit
    userLoginLog?: UserLoginLogOmit
    terminalSettings?: TerminalSettingsOmit
    admin?: adminOmit
    admin_login_log?: admin_login_logOmit
    balance_operation_history?: balance_operation_historyOmit
    chat_conversations?: chat_conversationsOmit
    chat_messages?: chat_messagesOmit
    chat_participants?: chat_participantsOmit
    group_commission_structures?: group_commission_structuresOmit
    ib_admin?: ib_adminOmit
    ib_requests?: ib_requestsOmit
    manual_gateway?: manual_gatewayOmit
    mt5_groups?: mt5_groupsOmit
    payment_gateway?: payment_gatewayOmit
    symbols?: symbolsOmit
    ib_group_assignments?: ib_group_assignmentsOmit
    ib_trade_history?: ib_trade_historyOmit
    support_tickets?: support_ticketsOmit
    support_ticket_replies?: support_ticket_repliesOmit
    support_articles?: support_articlesOmit
    support_faq?: support_faqOmit
    support_categories?: support_categoriesOmit
    support_replies?: support_repliesOmit
    notification?: NotificationOmit
    group_management?: group_managementOmit
    symbolGroupAccess?: SymbolGroupAccessOmit
    transaction?: TransactionOmit
    admin_transactions?: admin_transactionsOmit
    countries?: countriesOmit
    country_admins?: country_adminsOmit
    email_templates?: email_templatesOmit
    ib_client_linking?: ib_client_linkingOmit
    ib_client_linking_history?: ib_client_linking_historyOmit
    ib_commission?: ib_commissionOmit
    ib_level_up_history?: ib_level_up_historyOmit
    ib_referrals?: ib_referralsOmit
    ib_reward_claims?: ib_reward_claimsOmit
    ib_withdrawal_requests?: ib_withdrawal_requestsOmit
    sent_emails?: sent_emailsOmit
    symbols_with_categories?: symbols_with_categoriesOmit
    country?: CountryOmit
    suggestion?: SuggestionOmit
    priceAlert?: PriceAlertOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    activityLogs: number
    deposits: number
    mt5Accounts: number
    notifications: number
    RefreshToken: number
    UserFavorite: number
    userLoginLogs: number
    suggestions: number
    priceAlerts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    deposits?: boolean | UserCountOutputTypeCountDepositsArgs
    mt5Accounts?: boolean | UserCountOutputTypeCountMt5AccountsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    RefreshToken?: boolean | UserCountOutputTypeCountRefreshTokenArgs
    UserFavorite?: boolean | UserCountOutputTypeCountUserFavoriteArgs
    userLoginLogs?: boolean | UserCountOutputTypeCountUserLoginLogsArgs
    suggestions?: boolean | UserCountOutputTypeCountSuggestionsArgs
    priceAlerts?: boolean | UserCountOutputTypeCountPriceAlertsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMt5AccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLoginLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPriceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceAlertWhereInput
  }


  /**
   * Count Type MT5AccountCountOutputType
   */

  export type MT5AccountCountOutputType = {
    DefaultMT5Account: number
    deposits: number
    mt5Transactions: number
    UserFavorite: number
  }

  export type MT5AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DefaultMT5Account?: boolean | MT5AccountCountOutputTypeCountDefaultMT5AccountArgs
    deposits?: boolean | MT5AccountCountOutputTypeCountDepositsArgs
    mt5Transactions?: boolean | MT5AccountCountOutputTypeCountMt5TransactionsArgs
    UserFavorite?: boolean | MT5AccountCountOutputTypeCountUserFavoriteArgs
  }

  // Custom InputTypes
  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5AccountCountOutputType
     */
    select?: MT5AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountDefaultMT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultMT5AccountWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountMt5TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5TransactionWhereInput
  }

  /**
   * MT5AccountCountOutputType without action
   */
  export type MT5AccountCountOutputTypeCountUserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Count Type InstrumentCountOutputType
   */

  export type InstrumentCountOutputType = {
    UserFavorite: number
  }

  export type InstrumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserFavorite?: boolean | InstrumentCountOutputTypeCountUserFavoriteArgs
  }

  // Custom InputTypes
  /**
   * InstrumentCountOutputType without action
   */
  export type InstrumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstrumentCountOutputType
     */
    select?: InstrumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstrumentCountOutputType without action
   */
  export type InstrumentCountOutputTypeCountUserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    admin_login_log: number
    balance_operation_history: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_login_log?: boolean | AdminCountOutputTypeCountAdmin_login_logArgs
    balance_operation_history?: boolean | AdminCountOutputTypeCountBalance_operation_historyArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdmin_login_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_login_logWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountBalance_operation_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balance_operation_historyWhereInput
  }


  /**
   * Count Type Chat_conversationsCountOutputType
   */

  export type Chat_conversationsCountOutputType = {
    chat_messages: number
    chat_participants: number
  }

  export type Chat_conversationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | Chat_conversationsCountOutputTypeCountChat_messagesArgs
    chat_participants?: boolean | Chat_conversationsCountOutputTypeCountChat_participantsArgs
  }

  // Custom InputTypes
  /**
   * Chat_conversationsCountOutputType without action
   */
  export type Chat_conversationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat_conversationsCountOutputType
     */
    select?: Chat_conversationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Chat_conversationsCountOutputType without action
   */
  export type Chat_conversationsCountOutputTypeCountChat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
  }

  /**
   * Chat_conversationsCountOutputType without action
   */
  export type Chat_conversationsCountOutputTypeCountChat_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_participantsWhereInput
  }


  /**
   * Count Type Ib_requestsCountOutputType
   */

  export type Ib_requestsCountOutputType = {
    ib_group_assignments: number
  }

  export type Ib_requestsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_group_assignments?: boolean | Ib_requestsCountOutputTypeCountIb_group_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * Ib_requestsCountOutputType without action
   */
  export type Ib_requestsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ib_requestsCountOutputType
     */
    select?: Ib_requestsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Ib_requestsCountOutputType without action
   */
  export type Ib_requestsCountOutputTypeCountIb_group_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_group_assignmentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    country: string | null
    createdAt: Date | null
    emailVerified: boolean | null
    lastLoginAt: Date | null
    role: string | null
    status: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    resetToken: string | null
    resetTokenExpires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    country: string | null
    createdAt: Date | null
    emailVerified: boolean | null
    lastLoginAt: Date | null
    role: string | null
    status: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    resetToken: string | null
    resetTokenExpires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    clientId: number
    email: number
    password: number
    name: number
    phone: number
    country: number
    createdAt: number
    emailVerified: number
    lastLoginAt: number
    role: number
    status: number
    twoFactorEnabled: number
    twoFactorSecret: number
    twoFactorBackupCodes: number
    resetToken: number
    resetTokenExpires: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    clientId?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    country?: true
    createdAt?: true
    emailVerified?: true
    lastLoginAt?: true
    role?: true
    status?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    resetToken?: true
    resetTokenExpires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    clientId?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    country?: true
    createdAt?: true
    emailVerified?: true
    lastLoginAt?: true
    role?: true
    status?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    resetToken?: true
    resetTokenExpires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    clientId?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    country?: true
    createdAt?: true
    emailVerified?: true
    lastLoginAt?: true
    role?: true
    status?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    resetToken?: true
    resetTokenExpires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    clientId: string
    email: string
    password: string
    name: string | null
    phone: string | null
    country: string | null
    createdAt: Date
    emailVerified: boolean
    lastLoginAt: Date | null
    role: string
    status: string
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    twoFactorBackupCodes: string[]
    resetToken: string | null
    resetTokenExpires: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    DefaultMT5Account?: boolean | User$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | User$depositsArgs<ExtArgs>
    kyc?: boolean | User$kycArgs<ExtArgs>
    mt5Accounts?: boolean | User$mt5AccountsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    terminalSettings?: boolean | User$terminalSettingsArgs<ExtArgs>
    UserFavorite?: boolean | User$UserFavoriteArgs<ExtArgs>
    userLoginLogs?: boolean | User$userLoginLogsArgs<ExtArgs>
    suggestions?: boolean | User$suggestionsArgs<ExtArgs>
    priceAlerts?: boolean | User$priceAlertsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    clientId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    country?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    role?: boolean
    status?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "email" | "password" | "name" | "phone" | "country" | "createdAt" | "emailVerified" | "lastLoginAt" | "role" | "status" | "twoFactorEnabled" | "twoFactorSecret" | "twoFactorBackupCodes" | "resetToken" | "resetTokenExpires", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    DefaultMT5Account?: boolean | User$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | User$depositsArgs<ExtArgs>
    kyc?: boolean | User$kycArgs<ExtArgs>
    mt5Accounts?: boolean | User$mt5AccountsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    terminalSettings?: boolean | User$terminalSettingsArgs<ExtArgs>
    UserFavorite?: boolean | User$UserFavoriteArgs<ExtArgs>
    userLoginLogs?: boolean | User$userLoginLogsArgs<ExtArgs>
    suggestions?: boolean | User$suggestionsArgs<ExtArgs>
    priceAlerts?: boolean | User$priceAlertsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      DefaultMT5Account: Prisma.$DefaultMT5AccountPayload<ExtArgs> | null
      deposits: Prisma.$DepositPayload<ExtArgs>[]
      kyc: Prisma.$KYCPayload<ExtArgs> | null
      mt5Accounts: Prisma.$MT5AccountPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      RefreshToken: Prisma.$RefreshTokenPayload<ExtArgs>[]
      terminalSettings: Prisma.$TerminalSettingsPayload<ExtArgs> | null
      UserFavorite: Prisma.$UserFavoritePayload<ExtArgs>[]
      userLoginLogs: Prisma.$UserLoginLogPayload<ExtArgs>[]
      suggestions: Prisma.$SuggestionPayload<ExtArgs>[]
      priceAlerts: Prisma.$PriceAlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      email: string
      password: string
      name: string | null
      phone: string | null
      country: string | null
      createdAt: Date
      emailVerified: boolean
      lastLoginAt: Date | null
      role: string
      status: string
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      twoFactorBackupCodes: string[]
      resetToken: string | null
      resetTokenExpires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DefaultMT5Account<T extends User$DefaultMT5AccountArgs<ExtArgs> = {}>(args?: Subset<T, User$DefaultMT5AccountArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deposits<T extends User$depositsArgs<ExtArgs> = {}>(args?: Subset<T, User$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kyc<T extends User$kycArgs<ExtArgs> = {}>(args?: Subset<T, User$kycArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mt5Accounts<T extends User$mt5AccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$mt5AccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RefreshToken<T extends User$RefreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$RefreshTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    terminalSettings<T extends User$terminalSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$terminalSettingsArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    UserFavorite<T extends User$UserFavoriteArgs<ExtArgs> = {}>(args?: Subset<T, User$UserFavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLoginLogs<T extends User$userLoginLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$userLoginLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suggestions<T extends User$suggestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$suggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceAlerts<T extends User$priceAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$priceAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly clientId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'String[]'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.DefaultMT5Account
   */
  export type User$DefaultMT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    where?: DefaultMT5AccountWhereInput
  }

  /**
   * User.deposits
   */
  export type User$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    cursor?: DepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * User.kyc
   */
  export type User$kycArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    where?: KYCWhereInput
  }

  /**
   * User.mt5Accounts
   */
  export type User$mt5AccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    where?: MT5AccountWhereInput
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    cursor?: MT5AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.RefreshToken
   */
  export type User$RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.terminalSettings
   */
  export type User$terminalSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    where?: TerminalSettingsWhereInput
  }

  /**
   * User.UserFavorite
   */
  export type User$UserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * User.userLoginLogs
   */
  export type User$userLoginLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    where?: UserLoginLogWhereInput
    orderBy?: UserLoginLogOrderByWithRelationInput | UserLoginLogOrderByWithRelationInput[]
    cursor?: UserLoginLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLoginLogScalarFieldEnum | UserLoginLogScalarFieldEnum[]
  }

  /**
   * User.suggestions
   */
  export type User$suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    where?: SuggestionWhereInput
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    cursor?: SuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * User.priceAlerts
   */
  export type User$priceAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    where?: PriceAlertWhereInput
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    cursor?: PriceAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model KYC
   */

  export type AggregateKYC = {
    _count: KYCCountAggregateOutputType | null
    _min: KYCMinAggregateOutputType | null
    _max: KYCMaxAggregateOutputType | null
  }

  export type KYCMinAggregateOutputType = {
    id: string | null
    isDocumentVerified: boolean | null
    isAddressVerified: boolean | null
    verificationStatus: string | null
    documentReference: string | null
    addressReference: string | null
    amlReference: string | null
    documentSubmittedAt: Date | null
    addressSubmittedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type KYCMaxAggregateOutputType = {
    id: string | null
    isDocumentVerified: boolean | null
    isAddressVerified: boolean | null
    verificationStatus: string | null
    documentReference: string | null
    addressReference: string | null
    amlReference: string | null
    documentSubmittedAt: Date | null
    addressSubmittedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type KYCCountAggregateOutputType = {
    id: number
    isDocumentVerified: number
    isAddressVerified: number
    verificationStatus: number
    documentReference: number
    addressReference: number
    amlReference: number
    documentSubmittedAt: number
    addressSubmittedAt: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type KYCMinAggregateInputType = {
    id?: true
    isDocumentVerified?: true
    isAddressVerified?: true
    verificationStatus?: true
    documentReference?: true
    addressReference?: true
    amlReference?: true
    documentSubmittedAt?: true
    addressSubmittedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type KYCMaxAggregateInputType = {
    id?: true
    isDocumentVerified?: true
    isAddressVerified?: true
    verificationStatus?: true
    documentReference?: true
    addressReference?: true
    amlReference?: true
    documentSubmittedAt?: true
    addressSubmittedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type KYCCountAggregateInputType = {
    id?: true
    isDocumentVerified?: true
    isAddressVerified?: true
    verificationStatus?: true
    documentReference?: true
    addressReference?: true
    amlReference?: true
    documentSubmittedAt?: true
    addressSubmittedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type KYCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYC to aggregate.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCS
    **/
    _count?: true | KYCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCMaxAggregateInputType
  }

  export type GetKYCAggregateType<T extends KYCAggregateArgs> = {
        [P in keyof T & keyof AggregateKYC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYC[P]>
      : GetScalarType<T[P], AggregateKYC[P]>
  }




  export type KYCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCWhereInput
    orderBy?: KYCOrderByWithAggregationInput | KYCOrderByWithAggregationInput[]
    by: KYCScalarFieldEnum[] | KYCScalarFieldEnum
    having?: KYCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCCountAggregateInputType | true
    _min?: KYCMinAggregateInputType
    _max?: KYCMaxAggregateInputType
  }

  export type KYCGroupByOutputType = {
    id: string
    isDocumentVerified: boolean
    isAddressVerified: boolean
    verificationStatus: string
    documentReference: string | null
    addressReference: string | null
    amlReference: string | null
    documentSubmittedAt: Date | null
    addressSubmittedAt: Date | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: KYCCountAggregateOutputType | null
    _min: KYCMinAggregateOutputType | null
    _max: KYCMaxAggregateOutputType | null
  }

  type GetKYCGroupByPayload<T extends KYCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCGroupByOutputType[P]>
            : GetScalarType<T[P], KYCGroupByOutputType[P]>
        }
      >
    >


  export type KYCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectScalar = {
    id?: boolean
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: boolean
    documentReference?: boolean
    addressReference?: boolean
    amlReference?: boolean
    documentSubmittedAt?: boolean
    addressSubmittedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type KYCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isDocumentVerified" | "isAddressVerified" | "verificationStatus" | "documentReference" | "addressReference" | "amlReference" | "documentSubmittedAt" | "addressSubmittedAt" | "rejectionReason" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["kYC"]>
  export type KYCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KYCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYC"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isDocumentVerified: boolean
      isAddressVerified: boolean
      verificationStatus: string
      documentReference: string | null
      addressReference: string | null
      amlReference: string | null
      documentSubmittedAt: Date | null
      addressSubmittedAt: Date | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["kYC"]>
    composites: {}
  }

  type KYCGetPayload<S extends boolean | null | undefined | KYCDefaultArgs> = $Result.GetResult<Prisma.$KYCPayload, S>

  type KYCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCCountAggregateInputType | true
    }

  export interface KYCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYC'], meta: { name: 'KYC' } }
    /**
     * Find zero or one KYC that matches the filter.
     * @param {KYCFindUniqueArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCFindUniqueArgs>(args: SelectSubset<T, KYCFindUniqueArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCFindUniqueOrThrowArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindFirstArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCFindFirstArgs>(args?: SelectSubset<T, KYCFindFirstArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindFirstOrThrowArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCS
     * const kYCS = await prisma.kYC.findMany()
     * 
     * // Get first 10 KYCS
     * const kYCS = await prisma.kYC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCWithIdOnly = await prisma.kYC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCFindManyArgs>(args?: SelectSubset<T, KYCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYC.
     * @param {KYCCreateArgs} args - Arguments to create a KYC.
     * @example
     * // Create one KYC
     * const KYC = await prisma.kYC.create({
     *   data: {
     *     // ... data to create a KYC
     *   }
     * })
     * 
     */
    create<T extends KYCCreateArgs>(args: SelectSubset<T, KYCCreateArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCS.
     * @param {KYCCreateManyArgs} args - Arguments to create many KYCS.
     * @example
     * // Create many KYCS
     * const kYC = await prisma.kYC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCCreateManyArgs>(args?: SelectSubset<T, KYCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCS and returns the data saved in the database.
     * @param {KYCCreateManyAndReturnArgs} args - Arguments to create many KYCS.
     * @example
     * // Create many KYCS
     * const kYC = await prisma.kYC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCS and only return the `id`
     * const kYCWithIdOnly = await prisma.kYC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYC.
     * @param {KYCDeleteArgs} args - Arguments to delete one KYC.
     * @example
     * // Delete one KYC
     * const KYC = await prisma.kYC.delete({
     *   where: {
     *     // ... filter to delete one KYC
     *   }
     * })
     * 
     */
    delete<T extends KYCDeleteArgs>(args: SelectSubset<T, KYCDeleteArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYC.
     * @param {KYCUpdateArgs} args - Arguments to update one KYC.
     * @example
     * // Update one KYC
     * const kYC = await prisma.kYC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCUpdateArgs>(args: SelectSubset<T, KYCUpdateArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCS.
     * @param {KYCDeleteManyArgs} args - Arguments to filter KYCS to delete.
     * @example
     * // Delete a few KYCS
     * const { count } = await prisma.kYC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCDeleteManyArgs>(args?: SelectSubset<T, KYCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCS
     * const kYC = await prisma.kYC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCUpdateManyArgs>(args: SelectSubset<T, KYCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCS and returns the data updated in the database.
     * @param {KYCUpdateManyAndReturnArgs} args - Arguments to update many KYCS.
     * @example
     * // Update many KYCS
     * const kYC = await prisma.kYC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCS and only return the `id`
     * const kYCWithIdOnly = await prisma.kYC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYC.
     * @param {KYCUpsertArgs} args - Arguments to update or create a KYC.
     * @example
     * // Update or create a KYC
     * const kYC = await prisma.kYC.upsert({
     *   create: {
     *     // ... data to create a KYC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYC we want to update
     *   }
     * })
     */
    upsert<T extends KYCUpsertArgs>(args: SelectSubset<T, KYCUpsertArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCCountArgs} args - Arguments to filter KYCS to count.
     * @example
     * // Count the number of KYCS
     * const count = await prisma.kYC.count({
     *   where: {
     *     // ... the filter for the KYCS we want to count
     *   }
     * })
    **/
    count<T extends KYCCountArgs>(
      args?: Subset<T, KYCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCAggregateArgs>(args: Subset<T, KYCAggregateArgs>): Prisma.PrismaPromise<GetKYCAggregateType<T>>

    /**
     * Group by KYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCGroupByArgs['orderBy'] }
        : { orderBy?: KYCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYC model
   */
  readonly fields: KYCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYC model
   */
  interface KYCFieldRefs {
    readonly id: FieldRef<"KYC", 'String'>
    readonly isDocumentVerified: FieldRef<"KYC", 'Boolean'>
    readonly isAddressVerified: FieldRef<"KYC", 'Boolean'>
    readonly verificationStatus: FieldRef<"KYC", 'String'>
    readonly documentReference: FieldRef<"KYC", 'String'>
    readonly addressReference: FieldRef<"KYC", 'String'>
    readonly amlReference: FieldRef<"KYC", 'String'>
    readonly documentSubmittedAt: FieldRef<"KYC", 'DateTime'>
    readonly addressSubmittedAt: FieldRef<"KYC", 'DateTime'>
    readonly rejectionReason: FieldRef<"KYC", 'String'>
    readonly createdAt: FieldRef<"KYC", 'DateTime'>
    readonly updatedAt: FieldRef<"KYC", 'DateTime'>
    readonly userId: FieldRef<"KYC", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KYC findUnique
   */
  export type KYCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC findUniqueOrThrow
   */
  export type KYCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC findFirst
   */
  export type KYCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCS.
     */
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC findFirstOrThrow
   */
  export type KYCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCS.
     */
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC findMany
   */
  export type KYCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYCS to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC create
   */
  export type KYCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The data needed to create a KYC.
     */
    data: XOR<KYCCreateInput, KYCUncheckedCreateInput>
  }

  /**
   * KYC createMany
   */
  export type KYCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCS.
     */
    data: KYCCreateManyInput | KYCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYC createManyAndReturn
   */
  export type KYCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * The data used to create many KYCS.
     */
    data: KYCCreateManyInput | KYCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYC update
   */
  export type KYCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The data needed to update a KYC.
     */
    data: XOR<KYCUpdateInput, KYCUncheckedUpdateInput>
    /**
     * Choose, which KYC to update.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC updateMany
   */
  export type KYCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCS.
     */
    data: XOR<KYCUpdateManyMutationInput, KYCUncheckedUpdateManyInput>
    /**
     * Filter which KYCS to update
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to update.
     */
    limit?: number
  }

  /**
   * KYC updateManyAndReturn
   */
  export type KYCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * The data used to update KYCS.
     */
    data: XOR<KYCUpdateManyMutationInput, KYCUncheckedUpdateManyInput>
    /**
     * Filter which KYCS to update
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYC upsert
   */
  export type KYCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The filter to search for the KYC to update in case it exists.
     */
    where: KYCWhereUniqueInput
    /**
     * In case the KYC found by the `where` argument doesn't exist, create a new KYC with this data.
     */
    create: XOR<KYCCreateInput, KYCUncheckedCreateInput>
    /**
     * In case the KYC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCUpdateInput, KYCUncheckedUpdateInput>
  }

  /**
   * KYC delete
   */
  export type KYCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter which KYC to delete.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC deleteMany
   */
  export type KYCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCS to delete
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to delete.
     */
    limit?: number
  }

  /**
   * KYC without action
   */
  export type KYCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
  }


  /**
   * Model MT5Account
   */

  export type AggregateMT5Account = {
    _count: MT5AccountCountAggregateOutputType | null
    _avg: MT5AccountAvgAggregateOutputType | null
    _sum: MT5AccountSumAggregateOutputType | null
    _min: MT5AccountMinAggregateOutputType | null
    _max: MT5AccountMaxAggregateOutputType | null
  }

  export type MT5AccountAvgAggregateOutputType = {
    leverage: number | null
    balance: number | null
    credit: number | null
    equity: number | null
    margin: number | null
    marginFree: number | null
    marginLevel: number | null
    profit: number | null
  }

  export type MT5AccountSumAggregateOutputType = {
    leverage: number | null
    balance: number | null
    credit: number | null
    equity: number | null
    margin: number | null
    marginFree: number | null
    marginLevel: number | null
    profit: number | null
  }

  export type MT5AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    accountType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    leverage: number | null
    nameOnAccount: string | null
    package: string | null
    group: string | null
    balance: number | null
    credit: number | null
    currency: string | null
    equity: number | null
    lastSyncedAt: Date | null
    margin: number | null
    marginFree: number | null
    marginLevel: number | null
    profit: number | null
    archived: boolean | null
    archived_at: Date | null
  }

  export type MT5AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    accountType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    leverage: number | null
    nameOnAccount: string | null
    package: string | null
    group: string | null
    balance: number | null
    credit: number | null
    currency: string | null
    equity: number | null
    lastSyncedAt: Date | null
    margin: number | null
    marginFree: number | null
    marginLevel: number | null
    profit: number | null
    archived: boolean | null
    archived_at: Date | null
  }

  export type MT5AccountCountAggregateOutputType = {
    id: number
    accountId: number
    userId: number
    accountType: number
    createdAt: number
    updatedAt: number
    password: number
    leverage: number
    nameOnAccount: number
    package: number
    group: number
    balance: number
    credit: number
    currency: number
    equity: number
    lastSyncedAt: number
    margin: number
    marginFree: number
    marginLevel: number
    profit: number
    archived: number
    archived_at: number
    _all: number
  }


  export type MT5AccountAvgAggregateInputType = {
    leverage?: true
    balance?: true
    credit?: true
    equity?: true
    margin?: true
    marginFree?: true
    marginLevel?: true
    profit?: true
  }

  export type MT5AccountSumAggregateInputType = {
    leverage?: true
    balance?: true
    credit?: true
    equity?: true
    margin?: true
    marginFree?: true
    marginLevel?: true
    profit?: true
  }

  export type MT5AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    accountType?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    leverage?: true
    nameOnAccount?: true
    package?: true
    group?: true
    balance?: true
    credit?: true
    currency?: true
    equity?: true
    lastSyncedAt?: true
    margin?: true
    marginFree?: true
    marginLevel?: true
    profit?: true
    archived?: true
    archived_at?: true
  }

  export type MT5AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    accountType?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    leverage?: true
    nameOnAccount?: true
    package?: true
    group?: true
    balance?: true
    credit?: true
    currency?: true
    equity?: true
    lastSyncedAt?: true
    margin?: true
    marginFree?: true
    marginLevel?: true
    profit?: true
    archived?: true
    archived_at?: true
  }

  export type MT5AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    accountType?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    leverage?: true
    nameOnAccount?: true
    package?: true
    group?: true
    balance?: true
    credit?: true
    currency?: true
    equity?: true
    lastSyncedAt?: true
    margin?: true
    marginFree?: true
    marginLevel?: true
    profit?: true
    archived?: true
    archived_at?: true
    _all?: true
  }

  export type MT5AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Account to aggregate.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MT5Accounts
    **/
    _count?: true | MT5AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MT5AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MT5AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MT5AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MT5AccountMaxAggregateInputType
  }

  export type GetMT5AccountAggregateType<T extends MT5AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateMT5Account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMT5Account[P]>
      : GetScalarType<T[P], AggregateMT5Account[P]>
  }




  export type MT5AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5AccountWhereInput
    orderBy?: MT5AccountOrderByWithAggregationInput | MT5AccountOrderByWithAggregationInput[]
    by: MT5AccountScalarFieldEnum[] | MT5AccountScalarFieldEnum
    having?: MT5AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MT5AccountCountAggregateInputType | true
    _avg?: MT5AccountAvgAggregateInputType
    _sum?: MT5AccountSumAggregateInputType
    _min?: MT5AccountMinAggregateInputType
    _max?: MT5AccountMaxAggregateInputType
  }

  export type MT5AccountGroupByOutputType = {
    id: string
    accountId: string
    userId: string | null
    accountType: string
    createdAt: Date
    updatedAt: Date
    password: string | null
    leverage: number | null
    nameOnAccount: string | null
    package: string | null
    group: string | null
    balance: number | null
    credit: number | null
    currency: string | null
    equity: number | null
    lastSyncedAt: Date | null
    margin: number | null
    marginFree: number | null
    marginLevel: number | null
    profit: number | null
    archived: boolean
    archived_at: Date | null
    _count: MT5AccountCountAggregateOutputType | null
    _avg: MT5AccountAvgAggregateOutputType | null
    _sum: MT5AccountSumAggregateOutputType | null
    _min: MT5AccountMinAggregateOutputType | null
    _max: MT5AccountMaxAggregateOutputType | null
  }

  type GetMT5AccountGroupByPayload<T extends MT5AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MT5AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MT5AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MT5AccountGroupByOutputType[P]>
            : GetScalarType<T[P], MT5AccountGroupByOutputType[P]>
        }
      >
    >


  export type MT5AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    nameOnAccount?: boolean
    package?: boolean
    group?: boolean
    balance?: boolean
    credit?: boolean
    currency?: boolean
    equity?: boolean
    lastSyncedAt?: boolean
    margin?: boolean
    marginFree?: boolean
    marginLevel?: boolean
    profit?: boolean
    archived?: boolean
    archived_at?: boolean
    DefaultMT5Account?: boolean | MT5Account$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | MT5Account$depositsArgs<ExtArgs>
    user?: boolean | MT5Account$userArgs<ExtArgs>
    mt5Transactions?: boolean | MT5Account$mt5TransactionsArgs<ExtArgs>
    UserFavorite?: boolean | MT5Account$UserFavoriteArgs<ExtArgs>
    _count?: boolean | MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    nameOnAccount?: boolean
    package?: boolean
    group?: boolean
    balance?: boolean
    credit?: boolean
    currency?: boolean
    equity?: boolean
    lastSyncedAt?: boolean
    margin?: boolean
    marginFree?: boolean
    marginLevel?: boolean
    profit?: boolean
    archived?: boolean
    archived_at?: boolean
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    nameOnAccount?: boolean
    package?: boolean
    group?: boolean
    balance?: boolean
    credit?: boolean
    currency?: boolean
    equity?: boolean
    lastSyncedAt?: boolean
    margin?: boolean
    marginFree?: boolean
    marginLevel?: boolean
    profit?: boolean
    archived?: boolean
    archived_at?: boolean
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Account"]>

  export type MT5AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    userId?: boolean
    accountType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    leverage?: boolean
    nameOnAccount?: boolean
    package?: boolean
    group?: boolean
    balance?: boolean
    credit?: boolean
    currency?: boolean
    equity?: boolean
    lastSyncedAt?: boolean
    margin?: boolean
    marginFree?: boolean
    marginLevel?: boolean
    profit?: boolean
    archived?: boolean
    archived_at?: boolean
  }

  export type MT5AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "userId" | "accountType" | "createdAt" | "updatedAt" | "password" | "leverage" | "nameOnAccount" | "package" | "group" | "balance" | "credit" | "currency" | "equity" | "lastSyncedAt" | "margin" | "marginFree" | "marginLevel" | "profit" | "archived" | "archived_at", ExtArgs["result"]["mT5Account"]>
  export type MT5AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DefaultMT5Account?: boolean | MT5Account$DefaultMT5AccountArgs<ExtArgs>
    deposits?: boolean | MT5Account$depositsArgs<ExtArgs>
    user?: boolean | MT5Account$userArgs<ExtArgs>
    mt5Transactions?: boolean | MT5Account$mt5TransactionsArgs<ExtArgs>
    UserFavorite?: boolean | MT5Account$UserFavoriteArgs<ExtArgs>
    _count?: boolean | MT5AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MT5AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }
  export type MT5AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MT5Account$userArgs<ExtArgs>
  }

  export type $MT5AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MT5Account"
    objects: {
      DefaultMT5Account: Prisma.$DefaultMT5AccountPayload<ExtArgs>[]
      deposits: Prisma.$DepositPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      mt5Transactions: Prisma.$MT5TransactionPayload<ExtArgs>[]
      UserFavorite: Prisma.$UserFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      userId: string | null
      accountType: string
      createdAt: Date
      updatedAt: Date
      password: string | null
      leverage: number | null
      nameOnAccount: string | null
      package: string | null
      group: string | null
      balance: number | null
      credit: number | null
      currency: string | null
      equity: number | null
      lastSyncedAt: Date | null
      margin: number | null
      marginFree: number | null
      marginLevel: number | null
      profit: number | null
      archived: boolean
      archived_at: Date | null
    }, ExtArgs["result"]["mT5Account"]>
    composites: {}
  }

  type MT5AccountGetPayload<S extends boolean | null | undefined | MT5AccountDefaultArgs> = $Result.GetResult<Prisma.$MT5AccountPayload, S>

  type MT5AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MT5AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MT5AccountCountAggregateInputType | true
    }

  export interface MT5AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MT5Account'], meta: { name: 'MT5Account' } }
    /**
     * Find zero or one MT5Account that matches the filter.
     * @param {MT5AccountFindUniqueArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MT5AccountFindUniqueArgs>(args: SelectSubset<T, MT5AccountFindUniqueArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MT5Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MT5AccountFindUniqueOrThrowArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MT5AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, MT5AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindFirstArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MT5AccountFindFirstArgs>(args?: SelectSubset<T, MT5AccountFindFirstArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindFirstOrThrowArgs} args - Arguments to find a MT5Account
     * @example
     * // Get one MT5Account
     * const mT5Account = await prisma.mT5Account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MT5AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, MT5AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MT5Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MT5Accounts
     * const mT5Accounts = await prisma.mT5Account.findMany()
     * 
     * // Get first 10 MT5Accounts
     * const mT5Accounts = await prisma.mT5Account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MT5AccountFindManyArgs>(args?: SelectSubset<T, MT5AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MT5Account.
     * @param {MT5AccountCreateArgs} args - Arguments to create a MT5Account.
     * @example
     * // Create one MT5Account
     * const MT5Account = await prisma.mT5Account.create({
     *   data: {
     *     // ... data to create a MT5Account
     *   }
     * })
     * 
     */
    create<T extends MT5AccountCreateArgs>(args: SelectSubset<T, MT5AccountCreateArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MT5Accounts.
     * @param {MT5AccountCreateManyArgs} args - Arguments to create many MT5Accounts.
     * @example
     * // Create many MT5Accounts
     * const mT5Account = await prisma.mT5Account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MT5AccountCreateManyArgs>(args?: SelectSubset<T, MT5AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MT5Accounts and returns the data saved in the database.
     * @param {MT5AccountCreateManyAndReturnArgs} args - Arguments to create many MT5Accounts.
     * @example
     * // Create many MT5Accounts
     * const mT5Account = await prisma.mT5Account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MT5Accounts and only return the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MT5AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, MT5AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MT5Account.
     * @param {MT5AccountDeleteArgs} args - Arguments to delete one MT5Account.
     * @example
     * // Delete one MT5Account
     * const MT5Account = await prisma.mT5Account.delete({
     *   where: {
     *     // ... filter to delete one MT5Account
     *   }
     * })
     * 
     */
    delete<T extends MT5AccountDeleteArgs>(args: SelectSubset<T, MT5AccountDeleteArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MT5Account.
     * @param {MT5AccountUpdateArgs} args - Arguments to update one MT5Account.
     * @example
     * // Update one MT5Account
     * const mT5Account = await prisma.mT5Account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MT5AccountUpdateArgs>(args: SelectSubset<T, MT5AccountUpdateArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MT5Accounts.
     * @param {MT5AccountDeleteManyArgs} args - Arguments to filter MT5Accounts to delete.
     * @example
     * // Delete a few MT5Accounts
     * const { count } = await prisma.mT5Account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MT5AccountDeleteManyArgs>(args?: SelectSubset<T, MT5AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MT5Accounts
     * const mT5Account = await prisma.mT5Account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MT5AccountUpdateManyArgs>(args: SelectSubset<T, MT5AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Accounts and returns the data updated in the database.
     * @param {MT5AccountUpdateManyAndReturnArgs} args - Arguments to update many MT5Accounts.
     * @example
     * // Update many MT5Accounts
     * const mT5Account = await prisma.mT5Account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MT5Accounts and only return the `id`
     * const mT5AccountWithIdOnly = await prisma.mT5Account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MT5AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, MT5AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MT5Account.
     * @param {MT5AccountUpsertArgs} args - Arguments to update or create a MT5Account.
     * @example
     * // Update or create a MT5Account
     * const mT5Account = await prisma.mT5Account.upsert({
     *   create: {
     *     // ... data to create a MT5Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MT5Account we want to update
     *   }
     * })
     */
    upsert<T extends MT5AccountUpsertArgs>(args: SelectSubset<T, MT5AccountUpsertArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountCountArgs} args - Arguments to filter MT5Accounts to count.
     * @example
     * // Count the number of MT5Accounts
     * const count = await prisma.mT5Account.count({
     *   where: {
     *     // ... the filter for the MT5Accounts we want to count
     *   }
     * })
    **/
    count<T extends MT5AccountCountArgs>(
      args?: Subset<T, MT5AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MT5AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MT5AccountAggregateArgs>(args: Subset<T, MT5AccountAggregateArgs>): Prisma.PrismaPromise<GetMT5AccountAggregateType<T>>

    /**
     * Group by MT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MT5AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MT5AccountGroupByArgs['orderBy'] }
        : { orderBy?: MT5AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MT5AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMT5AccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MT5Account model
   */
  readonly fields: MT5AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MT5Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MT5AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DefaultMT5Account<T extends MT5Account$DefaultMT5AccountArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$DefaultMT5AccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deposits<T extends MT5Account$depositsArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$depositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends MT5Account$userArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mt5Transactions<T extends MT5Account$mt5TransactionsArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$mt5TransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserFavorite<T extends MT5Account$UserFavoriteArgs<ExtArgs> = {}>(args?: Subset<T, MT5Account$UserFavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MT5Account model
   */
  interface MT5AccountFieldRefs {
    readonly id: FieldRef<"MT5Account", 'String'>
    readonly accountId: FieldRef<"MT5Account", 'String'>
    readonly userId: FieldRef<"MT5Account", 'String'>
    readonly accountType: FieldRef<"MT5Account", 'String'>
    readonly createdAt: FieldRef<"MT5Account", 'DateTime'>
    readonly updatedAt: FieldRef<"MT5Account", 'DateTime'>
    readonly password: FieldRef<"MT5Account", 'String'>
    readonly leverage: FieldRef<"MT5Account", 'Int'>
    readonly nameOnAccount: FieldRef<"MT5Account", 'String'>
    readonly package: FieldRef<"MT5Account", 'String'>
    readonly group: FieldRef<"MT5Account", 'String'>
    readonly balance: FieldRef<"MT5Account", 'Float'>
    readonly credit: FieldRef<"MT5Account", 'Float'>
    readonly currency: FieldRef<"MT5Account", 'String'>
    readonly equity: FieldRef<"MT5Account", 'Float'>
    readonly lastSyncedAt: FieldRef<"MT5Account", 'DateTime'>
    readonly margin: FieldRef<"MT5Account", 'Float'>
    readonly marginFree: FieldRef<"MT5Account", 'Float'>
    readonly marginLevel: FieldRef<"MT5Account", 'Float'>
    readonly profit: FieldRef<"MT5Account", 'Float'>
    readonly archived: FieldRef<"MT5Account", 'Boolean'>
    readonly archived_at: FieldRef<"MT5Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MT5Account findUnique
   */
  export type MT5AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account findUniqueOrThrow
   */
  export type MT5AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account findFirst
   */
  export type MT5AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Accounts.
     */
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account findFirstOrThrow
   */
  export type MT5AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Account to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Accounts.
     */
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account findMany
   */
  export type MT5AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which MT5Accounts to fetch.
     */
    where?: MT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Accounts to fetch.
     */
    orderBy?: MT5AccountOrderByWithRelationInput | MT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MT5Accounts.
     */
    cursor?: MT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Accounts.
     */
    skip?: number
    distinct?: MT5AccountScalarFieldEnum | MT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account create
   */
  export type MT5AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a MT5Account.
     */
    data: XOR<MT5AccountCreateInput, MT5AccountUncheckedCreateInput>
  }

  /**
   * MT5Account createMany
   */
  export type MT5AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MT5Accounts.
     */
    data: MT5AccountCreateManyInput | MT5AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MT5Account createManyAndReturn
   */
  export type MT5AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * The data used to create many MT5Accounts.
     */
    data: MT5AccountCreateManyInput | MT5AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Account update
   */
  export type MT5AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a MT5Account.
     */
    data: XOR<MT5AccountUpdateInput, MT5AccountUncheckedUpdateInput>
    /**
     * Choose, which MT5Account to update.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account updateMany
   */
  export type MT5AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MT5Accounts.
     */
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which MT5Accounts to update
     */
    where?: MT5AccountWhereInput
    /**
     * Limit how many MT5Accounts to update.
     */
    limit?: number
  }

  /**
   * MT5Account updateManyAndReturn
   */
  export type MT5AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * The data used to update MT5Accounts.
     */
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which MT5Accounts to update
     */
    where?: MT5AccountWhereInput
    /**
     * Limit how many MT5Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Account upsert
   */
  export type MT5AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the MT5Account to update in case it exists.
     */
    where: MT5AccountWhereUniqueInput
    /**
     * In case the MT5Account found by the `where` argument doesn't exist, create a new MT5Account with this data.
     */
    create: XOR<MT5AccountCreateInput, MT5AccountUncheckedCreateInput>
    /**
     * In case the MT5Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MT5AccountUpdateInput, MT5AccountUncheckedUpdateInput>
  }

  /**
   * MT5Account delete
   */
  export type MT5AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    /**
     * Filter which MT5Account to delete.
     */
    where: MT5AccountWhereUniqueInput
  }

  /**
   * MT5Account deleteMany
   */
  export type MT5AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Accounts to delete
     */
    where?: MT5AccountWhereInput
    /**
     * Limit how many MT5Accounts to delete.
     */
    limit?: number
  }

  /**
   * MT5Account.DefaultMT5Account
   */
  export type MT5Account$DefaultMT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    where?: DefaultMT5AccountWhereInput
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    cursor?: DefaultMT5AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * MT5Account.deposits
   */
  export type MT5Account$depositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    cursor?: DepositWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * MT5Account.user
   */
  export type MT5Account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MT5Account.mt5Transactions
   */
  export type MT5Account$mt5TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    where?: MT5TransactionWhereInput
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    cursor?: MT5TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Account.UserFavorite
   */
  export type MT5Account$UserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * MT5Account without action
   */
  export type MT5AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
  }


  /**
   * Model MT5Transaction
   */

  export type AggregateMT5Transaction = {
    _count: MT5TransactionCountAggregateOutputType | null
    _avg: MT5TransactionAvgAggregateOutputType | null
    _sum: MT5TransactionSumAggregateOutputType | null
    _min: MT5TransactionMinAggregateOutputType | null
    _max: MT5TransactionMaxAggregateOutputType | null
  }

  export type MT5TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type MT5TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type MT5TransactionMinAggregateOutputType = {
    id: string | null
    type: string | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    comment: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    currency: string | null
    depositId: string | null
    withdrawalId: string | null
    userId: string | null
    processedBy: string | null
    processedAt: Date | null
    updatedAt: Date | null
  }

  export type MT5TransactionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    comment: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    currency: string | null
    depositId: string | null
    withdrawalId: string | null
    userId: string | null
    processedBy: string | null
    processedAt: Date | null
    updatedAt: Date | null
  }

  export type MT5TransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    status: number
    paymentMethod: number
    transactionId: number
    comment: number
    mt5AccountId: number
    createdAt: number
    currency: number
    depositId: number
    withdrawalId: number
    userId: number
    processedBy: number
    processedAt: number
    updatedAt: number
    _all: number
  }


  export type MT5TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type MT5TransactionSumAggregateInputType = {
    amount?: true
  }

  export type MT5TransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    comment?: true
    mt5AccountId?: true
    createdAt?: true
    currency?: true
    depositId?: true
    withdrawalId?: true
    userId?: true
    processedBy?: true
    processedAt?: true
    updatedAt?: true
  }

  export type MT5TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    comment?: true
    mt5AccountId?: true
    createdAt?: true
    currency?: true
    depositId?: true
    withdrawalId?: true
    userId?: true
    processedBy?: true
    processedAt?: true
    updatedAt?: true
  }

  export type MT5TransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    comment?: true
    mt5AccountId?: true
    createdAt?: true
    currency?: true
    depositId?: true
    withdrawalId?: true
    userId?: true
    processedBy?: true
    processedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MT5TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Transaction to aggregate.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MT5Transactions
    **/
    _count?: true | MT5TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MT5TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MT5TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MT5TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MT5TransactionMaxAggregateInputType
  }

  export type GetMT5TransactionAggregateType<T extends MT5TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMT5Transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMT5Transaction[P]>
      : GetScalarType<T[P], AggregateMT5Transaction[P]>
  }




  export type MT5TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MT5TransactionWhereInput
    orderBy?: MT5TransactionOrderByWithAggregationInput | MT5TransactionOrderByWithAggregationInput[]
    by: MT5TransactionScalarFieldEnum[] | MT5TransactionScalarFieldEnum
    having?: MT5TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MT5TransactionCountAggregateInputType | true
    _avg?: MT5TransactionAvgAggregateInputType
    _sum?: MT5TransactionSumAggregateInputType
    _min?: MT5TransactionMinAggregateInputType
    _max?: MT5TransactionMaxAggregateInputType
  }

  export type MT5TransactionGroupByOutputType = {
    id: string
    type: string
    amount: number
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    comment: string | null
    mt5AccountId: string
    createdAt: Date | null
    currency: string | null
    depositId: string | null
    withdrawalId: string | null
    userId: string | null
    processedBy: string | null
    processedAt: Date | null
    updatedAt: Date | null
    _count: MT5TransactionCountAggregateOutputType | null
    _avg: MT5TransactionAvgAggregateOutputType | null
    _sum: MT5TransactionSumAggregateOutputType | null
    _min: MT5TransactionMinAggregateOutputType | null
    _max: MT5TransactionMaxAggregateOutputType | null
  }

  type GetMT5TransactionGroupByPayload<T extends MT5TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MT5TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MT5TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MT5TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], MT5TransactionGroupByOutputType[P]>
        }
      >
    >


  export type MT5TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Transaction"]>

  export type MT5TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Transaction"]>

  export type MT5TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mT5Transaction"]>

  export type MT5TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    comment?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    currency?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    userId?: boolean
    processedBy?: boolean
    processedAt?: boolean
    updatedAt?: boolean
  }

  export type MT5TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "status" | "paymentMethod" | "transactionId" | "comment" | "mt5AccountId" | "createdAt" | "currency" | "depositId" | "withdrawalId" | "userId" | "processedBy" | "processedAt" | "updatedAt", ExtArgs["result"]["mT5Transaction"]>
  export type MT5TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }
  export type MT5TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }
  export type MT5TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
  }

  export type $MT5TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MT5Transaction"
    objects: {
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      amount: number
      status: string | null
      paymentMethod: string | null
      transactionId: string | null
      comment: string | null
      mt5AccountId: string
      createdAt: Date | null
      currency: string | null
      depositId: string | null
      withdrawalId: string | null
      userId: string | null
      processedBy: string | null
      processedAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["mT5Transaction"]>
    composites: {}
  }

  type MT5TransactionGetPayload<S extends boolean | null | undefined | MT5TransactionDefaultArgs> = $Result.GetResult<Prisma.$MT5TransactionPayload, S>

  type MT5TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MT5TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MT5TransactionCountAggregateInputType | true
    }

  export interface MT5TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MT5Transaction'], meta: { name: 'MT5Transaction' } }
    /**
     * Find zero or one MT5Transaction that matches the filter.
     * @param {MT5TransactionFindUniqueArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MT5TransactionFindUniqueArgs>(args: SelectSubset<T, MT5TransactionFindUniqueArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MT5Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MT5TransactionFindUniqueOrThrowArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MT5TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, MT5TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionFindFirstArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MT5TransactionFindFirstArgs>(args?: SelectSubset<T, MT5TransactionFindFirstArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MT5Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionFindFirstOrThrowArgs} args - Arguments to find a MT5Transaction
     * @example
     * // Get one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MT5TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, MT5TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MT5Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MT5Transactions
     * const mT5Transactions = await prisma.mT5Transaction.findMany()
     * 
     * // Get first 10 MT5Transactions
     * const mT5Transactions = await prisma.mT5Transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mT5TransactionWithIdOnly = await prisma.mT5Transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MT5TransactionFindManyArgs>(args?: SelectSubset<T, MT5TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MT5Transaction.
     * @param {MT5TransactionCreateArgs} args - Arguments to create a MT5Transaction.
     * @example
     * // Create one MT5Transaction
     * const MT5Transaction = await prisma.mT5Transaction.create({
     *   data: {
     *     // ... data to create a MT5Transaction
     *   }
     * })
     * 
     */
    create<T extends MT5TransactionCreateArgs>(args: SelectSubset<T, MT5TransactionCreateArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MT5Transactions.
     * @param {MT5TransactionCreateManyArgs} args - Arguments to create many MT5Transactions.
     * @example
     * // Create many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MT5TransactionCreateManyArgs>(args?: SelectSubset<T, MT5TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MT5Transactions and returns the data saved in the database.
     * @param {MT5TransactionCreateManyAndReturnArgs} args - Arguments to create many MT5Transactions.
     * @example
     * // Create many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MT5Transactions and only return the `id`
     * const mT5TransactionWithIdOnly = await prisma.mT5Transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MT5TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, MT5TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MT5Transaction.
     * @param {MT5TransactionDeleteArgs} args - Arguments to delete one MT5Transaction.
     * @example
     * // Delete one MT5Transaction
     * const MT5Transaction = await prisma.mT5Transaction.delete({
     *   where: {
     *     // ... filter to delete one MT5Transaction
     *   }
     * })
     * 
     */
    delete<T extends MT5TransactionDeleteArgs>(args: SelectSubset<T, MT5TransactionDeleteArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MT5Transaction.
     * @param {MT5TransactionUpdateArgs} args - Arguments to update one MT5Transaction.
     * @example
     * // Update one MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MT5TransactionUpdateArgs>(args: SelectSubset<T, MT5TransactionUpdateArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MT5Transactions.
     * @param {MT5TransactionDeleteManyArgs} args - Arguments to filter MT5Transactions to delete.
     * @example
     * // Delete a few MT5Transactions
     * const { count } = await prisma.mT5Transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MT5TransactionDeleteManyArgs>(args?: SelectSubset<T, MT5TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MT5TransactionUpdateManyArgs>(args: SelectSubset<T, MT5TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MT5Transactions and returns the data updated in the database.
     * @param {MT5TransactionUpdateManyAndReturnArgs} args - Arguments to update many MT5Transactions.
     * @example
     * // Update many MT5Transactions
     * const mT5Transaction = await prisma.mT5Transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MT5Transactions and only return the `id`
     * const mT5TransactionWithIdOnly = await prisma.mT5Transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MT5TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, MT5TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MT5Transaction.
     * @param {MT5TransactionUpsertArgs} args - Arguments to update or create a MT5Transaction.
     * @example
     * // Update or create a MT5Transaction
     * const mT5Transaction = await prisma.mT5Transaction.upsert({
     *   create: {
     *     // ... data to create a MT5Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MT5Transaction we want to update
     *   }
     * })
     */
    upsert<T extends MT5TransactionUpsertArgs>(args: SelectSubset<T, MT5TransactionUpsertArgs<ExtArgs>>): Prisma__MT5TransactionClient<$Result.GetResult<Prisma.$MT5TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MT5Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionCountArgs} args - Arguments to filter MT5Transactions to count.
     * @example
     * // Count the number of MT5Transactions
     * const count = await prisma.mT5Transaction.count({
     *   where: {
     *     // ... the filter for the MT5Transactions we want to count
     *   }
     * })
    **/
    count<T extends MT5TransactionCountArgs>(
      args?: Subset<T, MT5TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MT5TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MT5Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MT5TransactionAggregateArgs>(args: Subset<T, MT5TransactionAggregateArgs>): Prisma.PrismaPromise<GetMT5TransactionAggregateType<T>>

    /**
     * Group by MT5Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MT5TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MT5TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MT5TransactionGroupByArgs['orderBy'] }
        : { orderBy?: MT5TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MT5TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMT5TransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MT5Transaction model
   */
  readonly fields: MT5TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MT5Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MT5TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MT5Transaction model
   */
  interface MT5TransactionFieldRefs {
    readonly id: FieldRef<"MT5Transaction", 'String'>
    readonly type: FieldRef<"MT5Transaction", 'String'>
    readonly amount: FieldRef<"MT5Transaction", 'Float'>
    readonly status: FieldRef<"MT5Transaction", 'String'>
    readonly paymentMethod: FieldRef<"MT5Transaction", 'String'>
    readonly transactionId: FieldRef<"MT5Transaction", 'String'>
    readonly comment: FieldRef<"MT5Transaction", 'String'>
    readonly mt5AccountId: FieldRef<"MT5Transaction", 'String'>
    readonly createdAt: FieldRef<"MT5Transaction", 'DateTime'>
    readonly currency: FieldRef<"MT5Transaction", 'String'>
    readonly depositId: FieldRef<"MT5Transaction", 'String'>
    readonly withdrawalId: FieldRef<"MT5Transaction", 'String'>
    readonly userId: FieldRef<"MT5Transaction", 'String'>
    readonly processedBy: FieldRef<"MT5Transaction", 'String'>
    readonly processedAt: FieldRef<"MT5Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"MT5Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MT5Transaction findUnique
   */
  export type MT5TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction findUniqueOrThrow
   */
  export type MT5TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction findFirst
   */
  export type MT5TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Transactions.
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Transactions.
     */
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Transaction findFirstOrThrow
   */
  export type MT5TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transaction to fetch.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MT5Transactions.
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MT5Transactions.
     */
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Transaction findMany
   */
  export type MT5TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter, which MT5Transactions to fetch.
     */
    where?: MT5TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MT5Transactions to fetch.
     */
    orderBy?: MT5TransactionOrderByWithRelationInput | MT5TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MT5Transactions.
     */
    cursor?: MT5TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MT5Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MT5Transactions.
     */
    skip?: number
    distinct?: MT5TransactionScalarFieldEnum | MT5TransactionScalarFieldEnum[]
  }

  /**
   * MT5Transaction create
   */
  export type MT5TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a MT5Transaction.
     */
    data: XOR<MT5TransactionCreateInput, MT5TransactionUncheckedCreateInput>
  }

  /**
   * MT5Transaction createMany
   */
  export type MT5TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MT5Transactions.
     */
    data: MT5TransactionCreateManyInput | MT5TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MT5Transaction createManyAndReturn
   */
  export type MT5TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many MT5Transactions.
     */
    data: MT5TransactionCreateManyInput | MT5TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Transaction update
   */
  export type MT5TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a MT5Transaction.
     */
    data: XOR<MT5TransactionUpdateInput, MT5TransactionUncheckedUpdateInput>
    /**
     * Choose, which MT5Transaction to update.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction updateMany
   */
  export type MT5TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MT5Transactions.
     */
    data: XOR<MT5TransactionUpdateManyMutationInput, MT5TransactionUncheckedUpdateManyInput>
    /**
     * Filter which MT5Transactions to update
     */
    where?: MT5TransactionWhereInput
    /**
     * Limit how many MT5Transactions to update.
     */
    limit?: number
  }

  /**
   * MT5Transaction updateManyAndReturn
   */
  export type MT5TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * The data used to update MT5Transactions.
     */
    data: XOR<MT5TransactionUpdateManyMutationInput, MT5TransactionUncheckedUpdateManyInput>
    /**
     * Filter which MT5Transactions to update
     */
    where?: MT5TransactionWhereInput
    /**
     * Limit how many MT5Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MT5Transaction upsert
   */
  export type MT5TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the MT5Transaction to update in case it exists.
     */
    where: MT5TransactionWhereUniqueInput
    /**
     * In case the MT5Transaction found by the `where` argument doesn't exist, create a new MT5Transaction with this data.
     */
    create: XOR<MT5TransactionCreateInput, MT5TransactionUncheckedCreateInput>
    /**
     * In case the MT5Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MT5TransactionUpdateInput, MT5TransactionUncheckedUpdateInput>
  }

  /**
   * MT5Transaction delete
   */
  export type MT5TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
    /**
     * Filter which MT5Transaction to delete.
     */
    where: MT5TransactionWhereUniqueInput
  }

  /**
   * MT5Transaction deleteMany
   */
  export type MT5TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MT5Transactions to delete
     */
    where?: MT5TransactionWhereInput
    /**
     * Limit how many MT5Transactions to delete.
     */
    limit?: number
  }

  /**
   * MT5Transaction without action
   */
  export type MT5TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Transaction
     */
    select?: MT5TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Transaction
     */
    omit?: MT5TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    balance: number | null
  }

  export type AccountSumAggregateOutputType = {
    balance: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountType: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    balance?: true
  }

  export type AccountSumAggregateInputType = {
    balance?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountType: string
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountType?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountType" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountType: string
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountType: FieldRef<"Account", 'String'>
    readonly balance: FieldRef<"Account", 'Float'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Deposit
   */

  export type AggregateDeposit = {
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  export type DepositAvgAggregateOutputType = {
    amount: number | null
  }

  export type DepositSumAggregateOutputType = {
    amount: number | null
  }

  export type DepositMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    amount: number | null
    currency: string | null
    method: string | null
    paymentMethod: string | null
    transactionHash: string | null
    proofFileUrl: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    depositAddress: string | null
    externalTransactionId: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    amount: number | null
    currency: string | null
    method: string | null
    paymentMethod: string | null
    transactionHash: string | null
    proofFileUrl: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    depositAddress: string | null
    externalTransactionId: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositCountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    amount: number
    currency: number
    method: number
    paymentMethod: number
    transactionHash: number
    proofFileUrl: number
    bankDetails: number
    cryptoAddress: number
    depositAddress: number
    externalTransactionId: number
    status: number
    rejectionReason: number
    approvedBy: number
    approvedAt: number
    rejectedAt: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositAvgAggregateInputType = {
    amount?: true
  }

  export type DepositSumAggregateInputType = {
    amount?: true
  }

  export type DepositMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    currency?: true
    method?: true
    paymentMethod?: true
    transactionHash?: true
    proofFileUrl?: true
    bankDetails?: true
    cryptoAddress?: true
    depositAddress?: true
    externalTransactionId?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    currency?: true
    method?: true
    paymentMethod?: true
    transactionHash?: true
    proofFileUrl?: true
    bankDetails?: true
    cryptoAddress?: true
    depositAddress?: true
    externalTransactionId?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositCountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    amount?: true
    currency?: true
    method?: true
    paymentMethod?: true
    transactionHash?: true
    proofFileUrl?: true
    bankDetails?: true
    cryptoAddress?: true
    depositAddress?: true
    externalTransactionId?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposit to aggregate.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deposits
    **/
    _count?: true | DepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositMaxAggregateInputType
  }

  export type GetDepositAggregateType<T extends DepositAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposit[P]>
      : GetScalarType<T[P], AggregateDeposit[P]>
  }




  export type DepositGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositWhereInput
    orderBy?: DepositOrderByWithAggregationInput | DepositOrderByWithAggregationInput[]
    by: DepositScalarFieldEnum[] | DepositScalarFieldEnum
    having?: DepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositCountAggregateInputType | true
    _avg?: DepositAvgAggregateInputType
    _sum?: DepositSumAggregateInputType
    _min?: DepositMinAggregateInputType
    _max?: DepositMaxAggregateInputType
  }

  export type DepositGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    amount: number
    currency: string
    method: string
    paymentMethod: string | null
    transactionHash: string | null
    proofFileUrl: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    depositAddress: string | null
    externalTransactionId: string | null
    status: string
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DepositCountAggregateOutputType | null
    _avg: DepositAvgAggregateOutputType | null
    _sum: DepositSumAggregateOutputType | null
    _min: DepositMinAggregateOutputType | null
    _max: DepositMaxAggregateOutputType | null
  }

  type GetDepositGroupByPayload<T extends DepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositGroupByOutputType[P]>
            : GetScalarType<T[P], DepositGroupByOutputType[P]>
        }
      >
    >


  export type DepositSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    cregisDeposit?: boolean | Deposit$cregisDepositArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposit"]>

  export type DepositSelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentMethod?: boolean
    transactionHash?: boolean
    proofFileUrl?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    depositAddress?: boolean
    externalTransactionId?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepositOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mt5AccountId" | "amount" | "currency" | "method" | "paymentMethod" | "transactionHash" | "proofFileUrl" | "bankDetails" | "cryptoAddress" | "depositAddress" | "externalTransactionId" | "status" | "rejectionReason" | "approvedBy" | "approvedAt" | "rejectedAt" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["deposit"]>
  export type DepositInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    cregisDeposit?: boolean | Deposit$cregisDepositArgs<ExtArgs>
  }
  export type DepositIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DepositIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mt5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DepositPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deposit"
    objects: {
      mt5Account: Prisma.$MT5AccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      cregisDeposit: Prisma.$CregisDepositPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      amount: number
      currency: string
      method: string
      paymentMethod: string | null
      transactionHash: string | null
      proofFileUrl: string | null
      bankDetails: string | null
      cryptoAddress: string | null
      depositAddress: string | null
      externalTransactionId: string | null
      status: string
      rejectionReason: string | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deposit"]>
    composites: {}
  }

  type DepositGetPayload<S extends boolean | null | undefined | DepositDefaultArgs> = $Result.GetResult<Prisma.$DepositPayload, S>

  type DepositCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepositFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositCountAggregateInputType | true
    }

  export interface DepositDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deposit'], meta: { name: 'Deposit' } }
    /**
     * Find zero or one Deposit that matches the filter.
     * @param {DepositFindUniqueArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositFindUniqueArgs>(args: SelectSubset<T, DepositFindUniqueArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepositFindUniqueOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositFindFirstArgs>(args?: SelectSubset<T, DepositFindFirstArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindFirstOrThrowArgs} args - Arguments to find a Deposit
     * @example
     * // Get one Deposit
     * const deposit = await prisma.deposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposits
     * const deposits = await prisma.deposit.findMany()
     * 
     * // Get first 10 Deposits
     * const deposits = await prisma.deposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositWithIdOnly = await prisma.deposit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositFindManyArgs>(args?: SelectSubset<T, DepositFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposit.
     * @param {DepositCreateArgs} args - Arguments to create a Deposit.
     * @example
     * // Create one Deposit
     * const Deposit = await prisma.deposit.create({
     *   data: {
     *     // ... data to create a Deposit
     *   }
     * })
     * 
     */
    create<T extends DepositCreateArgs>(args: SelectSubset<T, DepositCreateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deposits.
     * @param {DepositCreateManyArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositCreateManyArgs>(args?: SelectSubset<T, DepositCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposits and returns the data saved in the database.
     * @param {DepositCreateManyAndReturnArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposit = await prisma.deposit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepositCreateManyAndReturnArgs>(args?: SelectSubset<T, DepositCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deposit.
     * @param {DepositDeleteArgs} args - Arguments to delete one Deposit.
     * @example
     * // Delete one Deposit
     * const Deposit = await prisma.deposit.delete({
     *   where: {
     *     // ... filter to delete one Deposit
     *   }
     * })
     * 
     */
    delete<T extends DepositDeleteArgs>(args: SelectSubset<T, DepositDeleteArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposit.
     * @param {DepositUpdateArgs} args - Arguments to update one Deposit.
     * @example
     * // Update one Deposit
     * const deposit = await prisma.deposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositUpdateArgs>(args: SelectSubset<T, DepositUpdateArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deposits.
     * @param {DepositDeleteManyArgs} args - Arguments to filter Deposits to delete.
     * @example
     * // Delete a few Deposits
     * const { count } = await prisma.deposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositDeleteManyArgs>(args?: SelectSubset<T, DepositDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositUpdateManyArgs>(args: SelectSubset<T, DepositUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits and returns the data updated in the database.
     * @param {DepositUpdateManyAndReturnArgs} args - Arguments to update many Deposits.
     * @example
     * // Update many Deposits
     * const deposit = await prisma.deposit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deposits and only return the `id`
     * const depositWithIdOnly = await prisma.deposit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepositUpdateManyAndReturnArgs>(args: SelectSubset<T, DepositUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deposit.
     * @param {DepositUpsertArgs} args - Arguments to update or create a Deposit.
     * @example
     * // Update or create a Deposit
     * const deposit = await prisma.deposit.upsert({
     *   create: {
     *     // ... data to create a Deposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposit we want to update
     *   }
     * })
     */
    upsert<T extends DepositUpsertArgs>(args: SelectSubset<T, DepositUpsertArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositCountArgs} args - Arguments to filter Deposits to count.
     * @example
     * // Count the number of Deposits
     * const count = await prisma.deposit.count({
     *   where: {
     *     // ... the filter for the Deposits we want to count
     *   }
     * })
    **/
    count<T extends DepositCountArgs>(
      args?: Subset<T, DepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositAggregateArgs>(args: Subset<T, DepositAggregateArgs>): Prisma.PrismaPromise<GetDepositAggregateType<T>>

    /**
     * Group by Deposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositGroupByArgs['orderBy'] }
        : { orderBy?: DepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deposit model
   */
  readonly fields: DepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mt5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cregisDeposit<T extends Deposit$cregisDepositArgs<ExtArgs> = {}>(args?: Subset<T, Deposit$cregisDepositArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deposit model
   */
  interface DepositFieldRefs {
    readonly id: FieldRef<"Deposit", 'String'>
    readonly userId: FieldRef<"Deposit", 'String'>
    readonly mt5AccountId: FieldRef<"Deposit", 'String'>
    readonly amount: FieldRef<"Deposit", 'Float'>
    readonly currency: FieldRef<"Deposit", 'String'>
    readonly method: FieldRef<"Deposit", 'String'>
    readonly paymentMethod: FieldRef<"Deposit", 'String'>
    readonly transactionHash: FieldRef<"Deposit", 'String'>
    readonly proofFileUrl: FieldRef<"Deposit", 'String'>
    readonly bankDetails: FieldRef<"Deposit", 'String'>
    readonly cryptoAddress: FieldRef<"Deposit", 'String'>
    readonly depositAddress: FieldRef<"Deposit", 'String'>
    readonly externalTransactionId: FieldRef<"Deposit", 'String'>
    readonly status: FieldRef<"Deposit", 'String'>
    readonly rejectionReason: FieldRef<"Deposit", 'String'>
    readonly approvedBy: FieldRef<"Deposit", 'String'>
    readonly approvedAt: FieldRef<"Deposit", 'DateTime'>
    readonly rejectedAt: FieldRef<"Deposit", 'DateTime'>
    readonly processedAt: FieldRef<"Deposit", 'DateTime'>
    readonly createdAt: FieldRef<"Deposit", 'DateTime'>
    readonly updatedAt: FieldRef<"Deposit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deposit findUnique
   */
  export type DepositFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findUniqueOrThrow
   */
  export type DepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit findFirst
   */
  export type DepositFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findFirstOrThrow
   */
  export type DepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposit to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit findMany
   */
  export type DepositFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositOrderByWithRelationInput | DepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deposits.
     */
    cursor?: DepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    distinct?: DepositScalarFieldEnum | DepositScalarFieldEnum[]
  }

  /**
   * Deposit create
   */
  export type DepositCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to create a Deposit.
     */
    data: XOR<DepositCreateInput, DepositUncheckedCreateInput>
  }

  /**
   * Deposit createMany
   */
  export type DepositCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deposit createManyAndReturn
   */
  export type DepositCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * The data used to create many Deposits.
     */
    data: DepositCreateManyInput | DepositCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit update
   */
  export type DepositUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The data needed to update a Deposit.
     */
    data: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
    /**
     * Choose, which Deposit to update.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit updateMany
   */
  export type DepositUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
  }

  /**
   * Deposit updateManyAndReturn
   */
  export type DepositUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposit upsert
   */
  export type DepositUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * The filter to search for the Deposit to update in case it exists.
     */
    where: DepositWhereUniqueInput
    /**
     * In case the Deposit found by the `where` argument doesn't exist, create a new Deposit with this data.
     */
    create: XOR<DepositCreateInput, DepositUncheckedCreateInput>
    /**
     * In case the Deposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositUpdateInput, DepositUncheckedUpdateInput>
  }

  /**
   * Deposit delete
   */
  export type DepositDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
    /**
     * Filter which Deposit to delete.
     */
    where: DepositWhereUniqueInput
  }

  /**
   * Deposit deleteMany
   */
  export type DepositDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposits to delete
     */
    where?: DepositWhereInput
    /**
     * Limit how many Deposits to delete.
     */
    limit?: number
  }

  /**
   * Deposit.cregisDeposit
   */
  export type Deposit$cregisDepositArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    where?: CregisDepositWhereInput
  }

  /**
   * Deposit without action
   */
  export type DepositDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposit
     */
    select?: DepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposit
     */
    omit?: DepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositInclude<ExtArgs> | null
  }


  /**
   * Model CregisDeposit
   */

  export type AggregateCregisDeposit = {
    _count: CregisDepositCountAggregateOutputType | null
    _avg: CregisDepositAvgAggregateOutputType | null
    _sum: CregisDepositSumAggregateOutputType | null
    _min: CregisDepositMinAggregateOutputType | null
    _max: CregisDepositMaxAggregateOutputType | null
  }

  export type CregisDepositAvgAggregateOutputType = {
    amount: number | null
  }

  export type CregisDepositSumAggregateOutputType = {
    amount: number | null
  }

  export type CregisDepositMinAggregateOutputType = {
    id: string | null
    depositId: string | null
    cregisOrderId: string | null
    cregisStatus: string | null
    amount: number | null
    currency: string | null
    paymentUrl: string | null
    qrCodeUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CregisDepositMaxAggregateOutputType = {
    id: string | null
    depositId: string | null
    cregisOrderId: string | null
    cregisStatus: string | null
    amount: number | null
    currency: string | null
    paymentUrl: string | null
    qrCodeUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CregisDepositCountAggregateOutputType = {
    id: number
    depositId: number
    cregisOrderId: number
    cregisStatus: number
    amount: number
    currency: number
    paymentUrl: number
    qrCodeUrl: number
    expiresAt: number
    webhookData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CregisDepositAvgAggregateInputType = {
    amount?: true
  }

  export type CregisDepositSumAggregateInputType = {
    amount?: true
  }

  export type CregisDepositMinAggregateInputType = {
    id?: true
    depositId?: true
    cregisOrderId?: true
    cregisStatus?: true
    amount?: true
    currency?: true
    paymentUrl?: true
    qrCodeUrl?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CregisDepositMaxAggregateInputType = {
    id?: true
    depositId?: true
    cregisOrderId?: true
    cregisStatus?: true
    amount?: true
    currency?: true
    paymentUrl?: true
    qrCodeUrl?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CregisDepositCountAggregateInputType = {
    id?: true
    depositId?: true
    cregisOrderId?: true
    cregisStatus?: true
    amount?: true
    currency?: true
    paymentUrl?: true
    qrCodeUrl?: true
    expiresAt?: true
    webhookData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CregisDepositAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CregisDeposit to aggregate.
     */
    where?: CregisDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CregisDeposits to fetch.
     */
    orderBy?: CregisDepositOrderByWithRelationInput | CregisDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CregisDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CregisDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CregisDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CregisDeposits
    **/
    _count?: true | CregisDepositCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CregisDepositAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CregisDepositSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CregisDepositMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CregisDepositMaxAggregateInputType
  }

  export type GetCregisDepositAggregateType<T extends CregisDepositAggregateArgs> = {
        [P in keyof T & keyof AggregateCregisDeposit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCregisDeposit[P]>
      : GetScalarType<T[P], AggregateCregisDeposit[P]>
  }




  export type CregisDepositGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CregisDepositWhereInput
    orderBy?: CregisDepositOrderByWithAggregationInput | CregisDepositOrderByWithAggregationInput[]
    by: CregisDepositScalarFieldEnum[] | CregisDepositScalarFieldEnum
    having?: CregisDepositScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CregisDepositCountAggregateInputType | true
    _avg?: CregisDepositAvgAggregateInputType
    _sum?: CregisDepositSumAggregateInputType
    _min?: CregisDepositMinAggregateInputType
    _max?: CregisDepositMaxAggregateInputType
  }

  export type CregisDepositGroupByOutputType = {
    id: string
    depositId: string
    cregisOrderId: string
    cregisStatus: string
    amount: number
    currency: string
    paymentUrl: string | null
    qrCodeUrl: string | null
    expiresAt: Date | null
    webhookData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CregisDepositCountAggregateOutputType | null
    _avg: CregisDepositAvgAggregateOutputType | null
    _sum: CregisDepositSumAggregateOutputType | null
    _min: CregisDepositMinAggregateOutputType | null
    _max: CregisDepositMaxAggregateOutputType | null
  }

  type GetCregisDepositGroupByPayload<T extends CregisDepositGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CregisDepositGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CregisDepositGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CregisDepositGroupByOutputType[P]>
            : GetScalarType<T[P], CregisDepositGroupByOutputType[P]>
        }
      >
    >


  export type CregisDepositSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    depositId?: boolean
    cregisOrderId?: boolean
    cregisStatus?: boolean
    amount?: boolean
    currency?: boolean
    paymentUrl?: boolean
    qrCodeUrl?: boolean
    expiresAt?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deposit?: boolean | DepositDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cregisDeposit"]>

  export type CregisDepositSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    depositId?: boolean
    cregisOrderId?: boolean
    cregisStatus?: boolean
    amount?: boolean
    currency?: boolean
    paymentUrl?: boolean
    qrCodeUrl?: boolean
    expiresAt?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deposit?: boolean | DepositDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cregisDeposit"]>

  export type CregisDepositSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    depositId?: boolean
    cregisOrderId?: boolean
    cregisStatus?: boolean
    amount?: boolean
    currency?: boolean
    paymentUrl?: boolean
    qrCodeUrl?: boolean
    expiresAt?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deposit?: boolean | DepositDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cregisDeposit"]>

  export type CregisDepositSelectScalar = {
    id?: boolean
    depositId?: boolean
    cregisOrderId?: boolean
    cregisStatus?: boolean
    amount?: boolean
    currency?: boolean
    paymentUrl?: boolean
    qrCodeUrl?: boolean
    expiresAt?: boolean
    webhookData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CregisDepositOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "depositId" | "cregisOrderId" | "cregisStatus" | "amount" | "currency" | "paymentUrl" | "qrCodeUrl" | "expiresAt" | "webhookData" | "createdAt" | "updatedAt", ExtArgs["result"]["cregisDeposit"]>
  export type CregisDepositInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit?: boolean | DepositDefaultArgs<ExtArgs>
  }
  export type CregisDepositIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit?: boolean | DepositDefaultArgs<ExtArgs>
  }
  export type CregisDepositIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deposit?: boolean | DepositDefaultArgs<ExtArgs>
  }

  export type $CregisDepositPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CregisDeposit"
    objects: {
      deposit: Prisma.$DepositPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      depositId: string
      cregisOrderId: string
      cregisStatus: string
      amount: number
      currency: string
      paymentUrl: string | null
      qrCodeUrl: string | null
      expiresAt: Date | null
      webhookData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cregisDeposit"]>
    composites: {}
  }

  type CregisDepositGetPayload<S extends boolean | null | undefined | CregisDepositDefaultArgs> = $Result.GetResult<Prisma.$CregisDepositPayload, S>

  type CregisDepositCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CregisDepositFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CregisDepositCountAggregateInputType | true
    }

  export interface CregisDepositDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CregisDeposit'], meta: { name: 'CregisDeposit' } }
    /**
     * Find zero or one CregisDeposit that matches the filter.
     * @param {CregisDepositFindUniqueArgs} args - Arguments to find a CregisDeposit
     * @example
     * // Get one CregisDeposit
     * const cregisDeposit = await prisma.cregisDeposit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CregisDepositFindUniqueArgs>(args: SelectSubset<T, CregisDepositFindUniqueArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CregisDeposit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CregisDepositFindUniqueOrThrowArgs} args - Arguments to find a CregisDeposit
     * @example
     * // Get one CregisDeposit
     * const cregisDeposit = await prisma.cregisDeposit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CregisDepositFindUniqueOrThrowArgs>(args: SelectSubset<T, CregisDepositFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CregisDeposit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositFindFirstArgs} args - Arguments to find a CregisDeposit
     * @example
     * // Get one CregisDeposit
     * const cregisDeposit = await prisma.cregisDeposit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CregisDepositFindFirstArgs>(args?: SelectSubset<T, CregisDepositFindFirstArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CregisDeposit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositFindFirstOrThrowArgs} args - Arguments to find a CregisDeposit
     * @example
     * // Get one CregisDeposit
     * const cregisDeposit = await prisma.cregisDeposit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CregisDepositFindFirstOrThrowArgs>(args?: SelectSubset<T, CregisDepositFindFirstOrThrowArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CregisDeposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CregisDeposits
     * const cregisDeposits = await prisma.cregisDeposit.findMany()
     * 
     * // Get first 10 CregisDeposits
     * const cregisDeposits = await prisma.cregisDeposit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cregisDepositWithIdOnly = await prisma.cregisDeposit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CregisDepositFindManyArgs>(args?: SelectSubset<T, CregisDepositFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CregisDeposit.
     * @param {CregisDepositCreateArgs} args - Arguments to create a CregisDeposit.
     * @example
     * // Create one CregisDeposit
     * const CregisDeposit = await prisma.cregisDeposit.create({
     *   data: {
     *     // ... data to create a CregisDeposit
     *   }
     * })
     * 
     */
    create<T extends CregisDepositCreateArgs>(args: SelectSubset<T, CregisDepositCreateArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CregisDeposits.
     * @param {CregisDepositCreateManyArgs} args - Arguments to create many CregisDeposits.
     * @example
     * // Create many CregisDeposits
     * const cregisDeposit = await prisma.cregisDeposit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CregisDepositCreateManyArgs>(args?: SelectSubset<T, CregisDepositCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CregisDeposits and returns the data saved in the database.
     * @param {CregisDepositCreateManyAndReturnArgs} args - Arguments to create many CregisDeposits.
     * @example
     * // Create many CregisDeposits
     * const cregisDeposit = await prisma.cregisDeposit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CregisDeposits and only return the `id`
     * const cregisDepositWithIdOnly = await prisma.cregisDeposit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CregisDepositCreateManyAndReturnArgs>(args?: SelectSubset<T, CregisDepositCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CregisDeposit.
     * @param {CregisDepositDeleteArgs} args - Arguments to delete one CregisDeposit.
     * @example
     * // Delete one CregisDeposit
     * const CregisDeposit = await prisma.cregisDeposit.delete({
     *   where: {
     *     // ... filter to delete one CregisDeposit
     *   }
     * })
     * 
     */
    delete<T extends CregisDepositDeleteArgs>(args: SelectSubset<T, CregisDepositDeleteArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CregisDeposit.
     * @param {CregisDepositUpdateArgs} args - Arguments to update one CregisDeposit.
     * @example
     * // Update one CregisDeposit
     * const cregisDeposit = await prisma.cregisDeposit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CregisDepositUpdateArgs>(args: SelectSubset<T, CregisDepositUpdateArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CregisDeposits.
     * @param {CregisDepositDeleteManyArgs} args - Arguments to filter CregisDeposits to delete.
     * @example
     * // Delete a few CregisDeposits
     * const { count } = await prisma.cregisDeposit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CregisDepositDeleteManyArgs>(args?: SelectSubset<T, CregisDepositDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CregisDeposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CregisDeposits
     * const cregisDeposit = await prisma.cregisDeposit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CregisDepositUpdateManyArgs>(args: SelectSubset<T, CregisDepositUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CregisDeposits and returns the data updated in the database.
     * @param {CregisDepositUpdateManyAndReturnArgs} args - Arguments to update many CregisDeposits.
     * @example
     * // Update many CregisDeposits
     * const cregisDeposit = await prisma.cregisDeposit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CregisDeposits and only return the `id`
     * const cregisDepositWithIdOnly = await prisma.cregisDeposit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CregisDepositUpdateManyAndReturnArgs>(args: SelectSubset<T, CregisDepositUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CregisDeposit.
     * @param {CregisDepositUpsertArgs} args - Arguments to update or create a CregisDeposit.
     * @example
     * // Update or create a CregisDeposit
     * const cregisDeposit = await prisma.cregisDeposit.upsert({
     *   create: {
     *     // ... data to create a CregisDeposit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CregisDeposit we want to update
     *   }
     * })
     */
    upsert<T extends CregisDepositUpsertArgs>(args: SelectSubset<T, CregisDepositUpsertArgs<ExtArgs>>): Prisma__CregisDepositClient<$Result.GetResult<Prisma.$CregisDepositPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CregisDeposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositCountArgs} args - Arguments to filter CregisDeposits to count.
     * @example
     * // Count the number of CregisDeposits
     * const count = await prisma.cregisDeposit.count({
     *   where: {
     *     // ... the filter for the CregisDeposits we want to count
     *   }
     * })
    **/
    count<T extends CregisDepositCountArgs>(
      args?: Subset<T, CregisDepositCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CregisDepositCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CregisDeposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CregisDepositAggregateArgs>(args: Subset<T, CregisDepositAggregateArgs>): Prisma.PrismaPromise<GetCregisDepositAggregateType<T>>

    /**
     * Group by CregisDeposit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CregisDepositGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CregisDepositGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CregisDepositGroupByArgs['orderBy'] }
        : { orderBy?: CregisDepositGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CregisDepositGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCregisDepositGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CregisDeposit model
   */
  readonly fields: CregisDepositFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CregisDeposit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CregisDepositClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deposit<T extends DepositDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepositDefaultArgs<ExtArgs>>): Prisma__DepositClient<$Result.GetResult<Prisma.$DepositPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CregisDeposit model
   */
  interface CregisDepositFieldRefs {
    readonly id: FieldRef<"CregisDeposit", 'String'>
    readonly depositId: FieldRef<"CregisDeposit", 'String'>
    readonly cregisOrderId: FieldRef<"CregisDeposit", 'String'>
    readonly cregisStatus: FieldRef<"CregisDeposit", 'String'>
    readonly amount: FieldRef<"CregisDeposit", 'Float'>
    readonly currency: FieldRef<"CregisDeposit", 'String'>
    readonly paymentUrl: FieldRef<"CregisDeposit", 'String'>
    readonly qrCodeUrl: FieldRef<"CregisDeposit", 'String'>
    readonly expiresAt: FieldRef<"CregisDeposit", 'DateTime'>
    readonly webhookData: FieldRef<"CregisDeposit", 'Json'>
    readonly createdAt: FieldRef<"CregisDeposit", 'DateTime'>
    readonly updatedAt: FieldRef<"CregisDeposit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CregisDeposit findUnique
   */
  export type CregisDepositFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * Filter, which CregisDeposit to fetch.
     */
    where: CregisDepositWhereUniqueInput
  }

  /**
   * CregisDeposit findUniqueOrThrow
   */
  export type CregisDepositFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * Filter, which CregisDeposit to fetch.
     */
    where: CregisDepositWhereUniqueInput
  }

  /**
   * CregisDeposit findFirst
   */
  export type CregisDepositFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * Filter, which CregisDeposit to fetch.
     */
    where?: CregisDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CregisDeposits to fetch.
     */
    orderBy?: CregisDepositOrderByWithRelationInput | CregisDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CregisDeposits.
     */
    cursor?: CregisDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CregisDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CregisDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CregisDeposits.
     */
    distinct?: CregisDepositScalarFieldEnum | CregisDepositScalarFieldEnum[]
  }

  /**
   * CregisDeposit findFirstOrThrow
   */
  export type CregisDepositFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * Filter, which CregisDeposit to fetch.
     */
    where?: CregisDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CregisDeposits to fetch.
     */
    orderBy?: CregisDepositOrderByWithRelationInput | CregisDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CregisDeposits.
     */
    cursor?: CregisDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CregisDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CregisDeposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CregisDeposits.
     */
    distinct?: CregisDepositScalarFieldEnum | CregisDepositScalarFieldEnum[]
  }

  /**
   * CregisDeposit findMany
   */
  export type CregisDepositFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * Filter, which CregisDeposits to fetch.
     */
    where?: CregisDepositWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CregisDeposits to fetch.
     */
    orderBy?: CregisDepositOrderByWithRelationInput | CregisDepositOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CregisDeposits.
     */
    cursor?: CregisDepositWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CregisDeposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CregisDeposits.
     */
    skip?: number
    distinct?: CregisDepositScalarFieldEnum | CregisDepositScalarFieldEnum[]
  }

  /**
   * CregisDeposit create
   */
  export type CregisDepositCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * The data needed to create a CregisDeposit.
     */
    data: XOR<CregisDepositCreateInput, CregisDepositUncheckedCreateInput>
  }

  /**
   * CregisDeposit createMany
   */
  export type CregisDepositCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CregisDeposits.
     */
    data: CregisDepositCreateManyInput | CregisDepositCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CregisDeposit createManyAndReturn
   */
  export type CregisDepositCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * The data used to create many CregisDeposits.
     */
    data: CregisDepositCreateManyInput | CregisDepositCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CregisDeposit update
   */
  export type CregisDepositUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * The data needed to update a CregisDeposit.
     */
    data: XOR<CregisDepositUpdateInput, CregisDepositUncheckedUpdateInput>
    /**
     * Choose, which CregisDeposit to update.
     */
    where: CregisDepositWhereUniqueInput
  }

  /**
   * CregisDeposit updateMany
   */
  export type CregisDepositUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CregisDeposits.
     */
    data: XOR<CregisDepositUpdateManyMutationInput, CregisDepositUncheckedUpdateManyInput>
    /**
     * Filter which CregisDeposits to update
     */
    where?: CregisDepositWhereInput
    /**
     * Limit how many CregisDeposits to update.
     */
    limit?: number
  }

  /**
   * CregisDeposit updateManyAndReturn
   */
  export type CregisDepositUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * The data used to update CregisDeposits.
     */
    data: XOR<CregisDepositUpdateManyMutationInput, CregisDepositUncheckedUpdateManyInput>
    /**
     * Filter which CregisDeposits to update
     */
    where?: CregisDepositWhereInput
    /**
     * Limit how many CregisDeposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CregisDeposit upsert
   */
  export type CregisDepositUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * The filter to search for the CregisDeposit to update in case it exists.
     */
    where: CregisDepositWhereUniqueInput
    /**
     * In case the CregisDeposit found by the `where` argument doesn't exist, create a new CregisDeposit with this data.
     */
    create: XOR<CregisDepositCreateInput, CregisDepositUncheckedCreateInput>
    /**
     * In case the CregisDeposit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CregisDepositUpdateInput, CregisDepositUncheckedUpdateInput>
  }

  /**
   * CregisDeposit delete
   */
  export type CregisDepositDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
    /**
     * Filter which CregisDeposit to delete.
     */
    where: CregisDepositWhereUniqueInput
  }

  /**
   * CregisDeposit deleteMany
   */
  export type CregisDepositDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CregisDeposits to delete
     */
    where?: CregisDepositWhereInput
    /**
     * Limit how many CregisDeposits to delete.
     */
    limit?: number
  }

  /**
   * CregisDeposit without action
   */
  export type CregisDepositDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CregisDeposit
     */
    select?: CregisDepositSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CregisDeposit
     */
    omit?: CregisDepositOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CregisDepositInclude<ExtArgs> | null
  }


  /**
   * Model Withdrawal
   */

  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    amount: number | null
  }

  export type WithdrawalSumAggregateOutputType = {
    amount: number | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    method: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    externalTransactionId: string | null
    paymentMethod: string | null
    processedAt: Date | null
    walletAddress: string | null
    walletId: string | null
    mt5AccountId: string | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    method: string | null
    bankDetails: string | null
    cryptoAddress: string | null
    status: string | null
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    externalTransactionId: string | null
    paymentMethod: string | null
    processedAt: Date | null
    walletAddress: string | null
    walletId: string | null
    mt5AccountId: string | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    method: number
    bankDetails: number
    cryptoAddress: number
    status: number
    rejectionReason: number
    approvedBy: number
    approvedAt: number
    rejectedAt: number
    createdAt: number
    updatedAt: number
    currency: number
    externalTransactionId: number
    paymentMethod: number
    processedAt: number
    walletAddress: number
    walletId: number
    mt5AccountId: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    amount?: true
  }

  export type WithdrawalSumAggregateInputType = {
    amount?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    method?: true
    bankDetails?: true
    cryptoAddress?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    externalTransactionId?: true
    paymentMethod?: true
    processedAt?: true
    walletAddress?: true
    walletId?: true
    mt5AccountId?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    method?: true
    bankDetails?: true
    cryptoAddress?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    externalTransactionId?: true
    paymentMethod?: true
    processedAt?: true
    walletAddress?: true
    walletId?: true
    mt5AccountId?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    method?: true
    bankDetails?: true
    cryptoAddress?: true
    status?: true
    rejectionReason?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    externalTransactionId?: true
    paymentMethod?: true
    processedAt?: true
    walletAddress?: true
    walletId?: true
    mt5AccountId?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawal to aggregate.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type WithdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalWhereInput
    orderBy?: WithdrawalOrderByWithAggregationInput | WithdrawalOrderByWithAggregationInput[]
    by: WithdrawalScalarFieldEnum[] | WithdrawalScalarFieldEnum
    having?: WithdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }

  export type WithdrawalGroupByOutputType = {
    id: string
    userId: string
    amount: number
    method: string
    bankDetails: string | null
    cryptoAddress: string | null
    status: string
    rejectionReason: string | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    createdAt: Date
    updatedAt: Date
    currency: string
    externalTransactionId: string | null
    paymentMethod: string | null
    processedAt: Date | null
    walletAddress: string | null
    walletId: string | null
    mt5AccountId: string | null
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends WithdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    walletId?: boolean
    mt5AccountId?: boolean
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    walletId?: boolean
    mt5AccountId?: boolean
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    walletId?: boolean
    mt5AccountId?: boolean
  }, ExtArgs["result"]["withdrawal"]>

  export type WithdrawalSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    method?: boolean
    bankDetails?: boolean
    cryptoAddress?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    externalTransactionId?: boolean
    paymentMethod?: boolean
    processedAt?: boolean
    walletAddress?: boolean
    walletId?: boolean
    mt5AccountId?: boolean
  }

  export type WithdrawalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "method" | "bankDetails" | "cryptoAddress" | "status" | "rejectionReason" | "approvedBy" | "approvedAt" | "rejectedAt" | "createdAt" | "updatedAt" | "currency" | "externalTransactionId" | "paymentMethod" | "processedAt" | "walletAddress" | "walletId" | "mt5AccountId", ExtArgs["result"]["withdrawal"]>

  export type $WithdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Withdrawal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      method: string
      bankDetails: string | null
      cryptoAddress: string | null
      status: string
      rejectionReason: string | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      createdAt: Date
      updatedAt: Date
      currency: string
      externalTransactionId: string | null
      paymentMethod: string | null
      processedAt: Date | null
      walletAddress: string | null
      walletId: string | null
      mt5AccountId: string | null
    }, ExtArgs["result"]["withdrawal"]>
    composites: {}
  }

  type WithdrawalGetPayload<S extends boolean | null | undefined | WithdrawalDefaultArgs> = $Result.GetResult<Prisma.$WithdrawalPayload, S>

  type WithdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WithdrawalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalCountAggregateInputType | true
    }

  export interface WithdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Withdrawal'], meta: { name: 'Withdrawal' } }
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {WithdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WithdrawalFindUniqueArgs>(args: SelectSubset<T, WithdrawalFindUniqueArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Withdrawal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WithdrawalFindUniqueOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WithdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, WithdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WithdrawalFindFirstArgs>(args?: SelectSubset<T, WithdrawalFindFirstArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindFirstOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WithdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, WithdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WithdrawalFindManyArgs>(args?: SelectSubset<T, WithdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Withdrawal.
     * @param {WithdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     * 
     */
    create<T extends WithdrawalCreateArgs>(args: SelectSubset<T, WithdrawalCreateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Withdrawals.
     * @param {WithdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WithdrawalCreateManyArgs>(args?: SelectSubset<T, WithdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {WithdrawalCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WithdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, WithdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Withdrawal.
     * @param {WithdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     * 
     */
    delete<T extends WithdrawalDeleteArgs>(args: SelectSubset<T, WithdrawalDeleteArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Withdrawal.
     * @param {WithdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WithdrawalUpdateArgs>(args: SelectSubset<T, WithdrawalUpdateArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {WithdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WithdrawalDeleteManyArgs>(args?: SelectSubset<T, WithdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WithdrawalUpdateManyArgs>(args: SelectSubset<T, WithdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {WithdrawalUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WithdrawalUpdateManyAndReturnArgs>(args: SelectSubset<T, WithdrawalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Withdrawal.
     * @param {WithdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends WithdrawalUpsertArgs>(args: SelectSubset<T, WithdrawalUpsertArgs<ExtArgs>>): Prisma__WithdrawalClient<$Result.GetResult<Prisma.$WithdrawalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalCountArgs>(
      args?: Subset<T, WithdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Withdrawal model
   */
  readonly fields: WithdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Withdrawal model
   */
  interface WithdrawalFieldRefs {
    readonly id: FieldRef<"Withdrawal", 'String'>
    readonly userId: FieldRef<"Withdrawal", 'String'>
    readonly amount: FieldRef<"Withdrawal", 'Float'>
    readonly method: FieldRef<"Withdrawal", 'String'>
    readonly bankDetails: FieldRef<"Withdrawal", 'String'>
    readonly cryptoAddress: FieldRef<"Withdrawal", 'String'>
    readonly status: FieldRef<"Withdrawal", 'String'>
    readonly rejectionReason: FieldRef<"Withdrawal", 'String'>
    readonly approvedBy: FieldRef<"Withdrawal", 'String'>
    readonly approvedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly rejectedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly createdAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly updatedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly currency: FieldRef<"Withdrawal", 'String'>
    readonly externalTransactionId: FieldRef<"Withdrawal", 'String'>
    readonly paymentMethod: FieldRef<"Withdrawal", 'String'>
    readonly processedAt: FieldRef<"Withdrawal", 'DateTime'>
    readonly walletAddress: FieldRef<"Withdrawal", 'String'>
    readonly walletId: FieldRef<"Withdrawal", 'String'>
    readonly mt5AccountId: FieldRef<"Withdrawal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Withdrawal findUnique
   */
  export type WithdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findUniqueOrThrow
   */
  export type WithdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal findFirst
   */
  export type WithdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findFirstOrThrow
   */
  export type WithdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Filter, which Withdrawal to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal findMany
   */
  export type WithdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Filter, which Withdrawals to fetch.
     */
    where?: WithdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdrawals to fetch.
     */
    orderBy?: WithdrawalOrderByWithRelationInput | WithdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Withdrawals.
     */
    cursor?: WithdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdrawals.
     */
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * Withdrawal create
   */
  export type WithdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data needed to create a Withdrawal.
     */
    data: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
  }

  /**
   * Withdrawal createMany
   */
  export type WithdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Withdrawal createManyAndReturn
   */
  export type WithdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data used to create many Withdrawals.
     */
    data: WithdrawalCreateManyInput | WithdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Withdrawal update
   */
  export type WithdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data needed to update a Withdrawal.
     */
    data: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
    /**
     * Choose, which Withdrawal to update.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal updateMany
   */
  export type WithdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
  }

  /**
   * Withdrawal updateManyAndReturn
   */
  export type WithdrawalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The data used to update Withdrawals.
     */
    data: XOR<WithdrawalUpdateManyMutationInput, WithdrawalUncheckedUpdateManyInput>
    /**
     * Filter which Withdrawals to update
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to update.
     */
    limit?: number
  }

  /**
   * Withdrawal upsert
   */
  export type WithdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * The filter to search for the Withdrawal to update in case it exists.
     */
    where: WithdrawalWhereUniqueInput
    /**
     * In case the Withdrawal found by the `where` argument doesn't exist, create a new Withdrawal with this data.
     */
    create: XOR<WithdrawalCreateInput, WithdrawalUncheckedCreateInput>
    /**
     * In case the Withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawalUpdateInput, WithdrawalUncheckedUpdateInput>
  }

  /**
   * Withdrawal delete
   */
  export type WithdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
    /**
     * Filter which Withdrawal to delete.
     */
    where: WithdrawalWhereUniqueInput
  }

  /**
   * Withdrawal deleteMany
   */
  export type WithdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdrawals to delete
     */
    where?: WithdrawalWhereInput
    /**
     * Limit how many Withdrawals to delete.
     */
    limit?: number
  }

  /**
   * Withdrawal without action
   */
  export type WithdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdrawal
     */
    select?: WithdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Withdrawal
     */
    omit?: WithdrawalOmit<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: number | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
    walletNumber: string | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: number | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
    walletNumber: string | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    balance: number
    currency: number
    createdAt: number
    updatedAt: number
    walletNumber: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    walletNumber?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    walletNumber?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    walletNumber?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    balance: number
    currency: string
    createdAt: Date
    updatedAt: Date
    walletNumber: string | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletNumber?: boolean
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletNumber?: boolean
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletNumber?: boolean
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    balance?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    walletNumber?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "balance" | "currency" | "createdAt" | "updatedAt" | "walletNumber", ExtArgs["result"]["wallet"]>

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      balance: number
      currency: string
      createdAt: Date
      updatedAt: Date
      walletNumber: string | null
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Float'>
    readonly currency: FieldRef<"Wallet", 'String'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
    readonly walletNumber: FieldRef<"Wallet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    userId: string | null
    type: string | null
    amount: number | null
    status: string | null
    description: string | null
    mt5AccountId: string | null
    withdrawalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    userId: string | null
    type: string | null
    amount: number | null
    status: string | null
    description: string | null
    mt5AccountId: string | null
    withdrawalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    walletId: number
    userId: number
    type: number
    amount: number
    status: number
    description: number
    mt5AccountId: number
    withdrawalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amount?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    description?: true
    mt5AccountId?: true
    withdrawalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    description?: true
    mt5AccountId?: true
    withdrawalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    description?: true
    mt5AccountId?: true
    withdrawalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    walletId: string
    userId: string
    type: string
    amount: number
    status: string
    description: string | null
    mt5AccountId: string | null
    withdrawalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    description?: boolean
    mt5AccountId?: boolean
    withdrawalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    description?: boolean
    mt5AccountId?: boolean
    withdrawalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    description?: boolean
    mt5AccountId?: boolean
    withdrawalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    description?: boolean
    mt5AccountId?: boolean
    withdrawalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "userId" | "type" | "amount" | "status" | "description" | "mt5AccountId" | "withdrawalId" | "createdAt" | "updatedAt", ExtArgs["result"]["walletTransaction"]>

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      userId: string
      type: string
      amount: number
      status: string
      description: string | null
      mt5AccountId: string | null
      withdrawalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions and returns the data updated in the database.
     * @param {WalletTransactionUpdateManyAndReturnArgs} args - Arguments to update many WalletTransactions.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly walletId: FieldRef<"WalletTransaction", 'String'>
    readonly userId: FieldRef<"WalletTransaction", 'String'>
    readonly type: FieldRef<"WalletTransaction", 'String'>
    readonly amount: FieldRef<"WalletTransaction", 'Float'>
    readonly status: FieldRef<"WalletTransaction", 'String'>
    readonly description: FieldRef<"WalletTransaction", 'String'>
    readonly mt5AccountId: FieldRef<"WalletTransaction", 'String'>
    readonly withdrawalId: FieldRef<"WalletTransaction", 'String'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction updateManyAndReturn
   */
  export type WalletTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adminId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: string | null
    newValues: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adminId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: string | null
    newValues: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    adminId: number
    action: number
    entity: number
    entityId: number
    ipAddress: number
    userAgent: number
    oldValues: number
    newValues: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    oldValues?: true
    newValues?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string | null
    adminId: string
    action: string
    entity: string
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValues: string | null
    newValues: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    adminId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValues?: boolean
    newValues?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adminId" | "action" | "entity" | "entityId" | "ipAddress" | "userAgent" | "oldValues" | "newValues" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      adminId: string
      action: string
      entity: string
      entityId: string | null
      ipAddress: string | null
      userAgent: string | null
      oldValues: string | null
      newValues: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly adminId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly entity: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly oldValues: FieldRef<"ActivityLog", 'String'>
    readonly newValues: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    permissions: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    permissions: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    permissions: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    permissions?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    permissions: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    permissions?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "permissions" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      permissions: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    currency: string | null
    network: string | null
    status: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    methodType: string | null
    bankName: string | null
    accountName: string | null
    accountNumber: string | null
    ifscSwiftCode: string | null
    accountType: string | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    currency: string | null
    network: string | null
    status: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    methodType: string | null
    bankName: string | null
    accountName: string | null
    accountNumber: string | null
    ifscSwiftCode: string | null
    accountType: string | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    userId: number
    address: number
    currency: number
    network: number
    status: number
    submittedAt: number
    approvedAt: number
    approvedBy: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    methodType: number
    bankName: number
    accountName: number
    accountNumber: number
    ifscSwiftCode: number
    accountType: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    currency?: true
    network?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    approvedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    methodType?: true
    bankName?: true
    accountName?: true
    accountNumber?: true
    ifscSwiftCode?: true
    accountType?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    currency?: true
    network?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    approvedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    methodType?: true
    bankName?: true
    accountName?: true
    accountNumber?: true
    ifscSwiftCode?: true
    accountType?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    currency?: true
    network?: true
    status?: true
    submittedAt?: true
    approvedAt?: true
    approvedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    methodType?: true
    bankName?: true
    accountName?: true
    accountNumber?: true
    ifscSwiftCode?: true
    accountType?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    userId: string
    address: string | null
    currency: string
    network: string
    status: string
    submittedAt: Date
    approvedAt: Date | null
    approvedBy: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    methodType: string
    bankName: string | null
    accountName: string | null
    accountNumber: string | null
    ifscSwiftCode: string | null
    accountType: string | null
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    methodType?: boolean
    bankName?: boolean
    accountName?: boolean
    accountNumber?: boolean
    ifscSwiftCode?: boolean
    accountType?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    methodType?: boolean
    bankName?: boolean
    accountName?: boolean
    accountNumber?: boolean
    ifscSwiftCode?: boolean
    accountType?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    methodType?: boolean
    bankName?: boolean
    accountName?: boolean
    accountNumber?: boolean
    ifscSwiftCode?: boolean
    accountType?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    userId?: boolean
    address?: boolean
    currency?: boolean
    network?: boolean
    status?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    methodType?: boolean
    bankName?: boolean
    accountName?: boolean
    accountNumber?: boolean
    ifscSwiftCode?: boolean
    accountType?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "address" | "currency" | "network" | "status" | "submittedAt" | "approvedAt" | "approvedBy" | "rejectionReason" | "createdAt" | "updatedAt" | "methodType" | "bankName" | "accountName" | "accountNumber" | "ifscSwiftCode" | "accountType", ExtArgs["result"]["paymentMethod"]>

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      address: string | null
      currency: string
      network: string
      status: string
      submittedAt: Date
      approvedAt: Date | null
      approvedBy: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
      methodType: string
      bankName: string | null
      accountName: string | null
      accountNumber: string | null
      ifscSwiftCode: string | null
      accountType: string | null
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly userId: FieldRef<"PaymentMethod", 'String'>
    readonly address: FieldRef<"PaymentMethod", 'String'>
    readonly currency: FieldRef<"PaymentMethod", 'String'>
    readonly network: FieldRef<"PaymentMethod", 'String'>
    readonly status: FieldRef<"PaymentMethod", 'String'>
    readonly submittedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly approvedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly approvedBy: FieldRef<"PaymentMethod", 'String'>
    readonly rejectionReason: FieldRef<"PaymentMethod", 'String'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly methodType: FieldRef<"PaymentMethod", 'String'>
    readonly bankName: FieldRef<"PaymentMethod", 'String'>
    readonly accountName: FieldRef<"PaymentMethod", 'String'>
    readonly accountNumber: FieldRef<"PaymentMethod", 'String'>
    readonly ifscSwiftCode: FieldRef<"PaymentMethod", 'String'>
    readonly accountType: FieldRef<"PaymentMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    assignedAt: Date
    assignedBy: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "assignedAt" | "assignedBy", ExtArgs["result"]["userRole"]>

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      assignedAt: Date
      assignedBy: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly assignedBy: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
  }


  /**
   * Model DefaultMT5Account
   */

  export type AggregateDefaultMT5Account = {
    _count: DefaultMT5AccountCountAggregateOutputType | null
    _min: DefaultMT5AccountMinAggregateOutputType | null
    _max: DefaultMT5AccountMaxAggregateOutputType | null
  }

  export type DefaultMT5AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultMT5AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mt5AccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DefaultMT5AccountCountAggregateOutputType = {
    id: number
    userId: number
    mt5AccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DefaultMT5AccountMinAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultMT5AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DefaultMT5AccountCountAggregateInputType = {
    id?: true
    userId?: true
    mt5AccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DefaultMT5AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultMT5Account to aggregate.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefaultMT5Accounts
    **/
    _count?: true | DefaultMT5AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefaultMT5AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefaultMT5AccountMaxAggregateInputType
  }

  export type GetDefaultMT5AccountAggregateType<T extends DefaultMT5AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateDefaultMT5Account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefaultMT5Account[P]>
      : GetScalarType<T[P], AggregateDefaultMT5Account[P]>
  }




  export type DefaultMT5AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultMT5AccountWhereInput
    orderBy?: DefaultMT5AccountOrderByWithAggregationInput | DefaultMT5AccountOrderByWithAggregationInput[]
    by: DefaultMT5AccountScalarFieldEnum[] | DefaultMT5AccountScalarFieldEnum
    having?: DefaultMT5AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefaultMT5AccountCountAggregateInputType | true
    _min?: DefaultMT5AccountMinAggregateInputType
    _max?: DefaultMT5AccountMaxAggregateInputType
  }

  export type DefaultMT5AccountGroupByOutputType = {
    id: string
    userId: string
    mt5AccountId: string
    createdAt: Date
    updatedAt: Date
    _count: DefaultMT5AccountCountAggregateOutputType | null
    _min: DefaultMT5AccountMinAggregateOutputType | null
    _max: DefaultMT5AccountMaxAggregateOutputType | null
  }

  type GetDefaultMT5AccountGroupByPayload<T extends DefaultMT5AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefaultMT5AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefaultMT5AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefaultMT5AccountGroupByOutputType[P]>
            : GetScalarType<T[P], DefaultMT5AccountGroupByOutputType[P]>
        }
      >
    >


  export type DefaultMT5AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultMT5Account"]>

  export type DefaultMT5AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultMT5Account"]>

  export type DefaultMT5AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["defaultMT5Account"]>

  export type DefaultMT5AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    mt5AccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DefaultMT5AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mt5AccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["defaultMT5Account"]>
  export type DefaultMT5AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DefaultMT5AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DefaultMT5AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MT5Account?: boolean | MT5AccountDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DefaultMT5AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefaultMT5Account"
    objects: {
      MT5Account: Prisma.$MT5AccountPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mt5AccountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["defaultMT5Account"]>
    composites: {}
  }

  type DefaultMT5AccountGetPayload<S extends boolean | null | undefined | DefaultMT5AccountDefaultArgs> = $Result.GetResult<Prisma.$DefaultMT5AccountPayload, S>

  type DefaultMT5AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DefaultMT5AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DefaultMT5AccountCountAggregateInputType | true
    }

  export interface DefaultMT5AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefaultMT5Account'], meta: { name: 'DefaultMT5Account' } }
    /**
     * Find zero or one DefaultMT5Account that matches the filter.
     * @param {DefaultMT5AccountFindUniqueArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DefaultMT5AccountFindUniqueArgs>(args: SelectSubset<T, DefaultMT5AccountFindUniqueArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DefaultMT5Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DefaultMT5AccountFindUniqueOrThrowArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DefaultMT5AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, DefaultMT5AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultMT5Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountFindFirstArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DefaultMT5AccountFindFirstArgs>(args?: SelectSubset<T, DefaultMT5AccountFindFirstArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DefaultMT5Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountFindFirstOrThrowArgs} args - Arguments to find a DefaultMT5Account
     * @example
     * // Get one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DefaultMT5AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, DefaultMT5AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DefaultMT5Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefaultMT5Accounts
     * const defaultMT5Accounts = await prisma.defaultMT5Account.findMany()
     * 
     * // Get first 10 DefaultMT5Accounts
     * const defaultMT5Accounts = await prisma.defaultMT5Account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defaultMT5AccountWithIdOnly = await prisma.defaultMT5Account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DefaultMT5AccountFindManyArgs>(args?: SelectSubset<T, DefaultMT5AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DefaultMT5Account.
     * @param {DefaultMT5AccountCreateArgs} args - Arguments to create a DefaultMT5Account.
     * @example
     * // Create one DefaultMT5Account
     * const DefaultMT5Account = await prisma.defaultMT5Account.create({
     *   data: {
     *     // ... data to create a DefaultMT5Account
     *   }
     * })
     * 
     */
    create<T extends DefaultMT5AccountCreateArgs>(args: SelectSubset<T, DefaultMT5AccountCreateArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DefaultMT5Accounts.
     * @param {DefaultMT5AccountCreateManyArgs} args - Arguments to create many DefaultMT5Accounts.
     * @example
     * // Create many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DefaultMT5AccountCreateManyArgs>(args?: SelectSubset<T, DefaultMT5AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DefaultMT5Accounts and returns the data saved in the database.
     * @param {DefaultMT5AccountCreateManyAndReturnArgs} args - Arguments to create many DefaultMT5Accounts.
     * @example
     * // Create many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DefaultMT5Accounts and only return the `id`
     * const defaultMT5AccountWithIdOnly = await prisma.defaultMT5Account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DefaultMT5AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, DefaultMT5AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DefaultMT5Account.
     * @param {DefaultMT5AccountDeleteArgs} args - Arguments to delete one DefaultMT5Account.
     * @example
     * // Delete one DefaultMT5Account
     * const DefaultMT5Account = await prisma.defaultMT5Account.delete({
     *   where: {
     *     // ... filter to delete one DefaultMT5Account
     *   }
     * })
     * 
     */
    delete<T extends DefaultMT5AccountDeleteArgs>(args: SelectSubset<T, DefaultMT5AccountDeleteArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DefaultMT5Account.
     * @param {DefaultMT5AccountUpdateArgs} args - Arguments to update one DefaultMT5Account.
     * @example
     * // Update one DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DefaultMT5AccountUpdateArgs>(args: SelectSubset<T, DefaultMT5AccountUpdateArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DefaultMT5Accounts.
     * @param {DefaultMT5AccountDeleteManyArgs} args - Arguments to filter DefaultMT5Accounts to delete.
     * @example
     * // Delete a few DefaultMT5Accounts
     * const { count } = await prisma.defaultMT5Account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DefaultMT5AccountDeleteManyArgs>(args?: SelectSubset<T, DefaultMT5AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultMT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DefaultMT5AccountUpdateManyArgs>(args: SelectSubset<T, DefaultMT5AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultMT5Accounts and returns the data updated in the database.
     * @param {DefaultMT5AccountUpdateManyAndReturnArgs} args - Arguments to update many DefaultMT5Accounts.
     * @example
     * // Update many DefaultMT5Accounts
     * const defaultMT5Account = await prisma.defaultMT5Account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DefaultMT5Accounts and only return the `id`
     * const defaultMT5AccountWithIdOnly = await prisma.defaultMT5Account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DefaultMT5AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, DefaultMT5AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DefaultMT5Account.
     * @param {DefaultMT5AccountUpsertArgs} args - Arguments to update or create a DefaultMT5Account.
     * @example
     * // Update or create a DefaultMT5Account
     * const defaultMT5Account = await prisma.defaultMT5Account.upsert({
     *   create: {
     *     // ... data to create a DefaultMT5Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefaultMT5Account we want to update
     *   }
     * })
     */
    upsert<T extends DefaultMT5AccountUpsertArgs>(args: SelectSubset<T, DefaultMT5AccountUpsertArgs<ExtArgs>>): Prisma__DefaultMT5AccountClient<$Result.GetResult<Prisma.$DefaultMT5AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DefaultMT5Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountCountArgs} args - Arguments to filter DefaultMT5Accounts to count.
     * @example
     * // Count the number of DefaultMT5Accounts
     * const count = await prisma.defaultMT5Account.count({
     *   where: {
     *     // ... the filter for the DefaultMT5Accounts we want to count
     *   }
     * })
    **/
    count<T extends DefaultMT5AccountCountArgs>(
      args?: Subset<T, DefaultMT5AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefaultMT5AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefaultMT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefaultMT5AccountAggregateArgs>(args: Subset<T, DefaultMT5AccountAggregateArgs>): Prisma.PrismaPromise<GetDefaultMT5AccountAggregateType<T>>

    /**
     * Group by DefaultMT5Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultMT5AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefaultMT5AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefaultMT5AccountGroupByArgs['orderBy'] }
        : { orderBy?: DefaultMT5AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefaultMT5AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefaultMT5AccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefaultMT5Account model
   */
  readonly fields: DefaultMT5AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefaultMT5Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefaultMT5AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MT5Account<T extends MT5AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MT5AccountDefaultArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DefaultMT5Account model
   */
  interface DefaultMT5AccountFieldRefs {
    readonly id: FieldRef<"DefaultMT5Account", 'String'>
    readonly userId: FieldRef<"DefaultMT5Account", 'String'>
    readonly mt5AccountId: FieldRef<"DefaultMT5Account", 'String'>
    readonly createdAt: FieldRef<"DefaultMT5Account", 'DateTime'>
    readonly updatedAt: FieldRef<"DefaultMT5Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DefaultMT5Account findUnique
   */
  export type DefaultMT5AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account findUniqueOrThrow
   */
  export type DefaultMT5AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account findFirst
   */
  export type DefaultMT5AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultMT5Accounts.
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultMT5Accounts.
     */
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * DefaultMT5Account findFirstOrThrow
   */
  export type DefaultMT5AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Account to fetch.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultMT5Accounts.
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultMT5Accounts.
     */
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * DefaultMT5Account findMany
   */
  export type DefaultMT5AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter, which DefaultMT5Accounts to fetch.
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultMT5Accounts to fetch.
     */
    orderBy?: DefaultMT5AccountOrderByWithRelationInput | DefaultMT5AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefaultMT5Accounts.
     */
    cursor?: DefaultMT5AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultMT5Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultMT5Accounts.
     */
    skip?: number
    distinct?: DefaultMT5AccountScalarFieldEnum | DefaultMT5AccountScalarFieldEnum[]
  }

  /**
   * DefaultMT5Account create
   */
  export type DefaultMT5AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a DefaultMT5Account.
     */
    data: XOR<DefaultMT5AccountCreateInput, DefaultMT5AccountUncheckedCreateInput>
  }

  /**
   * DefaultMT5Account createMany
   */
  export type DefaultMT5AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefaultMT5Accounts.
     */
    data: DefaultMT5AccountCreateManyInput | DefaultMT5AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DefaultMT5Account createManyAndReturn
   */
  export type DefaultMT5AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * The data used to create many DefaultMT5Accounts.
     */
    data: DefaultMT5AccountCreateManyInput | DefaultMT5AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefaultMT5Account update
   */
  export type DefaultMT5AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a DefaultMT5Account.
     */
    data: XOR<DefaultMT5AccountUpdateInput, DefaultMT5AccountUncheckedUpdateInput>
    /**
     * Choose, which DefaultMT5Account to update.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account updateMany
   */
  export type DefaultMT5AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefaultMT5Accounts.
     */
    data: XOR<DefaultMT5AccountUpdateManyMutationInput, DefaultMT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which DefaultMT5Accounts to update
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * Limit how many DefaultMT5Accounts to update.
     */
    limit?: number
  }

  /**
   * DefaultMT5Account updateManyAndReturn
   */
  export type DefaultMT5AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * The data used to update DefaultMT5Accounts.
     */
    data: XOR<DefaultMT5AccountUpdateManyMutationInput, DefaultMT5AccountUncheckedUpdateManyInput>
    /**
     * Filter which DefaultMT5Accounts to update
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * Limit how many DefaultMT5Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DefaultMT5Account upsert
   */
  export type DefaultMT5AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the DefaultMT5Account to update in case it exists.
     */
    where: DefaultMT5AccountWhereUniqueInput
    /**
     * In case the DefaultMT5Account found by the `where` argument doesn't exist, create a new DefaultMT5Account with this data.
     */
    create: XOR<DefaultMT5AccountCreateInput, DefaultMT5AccountUncheckedCreateInput>
    /**
     * In case the DefaultMT5Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefaultMT5AccountUpdateInput, DefaultMT5AccountUncheckedUpdateInput>
  }

  /**
   * DefaultMT5Account delete
   */
  export type DefaultMT5AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
    /**
     * Filter which DefaultMT5Account to delete.
     */
    where: DefaultMT5AccountWhereUniqueInput
  }

  /**
   * DefaultMT5Account deleteMany
   */
  export type DefaultMT5AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultMT5Accounts to delete
     */
    where?: DefaultMT5AccountWhereInput
    /**
     * Limit how many DefaultMT5Accounts to delete.
     */
    limit?: number
  }

  /**
   * DefaultMT5Account without action
   */
  export type DefaultMT5AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultMT5Account
     */
    select?: DefaultMT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DefaultMT5Account
     */
    omit?: DefaultMT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DefaultMT5AccountInclude<ExtArgs> | null
  }


  /**
   * Model Instrument
   */

  export type AggregateInstrument = {
    _count: InstrumentCountAggregateOutputType | null
    _avg: InstrumentAvgAggregateOutputType | null
    _sum: InstrumentSumAggregateOutputType | null
    _min: InstrumentMinAggregateOutputType | null
    _max: InstrumentMaxAggregateOutputType | null
  }

  export type InstrumentAvgAggregateOutputType = {
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
    sector: number | null
    industry: number | null
    point: number | null
    multiply: number | null
    tickSize: number | null
    tickValue: number | null
    volumeLimit: number | null
    marginInitial: number | null
    marginMaintenance: number | null
    tradeMode: number | null
    tradeFlags: number | null
    calcMode: number | null
    execMode: number | null
    swapLong: number | null
    swapShort: number | null
    swapMode: number | null
  }

  export type InstrumentSumAggregateOutputType = {
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
    sector: number | null
    industry: number | null
    point: number | null
    multiply: number | null
    tickSize: number | null
    tickValue: number | null
    volumeLimit: number | null
    marginInitial: number | null
    marginMaintenance: number | null
    tradeMode: number | null
    tradeFlags: number | null
    calcMode: number | null
    execMode: number | null
    swapLong: number | null
    swapShort: number | null
    swapMode: number | null
  }

  export type InstrumentMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    name: string | null
    description: string | null
    category: string | null
    group: string | null
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
    isActive: boolean | null
    tradingHours: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    path: string | null
    accountGroup: string | null
    isin: string | null
    sector: number | null
    industry: number | null
    country: string | null
    currency: string | null
    currencyProfit: string | null
    currencyMargin: string | null
    point: number | null
    multiply: number | null
    tickSize: number | null
    tickValue: number | null
    volumeLimit: number | null
    marginInitial: number | null
    marginMaintenance: number | null
    tradeMode: number | null
    tradeFlags: number | null
    calcMode: number | null
    execMode: number | null
    swapLong: number | null
    swapShort: number | null
    swapMode: number | null
  }

  export type InstrumentMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    name: string | null
    description: string | null
    category: string | null
    group: string | null
    digits: number | null
    contractSize: number | null
    minVolume: number | null
    maxVolume: number | null
    volumeStep: number | null
    spread: number | null
    isActive: boolean | null
    tradingHours: string | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    path: string | null
    accountGroup: string | null
    isin: string | null
    sector: number | null
    industry: number | null
    country: string | null
    currency: string | null
    currencyProfit: string | null
    currencyMargin: string | null
    point: number | null
    multiply: number | null
    tickSize: number | null
    tickValue: number | null
    volumeLimit: number | null
    marginInitial: number | null
    marginMaintenance: number | null
    tradeMode: number | null
    tradeFlags: number | null
    calcMode: number | null
    execMode: number | null
    swapLong: number | null
    swapShort: number | null
    swapMode: number | null
  }

  export type InstrumentCountAggregateOutputType = {
    id: number
    symbol: number
    name: number
    description: number
    category: number
    group: number
    digits: number
    contractSize: number
    minVolume: number
    maxVolume: number
    volumeStep: number
    spread: number
    isActive: number
    tradingHours: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    path: number
    accountGroup: number
    isin: number
    sector: number
    industry: number
    country: number
    currency: number
    currencyProfit: number
    currencyMargin: number
    point: number
    multiply: number
    tickSize: number
    tickValue: number
    volumeLimit: number
    marginInitial: number
    marginMaintenance: number
    tradeMode: number
    tradeFlags: number
    calcMode: number
    execMode: number
    swapLong: number
    swapShort: number
    swapMode: number
    _all: number
  }


  export type InstrumentAvgAggregateInputType = {
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    sector?: true
    industry?: true
    point?: true
    multiply?: true
    tickSize?: true
    tickValue?: true
    volumeLimit?: true
    marginInitial?: true
    marginMaintenance?: true
    tradeMode?: true
    tradeFlags?: true
    calcMode?: true
    execMode?: true
    swapLong?: true
    swapShort?: true
    swapMode?: true
  }

  export type InstrumentSumAggregateInputType = {
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    sector?: true
    industry?: true
    point?: true
    multiply?: true
    tickSize?: true
    tickValue?: true
    volumeLimit?: true
    marginInitial?: true
    marginMaintenance?: true
    tradeMode?: true
    tradeFlags?: true
    calcMode?: true
    execMode?: true
    swapLong?: true
    swapShort?: true
    swapMode?: true
  }

  export type InstrumentMinAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    description?: true
    category?: true
    group?: true
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    isActive?: true
    tradingHours?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    path?: true
    accountGroup?: true
    isin?: true
    sector?: true
    industry?: true
    country?: true
    currency?: true
    currencyProfit?: true
    currencyMargin?: true
    point?: true
    multiply?: true
    tickSize?: true
    tickValue?: true
    volumeLimit?: true
    marginInitial?: true
    marginMaintenance?: true
    tradeMode?: true
    tradeFlags?: true
    calcMode?: true
    execMode?: true
    swapLong?: true
    swapShort?: true
    swapMode?: true
  }

  export type InstrumentMaxAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    description?: true
    category?: true
    group?: true
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    isActive?: true
    tradingHours?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    path?: true
    accountGroup?: true
    isin?: true
    sector?: true
    industry?: true
    country?: true
    currency?: true
    currencyProfit?: true
    currencyMargin?: true
    point?: true
    multiply?: true
    tickSize?: true
    tickValue?: true
    volumeLimit?: true
    marginInitial?: true
    marginMaintenance?: true
    tradeMode?: true
    tradeFlags?: true
    calcMode?: true
    execMode?: true
    swapLong?: true
    swapShort?: true
    swapMode?: true
  }

  export type InstrumentCountAggregateInputType = {
    id?: true
    symbol?: true
    name?: true
    description?: true
    category?: true
    group?: true
    digits?: true
    contractSize?: true
    minVolume?: true
    maxVolume?: true
    volumeStep?: true
    spread?: true
    isActive?: true
    tradingHours?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    path?: true
    accountGroup?: true
    isin?: true
    sector?: true
    industry?: true
    country?: true
    currency?: true
    currencyProfit?: true
    currencyMargin?: true
    point?: true
    multiply?: true
    tickSize?: true
    tickValue?: true
    volumeLimit?: true
    marginInitial?: true
    marginMaintenance?: true
    tradeMode?: true
    tradeFlags?: true
    calcMode?: true
    execMode?: true
    swapLong?: true
    swapShort?: true
    swapMode?: true
    _all?: true
  }

  export type InstrumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instrument to aggregate.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instruments
    **/
    _count?: true | InstrumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstrumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstrumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstrumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstrumentMaxAggregateInputType
  }

  export type GetInstrumentAggregateType<T extends InstrumentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstrument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstrument[P]>
      : GetScalarType<T[P], AggregateInstrument[P]>
  }




  export type InstrumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstrumentWhereInput
    orderBy?: InstrumentOrderByWithAggregationInput | InstrumentOrderByWithAggregationInput[]
    by: InstrumentScalarFieldEnum[] | InstrumentScalarFieldEnum
    having?: InstrumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstrumentCountAggregateInputType | true
    _avg?: InstrumentAvgAggregateInputType
    _sum?: InstrumentSumAggregateInputType
    _min?: InstrumentMinAggregateInputType
    _max?: InstrumentMaxAggregateInputType
  }

  export type InstrumentGroupByOutputType = {
    id: string
    symbol: string
    name: string | null
    description: string | null
    category: string
    group: string | null
    digits: number
    contractSize: number
    minVolume: number
    maxVolume: number
    volumeStep: number
    spread: number
    isActive: boolean
    tradingHours: string | null
    lastUpdated: Date
    createdAt: Date
    updatedAt: Date
    path: string | null
    accountGroup: string | null
    isin: string | null
    sector: number | null
    industry: number | null
    country: string | null
    currency: string | null
    currencyProfit: string | null
    currencyMargin: string | null
    point: number | null
    multiply: number | null
    tickSize: number | null
    tickValue: number | null
    volumeLimit: number | null
    marginInitial: number | null
    marginMaintenance: number | null
    tradeMode: number | null
    tradeFlags: number | null
    calcMode: number | null
    execMode: number | null
    swapLong: number | null
    swapShort: number | null
    swapMode: number | null
    _count: InstrumentCountAggregateOutputType | null
    _avg: InstrumentAvgAggregateOutputType | null
    _sum: InstrumentSumAggregateOutputType | null
    _min: InstrumentMinAggregateOutputType | null
    _max: InstrumentMaxAggregateOutputType | null
  }

  type GetInstrumentGroupByPayload<T extends InstrumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstrumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstrumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstrumentGroupByOutputType[P]>
            : GetScalarType<T[P], InstrumentGroupByOutputType[P]>
        }
      >
    >


  export type InstrumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    path?: boolean
    accountGroup?: boolean
    isin?: boolean
    sector?: boolean
    industry?: boolean
    country?: boolean
    currency?: boolean
    currencyProfit?: boolean
    currencyMargin?: boolean
    point?: boolean
    multiply?: boolean
    tickSize?: boolean
    tickValue?: boolean
    volumeLimit?: boolean
    marginInitial?: boolean
    marginMaintenance?: boolean
    tradeMode?: boolean
    tradeFlags?: boolean
    calcMode?: boolean
    execMode?: boolean
    swapLong?: boolean
    swapShort?: boolean
    swapMode?: boolean
    UserFavorite?: boolean | Instrument$UserFavoriteArgs<ExtArgs>
    _count?: boolean | InstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instrument"]>

  export type InstrumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    path?: boolean
    accountGroup?: boolean
    isin?: boolean
    sector?: boolean
    industry?: boolean
    country?: boolean
    currency?: boolean
    currencyProfit?: boolean
    currencyMargin?: boolean
    point?: boolean
    multiply?: boolean
    tickSize?: boolean
    tickValue?: boolean
    volumeLimit?: boolean
    marginInitial?: boolean
    marginMaintenance?: boolean
    tradeMode?: boolean
    tradeFlags?: boolean
    calcMode?: boolean
    execMode?: boolean
    swapLong?: boolean
    swapShort?: boolean
    swapMode?: boolean
  }, ExtArgs["result"]["instrument"]>

  export type InstrumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    path?: boolean
    accountGroup?: boolean
    isin?: boolean
    sector?: boolean
    industry?: boolean
    country?: boolean
    currency?: boolean
    currencyProfit?: boolean
    currencyMargin?: boolean
    point?: boolean
    multiply?: boolean
    tickSize?: boolean
    tickValue?: boolean
    volumeLimit?: boolean
    marginInitial?: boolean
    marginMaintenance?: boolean
    tradeMode?: boolean
    tradeFlags?: boolean
    calcMode?: boolean
    execMode?: boolean
    swapLong?: boolean
    swapShort?: boolean
    swapMode?: boolean
  }, ExtArgs["result"]["instrument"]>

  export type InstrumentSelectScalar = {
    id?: boolean
    symbol?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    group?: boolean
    digits?: boolean
    contractSize?: boolean
    minVolume?: boolean
    maxVolume?: boolean
    volumeStep?: boolean
    spread?: boolean
    isActive?: boolean
    tradingHours?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    path?: boolean
    accountGroup?: boolean
    isin?: boolean
    sector?: boolean
    industry?: boolean
    country?: boolean
    currency?: boolean
    currencyProfit?: boolean
    currencyMargin?: boolean
    point?: boolean
    multiply?: boolean
    tickSize?: boolean
    tickValue?: boolean
    volumeLimit?: boolean
    marginInitial?: boolean
    marginMaintenance?: boolean
    tradeMode?: boolean
    tradeFlags?: boolean
    calcMode?: boolean
    execMode?: boolean
    swapLong?: boolean
    swapShort?: boolean
    swapMode?: boolean
  }

  export type InstrumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "name" | "description" | "category" | "group" | "digits" | "contractSize" | "minVolume" | "maxVolume" | "volumeStep" | "spread" | "isActive" | "tradingHours" | "lastUpdated" | "createdAt" | "updatedAt" | "path" | "accountGroup" | "isin" | "sector" | "industry" | "country" | "currency" | "currencyProfit" | "currencyMargin" | "point" | "multiply" | "tickSize" | "tickValue" | "volumeLimit" | "marginInitial" | "marginMaintenance" | "tradeMode" | "tradeFlags" | "calcMode" | "execMode" | "swapLong" | "swapShort" | "swapMode", ExtArgs["result"]["instrument"]>
  export type InstrumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserFavorite?: boolean | Instrument$UserFavoriteArgs<ExtArgs>
    _count?: boolean | InstrumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstrumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InstrumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InstrumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instrument"
    objects: {
      UserFavorite: Prisma.$UserFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      name: string | null
      description: string | null
      category: string
      group: string | null
      digits: number
      contractSize: number
      minVolume: number
      maxVolume: number
      volumeStep: number
      spread: number
      isActive: boolean
      tradingHours: string | null
      lastUpdated: Date
      createdAt: Date
      updatedAt: Date
      path: string | null
      accountGroup: string | null
      isin: string | null
      sector: number | null
      industry: number | null
      country: string | null
      currency: string | null
      currencyProfit: string | null
      currencyMargin: string | null
      point: number | null
      multiply: number | null
      tickSize: number | null
      tickValue: number | null
      volumeLimit: number | null
      marginInitial: number | null
      marginMaintenance: number | null
      tradeMode: number | null
      tradeFlags: number | null
      calcMode: number | null
      execMode: number | null
      swapLong: number | null
      swapShort: number | null
      swapMode: number | null
    }, ExtArgs["result"]["instrument"]>
    composites: {}
  }

  type InstrumentGetPayload<S extends boolean | null | undefined | InstrumentDefaultArgs> = $Result.GetResult<Prisma.$InstrumentPayload, S>

  type InstrumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstrumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstrumentCountAggregateInputType | true
    }

  export interface InstrumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instrument'], meta: { name: 'Instrument' } }
    /**
     * Find zero or one Instrument that matches the filter.
     * @param {InstrumentFindUniqueArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstrumentFindUniqueArgs>(args: SelectSubset<T, InstrumentFindUniqueArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instrument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstrumentFindUniqueOrThrowArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstrumentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstrumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instrument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentFindFirstArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstrumentFindFirstArgs>(args?: SelectSubset<T, InstrumentFindFirstArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instrument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentFindFirstOrThrowArgs} args - Arguments to find a Instrument
     * @example
     * // Get one Instrument
     * const instrument = await prisma.instrument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstrumentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstrumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instruments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instruments
     * const instruments = await prisma.instrument.findMany()
     * 
     * // Get first 10 Instruments
     * const instruments = await prisma.instrument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instrumentWithIdOnly = await prisma.instrument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstrumentFindManyArgs>(args?: SelectSubset<T, InstrumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instrument.
     * @param {InstrumentCreateArgs} args - Arguments to create a Instrument.
     * @example
     * // Create one Instrument
     * const Instrument = await prisma.instrument.create({
     *   data: {
     *     // ... data to create a Instrument
     *   }
     * })
     * 
     */
    create<T extends InstrumentCreateArgs>(args: SelectSubset<T, InstrumentCreateArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instruments.
     * @param {InstrumentCreateManyArgs} args - Arguments to create many Instruments.
     * @example
     * // Create many Instruments
     * const instrument = await prisma.instrument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstrumentCreateManyArgs>(args?: SelectSubset<T, InstrumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instruments and returns the data saved in the database.
     * @param {InstrumentCreateManyAndReturnArgs} args - Arguments to create many Instruments.
     * @example
     * // Create many Instruments
     * const instrument = await prisma.instrument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instruments and only return the `id`
     * const instrumentWithIdOnly = await prisma.instrument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstrumentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstrumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instrument.
     * @param {InstrumentDeleteArgs} args - Arguments to delete one Instrument.
     * @example
     * // Delete one Instrument
     * const Instrument = await prisma.instrument.delete({
     *   where: {
     *     // ... filter to delete one Instrument
     *   }
     * })
     * 
     */
    delete<T extends InstrumentDeleteArgs>(args: SelectSubset<T, InstrumentDeleteArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instrument.
     * @param {InstrumentUpdateArgs} args - Arguments to update one Instrument.
     * @example
     * // Update one Instrument
     * const instrument = await prisma.instrument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstrumentUpdateArgs>(args: SelectSubset<T, InstrumentUpdateArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instruments.
     * @param {InstrumentDeleteManyArgs} args - Arguments to filter Instruments to delete.
     * @example
     * // Delete a few Instruments
     * const { count } = await prisma.instrument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstrumentDeleteManyArgs>(args?: SelectSubset<T, InstrumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instruments
     * const instrument = await prisma.instrument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstrumentUpdateManyArgs>(args: SelectSubset<T, InstrumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instruments and returns the data updated in the database.
     * @param {InstrumentUpdateManyAndReturnArgs} args - Arguments to update many Instruments.
     * @example
     * // Update many Instruments
     * const instrument = await prisma.instrument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instruments and only return the `id`
     * const instrumentWithIdOnly = await prisma.instrument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstrumentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstrumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instrument.
     * @param {InstrumentUpsertArgs} args - Arguments to update or create a Instrument.
     * @example
     * // Update or create a Instrument
     * const instrument = await prisma.instrument.upsert({
     *   create: {
     *     // ... data to create a Instrument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instrument we want to update
     *   }
     * })
     */
    upsert<T extends InstrumentUpsertArgs>(args: SelectSubset<T, InstrumentUpsertArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instruments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentCountArgs} args - Arguments to filter Instruments to count.
     * @example
     * // Count the number of Instruments
     * const count = await prisma.instrument.count({
     *   where: {
     *     // ... the filter for the Instruments we want to count
     *   }
     * })
    **/
    count<T extends InstrumentCountArgs>(
      args?: Subset<T, InstrumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstrumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstrumentAggregateArgs>(args: Subset<T, InstrumentAggregateArgs>): Prisma.PrismaPromise<GetInstrumentAggregateType<T>>

    /**
     * Group by Instrument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstrumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstrumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstrumentGroupByArgs['orderBy'] }
        : { orderBy?: InstrumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstrumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstrumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instrument model
   */
  readonly fields: InstrumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instrument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstrumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserFavorite<T extends Instrument$UserFavoriteArgs<ExtArgs> = {}>(args?: Subset<T, Instrument$UserFavoriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instrument model
   */
  interface InstrumentFieldRefs {
    readonly id: FieldRef<"Instrument", 'String'>
    readonly symbol: FieldRef<"Instrument", 'String'>
    readonly name: FieldRef<"Instrument", 'String'>
    readonly description: FieldRef<"Instrument", 'String'>
    readonly category: FieldRef<"Instrument", 'String'>
    readonly group: FieldRef<"Instrument", 'String'>
    readonly digits: FieldRef<"Instrument", 'Int'>
    readonly contractSize: FieldRef<"Instrument", 'Float'>
    readonly minVolume: FieldRef<"Instrument", 'Float'>
    readonly maxVolume: FieldRef<"Instrument", 'Float'>
    readonly volumeStep: FieldRef<"Instrument", 'Float'>
    readonly spread: FieldRef<"Instrument", 'Float'>
    readonly isActive: FieldRef<"Instrument", 'Boolean'>
    readonly tradingHours: FieldRef<"Instrument", 'String'>
    readonly lastUpdated: FieldRef<"Instrument", 'DateTime'>
    readonly createdAt: FieldRef<"Instrument", 'DateTime'>
    readonly updatedAt: FieldRef<"Instrument", 'DateTime'>
    readonly path: FieldRef<"Instrument", 'String'>
    readonly accountGroup: FieldRef<"Instrument", 'String'>
    readonly isin: FieldRef<"Instrument", 'String'>
    readonly sector: FieldRef<"Instrument", 'Int'>
    readonly industry: FieldRef<"Instrument", 'Int'>
    readonly country: FieldRef<"Instrument", 'String'>
    readonly currency: FieldRef<"Instrument", 'String'>
    readonly currencyProfit: FieldRef<"Instrument", 'String'>
    readonly currencyMargin: FieldRef<"Instrument", 'String'>
    readonly point: FieldRef<"Instrument", 'Float'>
    readonly multiply: FieldRef<"Instrument", 'Int'>
    readonly tickSize: FieldRef<"Instrument", 'Float'>
    readonly tickValue: FieldRef<"Instrument", 'Float'>
    readonly volumeLimit: FieldRef<"Instrument", 'Float'>
    readonly marginInitial: FieldRef<"Instrument", 'Float'>
    readonly marginMaintenance: FieldRef<"Instrument", 'Float'>
    readonly tradeMode: FieldRef<"Instrument", 'Int'>
    readonly tradeFlags: FieldRef<"Instrument", 'Int'>
    readonly calcMode: FieldRef<"Instrument", 'Int'>
    readonly execMode: FieldRef<"Instrument", 'Int'>
    readonly swapLong: FieldRef<"Instrument", 'Float'>
    readonly swapShort: FieldRef<"Instrument", 'Float'>
    readonly swapMode: FieldRef<"Instrument", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Instrument findUnique
   */
  export type InstrumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument findUniqueOrThrow
   */
  export type InstrumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument findFirst
   */
  export type InstrumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instruments.
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instruments.
     */
    distinct?: InstrumentScalarFieldEnum | InstrumentScalarFieldEnum[]
  }

  /**
   * Instrument findFirstOrThrow
   */
  export type InstrumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instrument to fetch.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instruments.
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instruments.
     */
    distinct?: InstrumentScalarFieldEnum | InstrumentScalarFieldEnum[]
  }

  /**
   * Instrument findMany
   */
  export type InstrumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter, which Instruments to fetch.
     */
    where?: InstrumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instruments to fetch.
     */
    orderBy?: InstrumentOrderByWithRelationInput | InstrumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instruments.
     */
    cursor?: InstrumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instruments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instruments.
     */
    skip?: number
    distinct?: InstrumentScalarFieldEnum | InstrumentScalarFieldEnum[]
  }

  /**
   * Instrument create
   */
  export type InstrumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Instrument.
     */
    data: XOR<InstrumentCreateInput, InstrumentUncheckedCreateInput>
  }

  /**
   * Instrument createMany
   */
  export type InstrumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instruments.
     */
    data: InstrumentCreateManyInput | InstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instrument createManyAndReturn
   */
  export type InstrumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * The data used to create many Instruments.
     */
    data: InstrumentCreateManyInput | InstrumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instrument update
   */
  export type InstrumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Instrument.
     */
    data: XOR<InstrumentUpdateInput, InstrumentUncheckedUpdateInput>
    /**
     * Choose, which Instrument to update.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument updateMany
   */
  export type InstrumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instruments.
     */
    data: XOR<InstrumentUpdateManyMutationInput, InstrumentUncheckedUpdateManyInput>
    /**
     * Filter which Instruments to update
     */
    where?: InstrumentWhereInput
    /**
     * Limit how many Instruments to update.
     */
    limit?: number
  }

  /**
   * Instrument updateManyAndReturn
   */
  export type InstrumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * The data used to update Instruments.
     */
    data: XOR<InstrumentUpdateManyMutationInput, InstrumentUncheckedUpdateManyInput>
    /**
     * Filter which Instruments to update
     */
    where?: InstrumentWhereInput
    /**
     * Limit how many Instruments to update.
     */
    limit?: number
  }

  /**
   * Instrument upsert
   */
  export type InstrumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Instrument to update in case it exists.
     */
    where: InstrumentWhereUniqueInput
    /**
     * In case the Instrument found by the `where` argument doesn't exist, create a new Instrument with this data.
     */
    create: XOR<InstrumentCreateInput, InstrumentUncheckedCreateInput>
    /**
     * In case the Instrument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstrumentUpdateInput, InstrumentUncheckedUpdateInput>
  }

  /**
   * Instrument delete
   */
  export type InstrumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
    /**
     * Filter which Instrument to delete.
     */
    where: InstrumentWhereUniqueInput
  }

  /**
   * Instrument deleteMany
   */
  export type InstrumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instruments to delete
     */
    where?: InstrumentWhereInput
    /**
     * Limit how many Instruments to delete.
     */
    limit?: number
  }

  /**
   * Instrument.UserFavorite
   */
  export type Instrument$UserFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * Instrument without action
   */
  export type InstrumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instrument
     */
    select?: InstrumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instrument
     */
    omit?: InstrumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstrumentInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revoked: boolean | null
    deviceName: string | null
    ipAddress: string | null
    userAgent: string | null
    lastActivity: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revoked: boolean | null
    deviceName: string | null
    ipAddress: string | null
    userAgent: string | null
    lastActivity: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    revoked: number
    deviceName: number
    ipAddress: number
    userAgent: number
    lastActivity: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revoked?: true
    deviceName?: true
    ipAddress?: true
    userAgent?: true
    lastActivity?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revoked?: true
    deviceName?: true
    ipAddress?: true
    userAgent?: true
    lastActivity?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    revoked?: true
    deviceName?: true
    ipAddress?: true
    userAgent?: true
    lastActivity?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date | null
    revoked: boolean | null
    deviceName: string | null
    ipAddress: string | null
    userAgent: string | null
    lastActivity: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    deviceName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastActivity?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    deviceName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastActivity?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    deviceName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastActivity?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revoked?: boolean
    deviceName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    lastActivity?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt" | "revoked" | "deviceName" | "ipAddress" | "userAgent" | "lastActivity", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date | null
      revoked: boolean | null
      deviceName: string | null
      ipAddress: string | null
      userAgent: string | null
      lastActivity: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly deviceName: FieldRef<"RefreshToken", 'String'>
    readonly ipAddress: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly lastActivity: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorite
   */

  export type AggregateUserFavorite = {
    _count: UserFavoriteCountAggregateOutputType | null
    _avg: UserFavoriteAvgAggregateOutputType | null
    _sum: UserFavoriteSumAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  export type UserFavoriteAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserFavoriteSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserFavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    instrumentId: string | null
    mt5AccountId: string | null
    sortOrder: number | null
    addedAt: Date | null
  }

  export type UserFavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    instrumentId: string | null
    mt5AccountId: string | null
    sortOrder: number | null
    addedAt: Date | null
  }

  export type UserFavoriteCountAggregateOutputType = {
    id: number
    userId: number
    instrumentId: number
    mt5AccountId: number
    sortOrder: number
    addedAt: number
    _all: number
  }


  export type UserFavoriteAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserFavoriteSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserFavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    instrumentId?: true
    mt5AccountId?: true
    sortOrder?: true
    addedAt?: true
  }

  export type UserFavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    instrumentId?: true
    mt5AccountId?: true
    sortOrder?: true
    addedAt?: true
  }

  export type UserFavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    instrumentId?: true
    mt5AccountId?: true
    sortOrder?: true
    addedAt?: true
    _all?: true
  }

  export type UserFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorite to aggregate.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorites
    **/
    _count?: true | UserFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type GetUserFavoriteAggregateType<T extends UserFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorite[P]>
      : GetScalarType<T[P], AggregateUserFavorite[P]>
  }




  export type UserFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithAggregationInput | UserFavoriteOrderByWithAggregationInput[]
    by: UserFavoriteScalarFieldEnum[] | UserFavoriteScalarFieldEnum
    having?: UserFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteCountAggregateInputType | true
    _avg?: UserFavoriteAvgAggregateInputType
    _sum?: UserFavoriteSumAggregateInputType
    _min?: UserFavoriteMinAggregateInputType
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type UserFavoriteGroupByOutputType = {
    id: string
    userId: string
    instrumentId: string
    mt5AccountId: string | null
    sortOrder: number
    addedAt: Date
    _count: UserFavoriteCountAggregateOutputType | null
    _avg: UserFavoriteAvgAggregateOutputType | null
    _sum: UserFavoriteSumAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  type GetUserFavoriteGroupByPayload<T extends UserFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    mt5AccountId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    MT5Account?: boolean | UserFavorite$MT5AccountArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    mt5AccountId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    MT5Account?: boolean | UserFavorite$MT5AccountArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    mt5AccountId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    MT5Account?: boolean | UserFavorite$MT5AccountArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    instrumentId?: boolean
    mt5AccountId?: boolean
    sortOrder?: boolean
    addedAt?: boolean
  }

  export type UserFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "instrumentId" | "mt5AccountId" | "sortOrder" | "addedAt", ExtArgs["result"]["userFavorite"]>
  export type UserFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    MT5Account?: boolean | UserFavorite$MT5AccountArgs<ExtArgs>
  }
  export type UserFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    MT5Account?: boolean | UserFavorite$MT5AccountArgs<ExtArgs>
  }
  export type UserFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instrument?: boolean | InstrumentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    MT5Account?: boolean | UserFavorite$MT5AccountArgs<ExtArgs>
  }

  export type $UserFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorite"
    objects: {
      Instrument: Prisma.$InstrumentPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      MT5Account: Prisma.$MT5AccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      instrumentId: string
      mt5AccountId: string | null
      sortOrder: number
      addedAt: Date
    }, ExtArgs["result"]["userFavorite"]>
    composites: {}
  }

  type UserFavoriteGetPayload<S extends boolean | null | undefined | UserFavoriteDefaultArgs> = $Result.GetResult<Prisma.$UserFavoritePayload, S>

  type UserFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteCountAggregateInputType | true
    }

  export interface UserFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorite'], meta: { name: 'UserFavorite' } }
    /**
     * Find zero or one UserFavorite that matches the filter.
     * @param {UserFavoriteFindUniqueArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteFindUniqueArgs>(args: SelectSubset<T, UserFavoriteFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteFindUniqueOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteFindFirstArgs>(args?: SelectSubset<T, UserFavoriteFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany()
     * 
     * // Get first 10 UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavoriteFindManyArgs>(args?: SelectSubset<T, UserFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorite.
     * @param {UserFavoriteCreateArgs} args - Arguments to create a UserFavorite.
     * @example
     * // Create one UserFavorite
     * const UserFavorite = await prisma.userFavorite.create({
     *   data: {
     *     // ... data to create a UserFavorite
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteCreateArgs>(args: SelectSubset<T, UserFavoriteCreateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorites.
     * @param {UserFavoriteCreateManyArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteCreateManyArgs>(args?: SelectSubset<T, UserFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavorites and returns the data saved in the database.
     * @param {UserFavoriteCreateManyAndReturnArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavorite.
     * @param {UserFavoriteDeleteArgs} args - Arguments to delete one UserFavorite.
     * @example
     * // Delete one UserFavorite
     * const UserFavorite = await prisma.userFavorite.delete({
     *   where: {
     *     // ... filter to delete one UserFavorite
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteDeleteArgs>(args: SelectSubset<T, UserFavoriteDeleteArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorite.
     * @param {UserFavoriteUpdateArgs} args - Arguments to update one UserFavorite.
     * @example
     * // Update one UserFavorite
     * const userFavorite = await prisma.userFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteUpdateArgs>(args: SelectSubset<T, UserFavoriteUpdateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorites.
     * @param {UserFavoriteDeleteManyArgs} args - Arguments to filter UserFavorites to delete.
     * @example
     * // Delete a few UserFavorites
     * const { count } = await prisma.userFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteUpdateManyArgs>(args: SelectSubset<T, UserFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites and returns the data updated in the database.
     * @param {UserFavoriteUpdateManyAndReturnArgs} args - Arguments to update many UserFavorites.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavorites and only return the `id`
     * const userFavoriteWithIdOnly = await prisma.userFavorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavorite.
     * @param {UserFavoriteUpsertArgs} args - Arguments to update or create a UserFavorite.
     * @example
     * // Update or create a UserFavorite
     * const userFavorite = await prisma.userFavorite.upsert({
     *   create: {
     *     // ... data to create a UserFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorite we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteUpsertArgs>(args: SelectSubset<T, UserFavoriteUpsertArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteCountArgs} args - Arguments to filter UserFavorites to count.
     * @example
     * // Count the number of UserFavorites
     * const count = await prisma.userFavorite.count({
     *   where: {
     *     // ... the filter for the UserFavorites we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteCountArgs>(
      args?: Subset<T, UserFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteAggregateArgs>(args: Subset<T, UserFavoriteAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteAggregateType<T>>

    /**
     * Group by UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorite model
   */
  readonly fields: UserFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instrument<T extends InstrumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstrumentDefaultArgs<ExtArgs>>): Prisma__InstrumentClient<$Result.GetResult<Prisma.$InstrumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MT5Account<T extends UserFavorite$MT5AccountArgs<ExtArgs> = {}>(args?: Subset<T, UserFavorite$MT5AccountArgs<ExtArgs>>): Prisma__MT5AccountClient<$Result.GetResult<Prisma.$MT5AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorite model
   */
  interface UserFavoriteFieldRefs {
    readonly id: FieldRef<"UserFavorite", 'String'>
    readonly userId: FieldRef<"UserFavorite", 'String'>
    readonly instrumentId: FieldRef<"UserFavorite", 'String'>
    readonly mt5AccountId: FieldRef<"UserFavorite", 'String'>
    readonly sortOrder: FieldRef<"UserFavorite", 'Int'>
    readonly addedAt: FieldRef<"UserFavorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorite findUnique
   */
  export type UserFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findUniqueOrThrow
   */
  export type UserFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findFirst
   */
  export type UserFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findFirstOrThrow
   */
  export type UserFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findMany
   */
  export type UserFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorites to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite create
   */
  export type UserFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorite.
     */
    data: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
  }

  /**
   * UserFavorite createMany
   */
  export type UserFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorite createManyAndReturn
   */
  export type UserFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite update
   */
  export type UserFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorite.
     */
    data: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
    /**
     * Choose, which UserFavorite to update.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite updateMany
   */
  export type UserFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
  }

  /**
   * UserFavorite updateManyAndReturn
   */
  export type UserFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite upsert
   */
  export type UserFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorite to update in case it exists.
     */
    where: UserFavoriteWhereUniqueInput
    /**
     * In case the UserFavorite found by the `where` argument doesn't exist, create a new UserFavorite with this data.
     */
    create: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
    /**
     * In case the UserFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
  }

  /**
   * UserFavorite delete
   */
  export type UserFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter which UserFavorite to delete.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite deleteMany
   */
  export type UserFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorites to delete
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to delete.
     */
    limit?: number
  }

  /**
   * UserFavorite.MT5Account
   */
  export type UserFavorite$MT5AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MT5Account
     */
    select?: MT5AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MT5Account
     */
    omit?: MT5AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MT5AccountInclude<ExtArgs> | null
    where?: MT5AccountWhereInput
  }

  /**
   * UserFavorite without action
   */
  export type UserFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model UserLoginLog
   */

  export type AggregateUserLoginLog = {
    _count: UserLoginLogCountAggregateOutputType | null
    _min: UserLoginLogMinAggregateOutputType | null
    _max: UserLoginLogMaxAggregateOutputType | null
  }

  export type UserLoginLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    user_agent: string | null
    device: string | null
    browser: string | null
    success: boolean | null
    failure_reason: string | null
    createdAt: Date | null
  }

  export type UserLoginLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    user_agent: string | null
    device: string | null
    browser: string | null
    success: boolean | null
    failure_reason: string | null
    createdAt: Date | null
  }

  export type UserLoginLogCountAggregateOutputType = {
    id: number
    userId: number
    user_agent: number
    device: number
    browser: number
    success: number
    failure_reason: number
    createdAt: number
    _all: number
  }


  export type UserLoginLogMinAggregateInputType = {
    id?: true
    userId?: true
    user_agent?: true
    device?: true
    browser?: true
    success?: true
    failure_reason?: true
    createdAt?: true
  }

  export type UserLoginLogMaxAggregateInputType = {
    id?: true
    userId?: true
    user_agent?: true
    device?: true
    browser?: true
    success?: true
    failure_reason?: true
    createdAt?: true
  }

  export type UserLoginLogCountAggregateInputType = {
    id?: true
    userId?: true
    user_agent?: true
    device?: true
    browser?: true
    success?: true
    failure_reason?: true
    createdAt?: true
    _all?: true
  }

  export type UserLoginLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLoginLog to aggregate.
     */
    where?: UserLoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginLogs to fetch.
     */
    orderBy?: UserLoginLogOrderByWithRelationInput | UserLoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLoginLogs
    **/
    _count?: true | UserLoginLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLoginLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLoginLogMaxAggregateInputType
  }

  export type GetUserLoginLogAggregateType<T extends UserLoginLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLoginLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLoginLog[P]>
      : GetScalarType<T[P], AggregateUserLoginLog[P]>
  }




  export type UserLoginLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginLogWhereInput
    orderBy?: UserLoginLogOrderByWithAggregationInput | UserLoginLogOrderByWithAggregationInput[]
    by: UserLoginLogScalarFieldEnum[] | UserLoginLogScalarFieldEnum
    having?: UserLoginLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLoginLogCountAggregateInputType | true
    _min?: UserLoginLogMinAggregateInputType
    _max?: UserLoginLogMaxAggregateInputType
  }

  export type UserLoginLogGroupByOutputType = {
    id: string
    userId: string
    user_agent: string | null
    device: string | null
    browser: string | null
    success: boolean
    failure_reason: string | null
    createdAt: Date
    _count: UserLoginLogCountAggregateOutputType | null
    _min: UserLoginLogMinAggregateOutputType | null
    _max: UserLoginLogMaxAggregateOutputType | null
  }

  type GetUserLoginLogGroupByPayload<T extends UserLoginLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLoginLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLoginLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLoginLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserLoginLogGroupByOutputType[P]>
        }
      >
    >


  export type UserLoginLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user_agent?: boolean
    device?: boolean
    browser?: boolean
    success?: boolean
    failure_reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginLog"]>

  export type UserLoginLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user_agent?: boolean
    device?: boolean
    browser?: boolean
    success?: boolean
    failure_reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginLog"]>

  export type UserLoginLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user_agent?: boolean
    device?: boolean
    browser?: boolean
    success?: boolean
    failure_reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginLog"]>

  export type UserLoginLogSelectScalar = {
    id?: boolean
    userId?: boolean
    user_agent?: boolean
    device?: boolean
    browser?: boolean
    success?: boolean
    failure_reason?: boolean
    createdAt?: boolean
  }

  export type UserLoginLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "user_agent" | "device" | "browser" | "success" | "failure_reason" | "createdAt", ExtArgs["result"]["userLoginLog"]>
  export type UserLoginLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLoginLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLoginLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      user_agent: string | null
      device: string | null
      browser: string | null
      success: boolean
      failure_reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["userLoginLog"]>
    composites: {}
  }

  type UserLoginLogGetPayload<S extends boolean | null | undefined | UserLoginLogDefaultArgs> = $Result.GetResult<Prisma.$UserLoginLogPayload, S>

  type UserLoginLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLoginLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLoginLogCountAggregateInputType | true
    }

  export interface UserLoginLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLoginLog'], meta: { name: 'UserLoginLog' } }
    /**
     * Find zero or one UserLoginLog that matches the filter.
     * @param {UserLoginLogFindUniqueArgs} args - Arguments to find a UserLoginLog
     * @example
     * // Get one UserLoginLog
     * const userLoginLog = await prisma.userLoginLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLoginLogFindUniqueArgs>(args: SelectSubset<T, UserLoginLogFindUniqueArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLoginLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLoginLogFindUniqueOrThrowArgs} args - Arguments to find a UserLoginLog
     * @example
     * // Get one UserLoginLog
     * const userLoginLog = await prisma.userLoginLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLoginLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLoginLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLoginLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogFindFirstArgs} args - Arguments to find a UserLoginLog
     * @example
     * // Get one UserLoginLog
     * const userLoginLog = await prisma.userLoginLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLoginLogFindFirstArgs>(args?: SelectSubset<T, UserLoginLogFindFirstArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLoginLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogFindFirstOrThrowArgs} args - Arguments to find a UserLoginLog
     * @example
     * // Get one UserLoginLog
     * const userLoginLog = await prisma.userLoginLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLoginLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLoginLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLoginLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLoginLogs
     * const userLoginLogs = await prisma.userLoginLog.findMany()
     * 
     * // Get first 10 UserLoginLogs
     * const userLoginLogs = await prisma.userLoginLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLoginLogWithIdOnly = await prisma.userLoginLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLoginLogFindManyArgs>(args?: SelectSubset<T, UserLoginLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLoginLog.
     * @param {UserLoginLogCreateArgs} args - Arguments to create a UserLoginLog.
     * @example
     * // Create one UserLoginLog
     * const UserLoginLog = await prisma.userLoginLog.create({
     *   data: {
     *     // ... data to create a UserLoginLog
     *   }
     * })
     * 
     */
    create<T extends UserLoginLogCreateArgs>(args: SelectSubset<T, UserLoginLogCreateArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLoginLogs.
     * @param {UserLoginLogCreateManyArgs} args - Arguments to create many UserLoginLogs.
     * @example
     * // Create many UserLoginLogs
     * const userLoginLog = await prisma.userLoginLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLoginLogCreateManyArgs>(args?: SelectSubset<T, UserLoginLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLoginLogs and returns the data saved in the database.
     * @param {UserLoginLogCreateManyAndReturnArgs} args - Arguments to create many UserLoginLogs.
     * @example
     * // Create many UserLoginLogs
     * const userLoginLog = await prisma.userLoginLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLoginLogs and only return the `id`
     * const userLoginLogWithIdOnly = await prisma.userLoginLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLoginLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLoginLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLoginLog.
     * @param {UserLoginLogDeleteArgs} args - Arguments to delete one UserLoginLog.
     * @example
     * // Delete one UserLoginLog
     * const UserLoginLog = await prisma.userLoginLog.delete({
     *   where: {
     *     // ... filter to delete one UserLoginLog
     *   }
     * })
     * 
     */
    delete<T extends UserLoginLogDeleteArgs>(args: SelectSubset<T, UserLoginLogDeleteArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLoginLog.
     * @param {UserLoginLogUpdateArgs} args - Arguments to update one UserLoginLog.
     * @example
     * // Update one UserLoginLog
     * const userLoginLog = await prisma.userLoginLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLoginLogUpdateArgs>(args: SelectSubset<T, UserLoginLogUpdateArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLoginLogs.
     * @param {UserLoginLogDeleteManyArgs} args - Arguments to filter UserLoginLogs to delete.
     * @example
     * // Delete a few UserLoginLogs
     * const { count } = await prisma.userLoginLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLoginLogDeleteManyArgs>(args?: SelectSubset<T, UserLoginLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLoginLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLoginLogs
     * const userLoginLog = await prisma.userLoginLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLoginLogUpdateManyArgs>(args: SelectSubset<T, UserLoginLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLoginLogs and returns the data updated in the database.
     * @param {UserLoginLogUpdateManyAndReturnArgs} args - Arguments to update many UserLoginLogs.
     * @example
     * // Update many UserLoginLogs
     * const userLoginLog = await prisma.userLoginLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLoginLogs and only return the `id`
     * const userLoginLogWithIdOnly = await prisma.userLoginLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLoginLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLoginLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLoginLog.
     * @param {UserLoginLogUpsertArgs} args - Arguments to update or create a UserLoginLog.
     * @example
     * // Update or create a UserLoginLog
     * const userLoginLog = await prisma.userLoginLog.upsert({
     *   create: {
     *     // ... data to create a UserLoginLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLoginLog we want to update
     *   }
     * })
     */
    upsert<T extends UserLoginLogUpsertArgs>(args: SelectSubset<T, UserLoginLogUpsertArgs<ExtArgs>>): Prisma__UserLoginLogClient<$Result.GetResult<Prisma.$UserLoginLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLoginLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogCountArgs} args - Arguments to filter UserLoginLogs to count.
     * @example
     * // Count the number of UserLoginLogs
     * const count = await prisma.userLoginLog.count({
     *   where: {
     *     // ... the filter for the UserLoginLogs we want to count
     *   }
     * })
    **/
    count<T extends UserLoginLogCountArgs>(
      args?: Subset<T, UserLoginLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLoginLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLoginLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLoginLogAggregateArgs>(args: Subset<T, UserLoginLogAggregateArgs>): Prisma.PrismaPromise<GetUserLoginLogAggregateType<T>>

    /**
     * Group by UserLoginLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLoginLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLoginLogGroupByArgs['orderBy'] }
        : { orderBy?: UserLoginLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLoginLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLoginLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLoginLog model
   */
  readonly fields: UserLoginLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLoginLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLoginLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLoginLog model
   */
  interface UserLoginLogFieldRefs {
    readonly id: FieldRef<"UserLoginLog", 'String'>
    readonly userId: FieldRef<"UserLoginLog", 'String'>
    readonly user_agent: FieldRef<"UserLoginLog", 'String'>
    readonly device: FieldRef<"UserLoginLog", 'String'>
    readonly browser: FieldRef<"UserLoginLog", 'String'>
    readonly success: FieldRef<"UserLoginLog", 'Boolean'>
    readonly failure_reason: FieldRef<"UserLoginLog", 'String'>
    readonly createdAt: FieldRef<"UserLoginLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLoginLog findUnique
   */
  export type UserLoginLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginLog to fetch.
     */
    where: UserLoginLogWhereUniqueInput
  }

  /**
   * UserLoginLog findUniqueOrThrow
   */
  export type UserLoginLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginLog to fetch.
     */
    where: UserLoginLogWhereUniqueInput
  }

  /**
   * UserLoginLog findFirst
   */
  export type UserLoginLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginLog to fetch.
     */
    where?: UserLoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginLogs to fetch.
     */
    orderBy?: UserLoginLogOrderByWithRelationInput | UserLoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLoginLogs.
     */
    cursor?: UserLoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLoginLogs.
     */
    distinct?: UserLoginLogScalarFieldEnum | UserLoginLogScalarFieldEnum[]
  }

  /**
   * UserLoginLog findFirstOrThrow
   */
  export type UserLoginLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginLog to fetch.
     */
    where?: UserLoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginLogs to fetch.
     */
    orderBy?: UserLoginLogOrderByWithRelationInput | UserLoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLoginLogs.
     */
    cursor?: UserLoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLoginLogs.
     */
    distinct?: UserLoginLogScalarFieldEnum | UserLoginLogScalarFieldEnum[]
  }

  /**
   * UserLoginLog findMany
   */
  export type UserLoginLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginLogs to fetch.
     */
    where?: UserLoginLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginLogs to fetch.
     */
    orderBy?: UserLoginLogOrderByWithRelationInput | UserLoginLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLoginLogs.
     */
    cursor?: UserLoginLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginLogs.
     */
    skip?: number
    distinct?: UserLoginLogScalarFieldEnum | UserLoginLogScalarFieldEnum[]
  }

  /**
   * UserLoginLog create
   */
  export type UserLoginLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLoginLog.
     */
    data: XOR<UserLoginLogCreateInput, UserLoginLogUncheckedCreateInput>
  }

  /**
   * UserLoginLog createMany
   */
  export type UserLoginLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLoginLogs.
     */
    data: UserLoginLogCreateManyInput | UserLoginLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLoginLog createManyAndReturn
   */
  export type UserLoginLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * The data used to create many UserLoginLogs.
     */
    data: UserLoginLogCreateManyInput | UserLoginLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLoginLog update
   */
  export type UserLoginLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLoginLog.
     */
    data: XOR<UserLoginLogUpdateInput, UserLoginLogUncheckedUpdateInput>
    /**
     * Choose, which UserLoginLog to update.
     */
    where: UserLoginLogWhereUniqueInput
  }

  /**
   * UserLoginLog updateMany
   */
  export type UserLoginLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLoginLogs.
     */
    data: XOR<UserLoginLogUpdateManyMutationInput, UserLoginLogUncheckedUpdateManyInput>
    /**
     * Filter which UserLoginLogs to update
     */
    where?: UserLoginLogWhereInput
    /**
     * Limit how many UserLoginLogs to update.
     */
    limit?: number
  }

  /**
   * UserLoginLog updateManyAndReturn
   */
  export type UserLoginLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * The data used to update UserLoginLogs.
     */
    data: XOR<UserLoginLogUpdateManyMutationInput, UserLoginLogUncheckedUpdateManyInput>
    /**
     * Filter which UserLoginLogs to update
     */
    where?: UserLoginLogWhereInput
    /**
     * Limit how many UserLoginLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLoginLog upsert
   */
  export type UserLoginLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLoginLog to update in case it exists.
     */
    where: UserLoginLogWhereUniqueInput
    /**
     * In case the UserLoginLog found by the `where` argument doesn't exist, create a new UserLoginLog with this data.
     */
    create: XOR<UserLoginLogCreateInput, UserLoginLogUncheckedCreateInput>
    /**
     * In case the UserLoginLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLoginLogUpdateInput, UserLoginLogUncheckedUpdateInput>
  }

  /**
   * UserLoginLog delete
   */
  export type UserLoginLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
    /**
     * Filter which UserLoginLog to delete.
     */
    where: UserLoginLogWhereUniqueInput
  }

  /**
   * UserLoginLog deleteMany
   */
  export type UserLoginLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLoginLogs to delete
     */
    where?: UserLoginLogWhereInput
    /**
     * Limit how many UserLoginLogs to delete.
     */
    limit?: number
  }

  /**
   * UserLoginLog without action
   */
  export type UserLoginLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginLog
     */
    select?: UserLoginLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLoginLog
     */
    omit?: UserLoginLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginLogInclude<ExtArgs> | null
  }


  /**
   * Model TerminalSettings
   */

  export type AggregateTerminalSettings = {
    _count: TerminalSettingsCountAggregateOutputType | null
    _min: TerminalSettingsMinAggregateOutputType | null
    _max: TerminalSettingsMaxAggregateOutputType | null
  }

  export type TerminalSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    showOnChart: boolean | null
    showSignals: boolean | null
    showHMR: boolean | null
    showPriceAlerts: boolean | null
    showOpenPositions: boolean | null
    showTPSL: boolean | null
    showEconomicCalendar: boolean | null
    economicCalendarHighImpact: boolean | null
    economicCalendarMiddleImpact: boolean | null
    economicCalendarLowImpact: boolean | null
    economicCalendarLowestImpact: boolean | null
    priceAlertSound: boolean | null
    closingSound: boolean | null
    autoTPSL: boolean | null
    openOrderMode: string | null
    priceSource: string | null
    appearance: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminalSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    showOnChart: boolean | null
    showSignals: boolean | null
    showHMR: boolean | null
    showPriceAlerts: boolean | null
    showOpenPositions: boolean | null
    showTPSL: boolean | null
    showEconomicCalendar: boolean | null
    economicCalendarHighImpact: boolean | null
    economicCalendarMiddleImpact: boolean | null
    economicCalendarLowImpact: boolean | null
    economicCalendarLowestImpact: boolean | null
    priceAlertSound: boolean | null
    closingSound: boolean | null
    autoTPSL: boolean | null
    openOrderMode: string | null
    priceSource: string | null
    appearance: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminalSettingsCountAggregateOutputType = {
    id: number
    userId: number
    showOnChart: number
    showSignals: number
    showHMR: number
    showPriceAlerts: number
    showOpenPositions: number
    showTPSL: number
    showEconomicCalendar: number
    economicCalendarHighImpact: number
    economicCalendarMiddleImpact: number
    economicCalendarLowImpact: number
    economicCalendarLowestImpact: number
    priceAlertSound: number
    closingSound: number
    autoTPSL: number
    openOrderMode: number
    priceSource: number
    appearance: number
    timezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TerminalSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    showOnChart?: true
    showSignals?: true
    showHMR?: true
    showPriceAlerts?: true
    showOpenPositions?: true
    showTPSL?: true
    showEconomicCalendar?: true
    economicCalendarHighImpact?: true
    economicCalendarMiddleImpact?: true
    economicCalendarLowImpact?: true
    economicCalendarLowestImpact?: true
    priceAlertSound?: true
    closingSound?: true
    autoTPSL?: true
    openOrderMode?: true
    priceSource?: true
    appearance?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminalSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    showOnChart?: true
    showSignals?: true
    showHMR?: true
    showPriceAlerts?: true
    showOpenPositions?: true
    showTPSL?: true
    showEconomicCalendar?: true
    economicCalendarHighImpact?: true
    economicCalendarMiddleImpact?: true
    economicCalendarLowImpact?: true
    economicCalendarLowestImpact?: true
    priceAlertSound?: true
    closingSound?: true
    autoTPSL?: true
    openOrderMode?: true
    priceSource?: true
    appearance?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminalSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    showOnChart?: true
    showSignals?: true
    showHMR?: true
    showPriceAlerts?: true
    showOpenPositions?: true
    showTPSL?: true
    showEconomicCalendar?: true
    economicCalendarHighImpact?: true
    economicCalendarMiddleImpact?: true
    economicCalendarLowImpact?: true
    economicCalendarLowestImpact?: true
    priceAlertSound?: true
    closingSound?: true
    autoTPSL?: true
    openOrderMode?: true
    priceSource?: true
    appearance?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TerminalSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerminalSettings to aggregate.
     */
    where?: TerminalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSettings to fetch.
     */
    orderBy?: TerminalSettingsOrderByWithRelationInput | TerminalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerminalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TerminalSettings
    **/
    _count?: true | TerminalSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminalSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminalSettingsMaxAggregateInputType
  }

  export type GetTerminalSettingsAggregateType<T extends TerminalSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTerminalSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerminalSettings[P]>
      : GetScalarType<T[P], AggregateTerminalSettings[P]>
  }




  export type TerminalSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminalSettingsWhereInput
    orderBy?: TerminalSettingsOrderByWithAggregationInput | TerminalSettingsOrderByWithAggregationInput[]
    by: TerminalSettingsScalarFieldEnum[] | TerminalSettingsScalarFieldEnum
    having?: TerminalSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminalSettingsCountAggregateInputType | true
    _min?: TerminalSettingsMinAggregateInputType
    _max?: TerminalSettingsMaxAggregateInputType
  }

  export type TerminalSettingsGroupByOutputType = {
    id: string
    userId: string
    showOnChart: boolean
    showSignals: boolean
    showHMR: boolean
    showPriceAlerts: boolean
    showOpenPositions: boolean
    showTPSL: boolean
    showEconomicCalendar: boolean
    economicCalendarHighImpact: boolean
    economicCalendarMiddleImpact: boolean
    economicCalendarLowImpact: boolean
    economicCalendarLowestImpact: boolean
    priceAlertSound: boolean
    closingSound: boolean
    autoTPSL: boolean
    openOrderMode: string
    priceSource: string
    appearance: string
    timezone: string
    createdAt: Date
    updatedAt: Date
    _count: TerminalSettingsCountAggregateOutputType | null
    _min: TerminalSettingsMinAggregateOutputType | null
    _max: TerminalSettingsMaxAggregateOutputType | null
  }

  type GetTerminalSettingsGroupByPayload<T extends TerminalSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminalSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminalSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminalSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TerminalSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TerminalSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: boolean
    priceSource?: boolean
    appearance?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminalSettings"]>

  export type TerminalSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: boolean
    priceSource?: boolean
    appearance?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminalSettings"]>

  export type TerminalSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: boolean
    priceSource?: boolean
    appearance?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminalSettings"]>

  export type TerminalSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: boolean
    priceSource?: boolean
    appearance?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TerminalSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "showOnChart" | "showSignals" | "showHMR" | "showPriceAlerts" | "showOpenPositions" | "showTPSL" | "showEconomicCalendar" | "economicCalendarHighImpact" | "economicCalendarMiddleImpact" | "economicCalendarLowImpact" | "economicCalendarLowestImpact" | "priceAlertSound" | "closingSound" | "autoTPSL" | "openOrderMode" | "priceSource" | "appearance" | "timezone" | "createdAt" | "updatedAt", ExtArgs["result"]["terminalSettings"]>
  export type TerminalSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TerminalSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TerminalSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TerminalSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TerminalSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      showOnChart: boolean
      showSignals: boolean
      showHMR: boolean
      showPriceAlerts: boolean
      showOpenPositions: boolean
      showTPSL: boolean
      showEconomicCalendar: boolean
      economicCalendarHighImpact: boolean
      economicCalendarMiddleImpact: boolean
      economicCalendarLowImpact: boolean
      economicCalendarLowestImpact: boolean
      priceAlertSound: boolean
      closingSound: boolean
      autoTPSL: boolean
      openOrderMode: string
      priceSource: string
      appearance: string
      timezone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["terminalSettings"]>
    composites: {}
  }

  type TerminalSettingsGetPayload<S extends boolean | null | undefined | TerminalSettingsDefaultArgs> = $Result.GetResult<Prisma.$TerminalSettingsPayload, S>

  type TerminalSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TerminalSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerminalSettingsCountAggregateInputType | true
    }

  export interface TerminalSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TerminalSettings'], meta: { name: 'TerminalSettings' } }
    /**
     * Find zero or one TerminalSettings that matches the filter.
     * @param {TerminalSettingsFindUniqueArgs} args - Arguments to find a TerminalSettings
     * @example
     * // Get one TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerminalSettingsFindUniqueArgs>(args: SelectSubset<T, TerminalSettingsFindUniqueArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TerminalSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TerminalSettingsFindUniqueOrThrowArgs} args - Arguments to find a TerminalSettings
     * @example
     * // Get one TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerminalSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TerminalSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TerminalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsFindFirstArgs} args - Arguments to find a TerminalSettings
     * @example
     * // Get one TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerminalSettingsFindFirstArgs>(args?: SelectSubset<T, TerminalSettingsFindFirstArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TerminalSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsFindFirstOrThrowArgs} args - Arguments to find a TerminalSettings
     * @example
     * // Get one TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerminalSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TerminalSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TerminalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.findMany()
     * 
     * // Get first 10 TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terminalSettingsWithIdOnly = await prisma.terminalSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerminalSettingsFindManyArgs>(args?: SelectSubset<T, TerminalSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TerminalSettings.
     * @param {TerminalSettingsCreateArgs} args - Arguments to create a TerminalSettings.
     * @example
     * // Create one TerminalSettings
     * const TerminalSettings = await prisma.terminalSettings.create({
     *   data: {
     *     // ... data to create a TerminalSettings
     *   }
     * })
     * 
     */
    create<T extends TerminalSettingsCreateArgs>(args: SelectSubset<T, TerminalSettingsCreateArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TerminalSettings.
     * @param {TerminalSettingsCreateManyArgs} args - Arguments to create many TerminalSettings.
     * @example
     * // Create many TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerminalSettingsCreateManyArgs>(args?: SelectSubset<T, TerminalSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TerminalSettings and returns the data saved in the database.
     * @param {TerminalSettingsCreateManyAndReturnArgs} args - Arguments to create many TerminalSettings.
     * @example
     * // Create many TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TerminalSettings and only return the `id`
     * const terminalSettingsWithIdOnly = await prisma.terminalSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerminalSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, TerminalSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TerminalSettings.
     * @param {TerminalSettingsDeleteArgs} args - Arguments to delete one TerminalSettings.
     * @example
     * // Delete one TerminalSettings
     * const TerminalSettings = await prisma.terminalSettings.delete({
     *   where: {
     *     // ... filter to delete one TerminalSettings
     *   }
     * })
     * 
     */
    delete<T extends TerminalSettingsDeleteArgs>(args: SelectSubset<T, TerminalSettingsDeleteArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TerminalSettings.
     * @param {TerminalSettingsUpdateArgs} args - Arguments to update one TerminalSettings.
     * @example
     * // Update one TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerminalSettingsUpdateArgs>(args: SelectSubset<T, TerminalSettingsUpdateArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TerminalSettings.
     * @param {TerminalSettingsDeleteManyArgs} args - Arguments to filter TerminalSettings to delete.
     * @example
     * // Delete a few TerminalSettings
     * const { count } = await prisma.terminalSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerminalSettingsDeleteManyArgs>(args?: SelectSubset<T, TerminalSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerminalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerminalSettingsUpdateManyArgs>(args: SelectSubset<T, TerminalSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerminalSettings and returns the data updated in the database.
     * @param {TerminalSettingsUpdateManyAndReturnArgs} args - Arguments to update many TerminalSettings.
     * @example
     * // Update many TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TerminalSettings and only return the `id`
     * const terminalSettingsWithIdOnly = await prisma.terminalSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TerminalSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, TerminalSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TerminalSettings.
     * @param {TerminalSettingsUpsertArgs} args - Arguments to update or create a TerminalSettings.
     * @example
     * // Update or create a TerminalSettings
     * const terminalSettings = await prisma.terminalSettings.upsert({
     *   create: {
     *     // ... data to create a TerminalSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TerminalSettings we want to update
     *   }
     * })
     */
    upsert<T extends TerminalSettingsUpsertArgs>(args: SelectSubset<T, TerminalSettingsUpsertArgs<ExtArgs>>): Prisma__TerminalSettingsClient<$Result.GetResult<Prisma.$TerminalSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TerminalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsCountArgs} args - Arguments to filter TerminalSettings to count.
     * @example
     * // Count the number of TerminalSettings
     * const count = await prisma.terminalSettings.count({
     *   where: {
     *     // ... the filter for the TerminalSettings we want to count
     *   }
     * })
    **/
    count<T extends TerminalSettingsCountArgs>(
      args?: Subset<T, TerminalSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminalSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TerminalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminalSettingsAggregateArgs>(args: Subset<T, TerminalSettingsAggregateArgs>): Prisma.PrismaPromise<GetTerminalSettingsAggregateType<T>>

    /**
     * Group by TerminalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerminalSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerminalSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TerminalSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerminalSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminalSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TerminalSettings model
   */
  readonly fields: TerminalSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TerminalSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerminalSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TerminalSettings model
   */
  interface TerminalSettingsFieldRefs {
    readonly id: FieldRef<"TerminalSettings", 'String'>
    readonly userId: FieldRef<"TerminalSettings", 'String'>
    readonly showOnChart: FieldRef<"TerminalSettings", 'Boolean'>
    readonly showSignals: FieldRef<"TerminalSettings", 'Boolean'>
    readonly showHMR: FieldRef<"TerminalSettings", 'Boolean'>
    readonly showPriceAlerts: FieldRef<"TerminalSettings", 'Boolean'>
    readonly showOpenPositions: FieldRef<"TerminalSettings", 'Boolean'>
    readonly showTPSL: FieldRef<"TerminalSettings", 'Boolean'>
    readonly showEconomicCalendar: FieldRef<"TerminalSettings", 'Boolean'>
    readonly economicCalendarHighImpact: FieldRef<"TerminalSettings", 'Boolean'>
    readonly economicCalendarMiddleImpact: FieldRef<"TerminalSettings", 'Boolean'>
    readonly economicCalendarLowImpact: FieldRef<"TerminalSettings", 'Boolean'>
    readonly economicCalendarLowestImpact: FieldRef<"TerminalSettings", 'Boolean'>
    readonly priceAlertSound: FieldRef<"TerminalSettings", 'Boolean'>
    readonly closingSound: FieldRef<"TerminalSettings", 'Boolean'>
    readonly autoTPSL: FieldRef<"TerminalSettings", 'Boolean'>
    readonly openOrderMode: FieldRef<"TerminalSettings", 'String'>
    readonly priceSource: FieldRef<"TerminalSettings", 'String'>
    readonly appearance: FieldRef<"TerminalSettings", 'String'>
    readonly timezone: FieldRef<"TerminalSettings", 'String'>
    readonly createdAt: FieldRef<"TerminalSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"TerminalSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TerminalSettings findUnique
   */
  export type TerminalSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSettings to fetch.
     */
    where: TerminalSettingsWhereUniqueInput
  }

  /**
   * TerminalSettings findUniqueOrThrow
   */
  export type TerminalSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSettings to fetch.
     */
    where: TerminalSettingsWhereUniqueInput
  }

  /**
   * TerminalSettings findFirst
   */
  export type TerminalSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSettings to fetch.
     */
    where?: TerminalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSettings to fetch.
     */
    orderBy?: TerminalSettingsOrderByWithRelationInput | TerminalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerminalSettings.
     */
    cursor?: TerminalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerminalSettings.
     */
    distinct?: TerminalSettingsScalarFieldEnum | TerminalSettingsScalarFieldEnum[]
  }

  /**
   * TerminalSettings findFirstOrThrow
   */
  export type TerminalSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSettings to fetch.
     */
    where?: TerminalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSettings to fetch.
     */
    orderBy?: TerminalSettingsOrderByWithRelationInput | TerminalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerminalSettings.
     */
    cursor?: TerminalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerminalSettings.
     */
    distinct?: TerminalSettingsScalarFieldEnum | TerminalSettingsScalarFieldEnum[]
  }

  /**
   * TerminalSettings findMany
   */
  export type TerminalSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSettings to fetch.
     */
    where?: TerminalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSettings to fetch.
     */
    orderBy?: TerminalSettingsOrderByWithRelationInput | TerminalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TerminalSettings.
     */
    cursor?: TerminalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSettings.
     */
    skip?: number
    distinct?: TerminalSettingsScalarFieldEnum | TerminalSettingsScalarFieldEnum[]
  }

  /**
   * TerminalSettings create
   */
  export type TerminalSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a TerminalSettings.
     */
    data: XOR<TerminalSettingsCreateInput, TerminalSettingsUncheckedCreateInput>
  }

  /**
   * TerminalSettings createMany
   */
  export type TerminalSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TerminalSettings.
     */
    data: TerminalSettingsCreateManyInput | TerminalSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TerminalSettings createManyAndReturn
   */
  export type TerminalSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many TerminalSettings.
     */
    data: TerminalSettingsCreateManyInput | TerminalSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TerminalSettings update
   */
  export type TerminalSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a TerminalSettings.
     */
    data: XOR<TerminalSettingsUpdateInput, TerminalSettingsUncheckedUpdateInput>
    /**
     * Choose, which TerminalSettings to update.
     */
    where: TerminalSettingsWhereUniqueInput
  }

  /**
   * TerminalSettings updateMany
   */
  export type TerminalSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TerminalSettings.
     */
    data: XOR<TerminalSettingsUpdateManyMutationInput, TerminalSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TerminalSettings to update
     */
    where?: TerminalSettingsWhereInput
    /**
     * Limit how many TerminalSettings to update.
     */
    limit?: number
  }

  /**
   * TerminalSettings updateManyAndReturn
   */
  export type TerminalSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * The data used to update TerminalSettings.
     */
    data: XOR<TerminalSettingsUpdateManyMutationInput, TerminalSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TerminalSettings to update
     */
    where?: TerminalSettingsWhereInput
    /**
     * Limit how many TerminalSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TerminalSettings upsert
   */
  export type TerminalSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the TerminalSettings to update in case it exists.
     */
    where: TerminalSettingsWhereUniqueInput
    /**
     * In case the TerminalSettings found by the `where` argument doesn't exist, create a new TerminalSettings with this data.
     */
    create: XOR<TerminalSettingsCreateInput, TerminalSettingsUncheckedCreateInput>
    /**
     * In case the TerminalSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerminalSettingsUpdateInput, TerminalSettingsUncheckedUpdateInput>
  }

  /**
   * TerminalSettings delete
   */
  export type TerminalSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
    /**
     * Filter which TerminalSettings to delete.
     */
    where: TerminalSettingsWhereUniqueInput
  }

  /**
   * TerminalSettings deleteMany
   */
  export type TerminalSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerminalSettings to delete
     */
    where?: TerminalSettingsWhereInput
    /**
     * Limit how many TerminalSettings to delete.
     */
    limit?: number
  }

  /**
   * TerminalSettings without action
   */
  export type TerminalSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSettings
     */
    select?: TerminalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSettings
     */
    omit?: TerminalSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSettingsInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    admin_role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password_hash: string | null
    admin_role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password_hash: number
    admin_role: number
    is_active: number
    last_login: number
    login_attempts: number
    locked_until: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    admin_role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    admin_role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    admin_role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    username: string
    email: string
    password_hash: string
    admin_role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
    admin_login_log?: boolean | admin$admin_login_logArgs<ExtArgs>
    balance_operation_history?: boolean | admin$balance_operation_historyArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    admin_role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password_hash" | "admin_role" | "is_active" | "last_login" | "login_attempts" | "locked_until" | "created_at" | "updated_at", ExtArgs["result"]["admin"]>
  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_login_log?: boolean | admin$admin_login_logArgs<ExtArgs>
    balance_operation_history?: boolean | admin$balance_operation_historyArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      admin_login_log: Prisma.$admin_login_logPayload<ExtArgs>[]
      balance_operation_history: Prisma.$balance_operation_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password_hash: string
      admin_role: string | null
      is_active: boolean | null
      last_login: Date | null
      login_attempts: number | null
      locked_until: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminCreateManyAndReturnArgs>(args?: SelectSubset<T, adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adminUpdateManyAndReturnArgs>(args: SelectSubset<T, adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_login_log<T extends admin$admin_login_logArgs<ExtArgs> = {}>(args?: Subset<T, admin$admin_login_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balance_operation_history<T extends admin$balance_operation_historyArgs<ExtArgs> = {}>(args?: Subset<T, admin$balance_operation_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly username: FieldRef<"admin", 'String'>
    readonly email: FieldRef<"admin", 'String'>
    readonly password_hash: FieldRef<"admin", 'String'>
    readonly admin_role: FieldRef<"admin", 'String'>
    readonly is_active: FieldRef<"admin", 'Boolean'>
    readonly last_login: FieldRef<"admin", 'DateTime'>
    readonly login_attempts: FieldRef<"admin", 'Int'>
    readonly locked_until: FieldRef<"admin", 'DateTime'>
    readonly created_at: FieldRef<"admin", 'DateTime'>
    readonly updated_at: FieldRef<"admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin createManyAndReturn
   */
  export type adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin updateManyAndReturn
   */
  export type adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin.admin_login_log
   */
  export type admin$admin_login_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    where?: admin_login_logWhereInput
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    cursor?: admin_login_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin.balance_operation_history
   */
  export type admin$balance_operation_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    where?: balance_operation_historyWhereInput
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    cursor?: balance_operation_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model admin_login_log
   */

  export type AggregateAdmin_login_log = {
    _count: Admin_login_logCountAggregateOutputType | null
    _avg: Admin_login_logAvgAggregateOutputType | null
    _sum: Admin_login_logSumAggregateOutputType | null
    _min: Admin_login_logMinAggregateOutputType | null
    _max: Admin_login_logMaxAggregateOutputType | null
  }

  export type Admin_login_logAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
  }

  export type Admin_login_logSumAggregateOutputType = {
    id: number | null
    admin_id: number | null
  }

  export type Admin_login_logMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    ip_address: string | null
    user_agent: string | null
    location: string | null
    device: string | null
    browser: string | null
    os: string | null
    success: boolean | null
    failure_reason: string | null
    created_at: Date | null
  }

  export type Admin_login_logMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    ip_address: string | null
    user_agent: string | null
    location: string | null
    device: string | null
    browser: string | null
    os: string | null
    success: boolean | null
    failure_reason: string | null
    created_at: Date | null
  }

  export type Admin_login_logCountAggregateOutputType = {
    id: number
    admin_id: number
    ip_address: number
    user_agent: number
    location: number
    device: number
    browser: number
    os: number
    success: number
    failure_reason: number
    created_at: number
    _all: number
  }


  export type Admin_login_logAvgAggregateInputType = {
    id?: true
    admin_id?: true
  }

  export type Admin_login_logSumAggregateInputType = {
    id?: true
    admin_id?: true
  }

  export type Admin_login_logMinAggregateInputType = {
    id?: true
    admin_id?: true
    ip_address?: true
    user_agent?: true
    location?: true
    device?: true
    browser?: true
    os?: true
    success?: true
    failure_reason?: true
    created_at?: true
  }

  export type Admin_login_logMaxAggregateInputType = {
    id?: true
    admin_id?: true
    ip_address?: true
    user_agent?: true
    location?: true
    device?: true
    browser?: true
    os?: true
    success?: true
    failure_reason?: true
    created_at?: true
  }

  export type Admin_login_logCountAggregateInputType = {
    id?: true
    admin_id?: true
    ip_address?: true
    user_agent?: true
    location?: true
    device?: true
    browser?: true
    os?: true
    success?: true
    failure_reason?: true
    created_at?: true
    _all?: true
  }

  export type Admin_login_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_login_log to aggregate.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_login_logs
    **/
    _count?: true | Admin_login_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_login_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_login_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_login_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_login_logMaxAggregateInputType
  }

  export type GetAdmin_login_logAggregateType<T extends Admin_login_logAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_login_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_login_log[P]>
      : GetScalarType<T[P], AggregateAdmin_login_log[P]>
  }




  export type admin_login_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_login_logWhereInput
    orderBy?: admin_login_logOrderByWithAggregationInput | admin_login_logOrderByWithAggregationInput[]
    by: Admin_login_logScalarFieldEnum[] | Admin_login_logScalarFieldEnum
    having?: admin_login_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_login_logCountAggregateInputType | true
    _avg?: Admin_login_logAvgAggregateInputType
    _sum?: Admin_login_logSumAggregateInputType
    _min?: Admin_login_logMinAggregateInputType
    _max?: Admin_login_logMaxAggregateInputType
  }

  export type Admin_login_logGroupByOutputType = {
    id: number
    admin_id: number
    ip_address: string
    user_agent: string | null
    location: string | null
    device: string | null
    browser: string | null
    os: string | null
    success: boolean
    failure_reason: string | null
    created_at: Date
    _count: Admin_login_logCountAggregateOutputType | null
    _avg: Admin_login_logAvgAggregateOutputType | null
    _sum: Admin_login_logSumAggregateOutputType | null
    _min: Admin_login_logMinAggregateOutputType | null
    _max: Admin_login_logMaxAggregateOutputType | null
  }

  type GetAdmin_login_logGroupByPayload<T extends admin_login_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_login_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_login_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_login_logGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_login_logGroupByOutputType[P]>
        }
      >
    >


  export type admin_login_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_login_log"]>

  export type admin_login_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_login_log"]>

  export type admin_login_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_login_log"]>

  export type admin_login_logSelectScalar = {
    id?: boolean
    admin_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    location?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    success?: boolean
    failure_reason?: boolean
    created_at?: boolean
  }

  export type admin_login_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "ip_address" | "user_agent" | "location" | "device" | "browser" | "os" | "success" | "failure_reason" | "created_at", ExtArgs["result"]["admin_login_log"]>
  export type admin_login_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type admin_login_logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type admin_login_logIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }

  export type $admin_login_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_login_log"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      ip_address: string
      user_agent: string | null
      location: string | null
      device: string | null
      browser: string | null
      os: string | null
      success: boolean
      failure_reason: string | null
      created_at: Date
    }, ExtArgs["result"]["admin_login_log"]>
    composites: {}
  }

  type admin_login_logGetPayload<S extends boolean | null | undefined | admin_login_logDefaultArgs> = $Result.GetResult<Prisma.$admin_login_logPayload, S>

  type admin_login_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_login_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_login_logCountAggregateInputType | true
    }

  export interface admin_login_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_login_log'], meta: { name: 'admin_login_log' } }
    /**
     * Find zero or one Admin_login_log that matches the filter.
     * @param {admin_login_logFindUniqueArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_login_logFindUniqueArgs>(args: SelectSubset<T, admin_login_logFindUniqueArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_login_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_login_logFindUniqueOrThrowArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_login_logFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_login_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_login_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logFindFirstArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_login_logFindFirstArgs>(args?: SelectSubset<T, admin_login_logFindFirstArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_login_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logFindFirstOrThrowArgs} args - Arguments to find a Admin_login_log
     * @example
     * // Get one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_login_logFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_login_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_login_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_login_logs
     * const admin_login_logs = await prisma.admin_login_log.findMany()
     * 
     * // Get first 10 Admin_login_logs
     * const admin_login_logs = await prisma.admin_login_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_login_logWithIdOnly = await prisma.admin_login_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_login_logFindManyArgs>(args?: SelectSubset<T, admin_login_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_login_log.
     * @param {admin_login_logCreateArgs} args - Arguments to create a Admin_login_log.
     * @example
     * // Create one Admin_login_log
     * const Admin_login_log = await prisma.admin_login_log.create({
     *   data: {
     *     // ... data to create a Admin_login_log
     *   }
     * })
     * 
     */
    create<T extends admin_login_logCreateArgs>(args: SelectSubset<T, admin_login_logCreateArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_login_logs.
     * @param {admin_login_logCreateManyArgs} args - Arguments to create many Admin_login_logs.
     * @example
     * // Create many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_login_logCreateManyArgs>(args?: SelectSubset<T, admin_login_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_login_logs and returns the data saved in the database.
     * @param {admin_login_logCreateManyAndReturnArgs} args - Arguments to create many Admin_login_logs.
     * @example
     * // Create many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_login_logs and only return the `id`
     * const admin_login_logWithIdOnly = await prisma.admin_login_log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_login_logCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_login_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin_login_log.
     * @param {admin_login_logDeleteArgs} args - Arguments to delete one Admin_login_log.
     * @example
     * // Delete one Admin_login_log
     * const Admin_login_log = await prisma.admin_login_log.delete({
     *   where: {
     *     // ... filter to delete one Admin_login_log
     *   }
     * })
     * 
     */
    delete<T extends admin_login_logDeleteArgs>(args: SelectSubset<T, admin_login_logDeleteArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_login_log.
     * @param {admin_login_logUpdateArgs} args - Arguments to update one Admin_login_log.
     * @example
     * // Update one Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_login_logUpdateArgs>(args: SelectSubset<T, admin_login_logUpdateArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_login_logs.
     * @param {admin_login_logDeleteManyArgs} args - Arguments to filter Admin_login_logs to delete.
     * @example
     * // Delete a few Admin_login_logs
     * const { count } = await prisma.admin_login_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_login_logDeleteManyArgs>(args?: SelectSubset<T, admin_login_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_login_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_login_logUpdateManyArgs>(args: SelectSubset<T, admin_login_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_login_logs and returns the data updated in the database.
     * @param {admin_login_logUpdateManyAndReturnArgs} args - Arguments to update many Admin_login_logs.
     * @example
     * // Update many Admin_login_logs
     * const admin_login_log = await prisma.admin_login_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admin_login_logs and only return the `id`
     * const admin_login_logWithIdOnly = await prisma.admin_login_log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admin_login_logUpdateManyAndReturnArgs>(args: SelectSubset<T, admin_login_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin_login_log.
     * @param {admin_login_logUpsertArgs} args - Arguments to update or create a Admin_login_log.
     * @example
     * // Update or create a Admin_login_log
     * const admin_login_log = await prisma.admin_login_log.upsert({
     *   create: {
     *     // ... data to create a Admin_login_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_login_log we want to update
     *   }
     * })
     */
    upsert<T extends admin_login_logUpsertArgs>(args: SelectSubset<T, admin_login_logUpsertArgs<ExtArgs>>): Prisma__admin_login_logClient<$Result.GetResult<Prisma.$admin_login_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_login_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logCountArgs} args - Arguments to filter Admin_login_logs to count.
     * @example
     * // Count the number of Admin_login_logs
     * const count = await prisma.admin_login_log.count({
     *   where: {
     *     // ... the filter for the Admin_login_logs we want to count
     *   }
     * })
    **/
    count<T extends admin_login_logCountArgs>(
      args?: Subset<T, admin_login_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_login_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_login_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_login_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_login_logAggregateArgs>(args: Subset<T, Admin_login_logAggregateArgs>): Prisma.PrismaPromise<GetAdmin_login_logAggregateType<T>>

    /**
     * Group by Admin_login_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_login_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_login_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_login_logGroupByArgs['orderBy'] }
        : { orderBy?: admin_login_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_login_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_login_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_login_log model
   */
  readonly fields: admin_login_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_login_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_login_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_login_log model
   */
  interface admin_login_logFieldRefs {
    readonly id: FieldRef<"admin_login_log", 'Int'>
    readonly admin_id: FieldRef<"admin_login_log", 'Int'>
    readonly ip_address: FieldRef<"admin_login_log", 'String'>
    readonly user_agent: FieldRef<"admin_login_log", 'String'>
    readonly location: FieldRef<"admin_login_log", 'String'>
    readonly device: FieldRef<"admin_login_log", 'String'>
    readonly browser: FieldRef<"admin_login_log", 'String'>
    readonly os: FieldRef<"admin_login_log", 'String'>
    readonly success: FieldRef<"admin_login_log", 'Boolean'>
    readonly failure_reason: FieldRef<"admin_login_log", 'String'>
    readonly created_at: FieldRef<"admin_login_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin_login_log findUnique
   */
  export type admin_login_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log findUniqueOrThrow
   */
  export type admin_login_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log findFirst
   */
  export type admin_login_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_login_logs.
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_login_logs.
     */
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin_login_log findFirstOrThrow
   */
  export type admin_login_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_log to fetch.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_login_logs.
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_login_logs.
     */
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin_login_log findMany
   */
  export type admin_login_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_login_logs to fetch.
     */
    where?: admin_login_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_login_logs to fetch.
     */
    orderBy?: admin_login_logOrderByWithRelationInput | admin_login_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_login_logs.
     */
    cursor?: admin_login_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_login_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_login_logs.
     */
    skip?: number
    distinct?: Admin_login_logScalarFieldEnum | Admin_login_logScalarFieldEnum[]
  }

  /**
   * admin_login_log create
   */
  export type admin_login_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * The data needed to create a admin_login_log.
     */
    data: XOR<admin_login_logCreateInput, admin_login_logUncheckedCreateInput>
  }

  /**
   * admin_login_log createMany
   */
  export type admin_login_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_login_logs.
     */
    data: admin_login_logCreateManyInput | admin_login_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_login_log createManyAndReturn
   */
  export type admin_login_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * The data used to create many admin_login_logs.
     */
    data: admin_login_logCreateManyInput | admin_login_logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_login_log update
   */
  export type admin_login_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * The data needed to update a admin_login_log.
     */
    data: XOR<admin_login_logUpdateInput, admin_login_logUncheckedUpdateInput>
    /**
     * Choose, which admin_login_log to update.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log updateMany
   */
  export type admin_login_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_login_logs.
     */
    data: XOR<admin_login_logUpdateManyMutationInput, admin_login_logUncheckedUpdateManyInput>
    /**
     * Filter which admin_login_logs to update
     */
    where?: admin_login_logWhereInput
    /**
     * Limit how many admin_login_logs to update.
     */
    limit?: number
  }

  /**
   * admin_login_log updateManyAndReturn
   */
  export type admin_login_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * The data used to update admin_login_logs.
     */
    data: XOR<admin_login_logUpdateManyMutationInput, admin_login_logUncheckedUpdateManyInput>
    /**
     * Filter which admin_login_logs to update
     */
    where?: admin_login_logWhereInput
    /**
     * Limit how many admin_login_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_login_log upsert
   */
  export type admin_login_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * The filter to search for the admin_login_log to update in case it exists.
     */
    where: admin_login_logWhereUniqueInput
    /**
     * In case the admin_login_log found by the `where` argument doesn't exist, create a new admin_login_log with this data.
     */
    create: XOR<admin_login_logCreateInput, admin_login_logUncheckedCreateInput>
    /**
     * In case the admin_login_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_login_logUpdateInput, admin_login_logUncheckedUpdateInput>
  }

  /**
   * admin_login_log delete
   */
  export type admin_login_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
    /**
     * Filter which admin_login_log to delete.
     */
    where: admin_login_logWhereUniqueInput
  }

  /**
   * admin_login_log deleteMany
   */
  export type admin_login_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_login_logs to delete
     */
    where?: admin_login_logWhereInput
    /**
     * Limit how many admin_login_logs to delete.
     */
    limit?: number
  }

  /**
   * admin_login_log without action
   */
  export type admin_login_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_login_log
     */
    select?: admin_login_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_login_log
     */
    omit?: admin_login_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_login_logInclude<ExtArgs> | null
  }


  /**
   * Model balance_operation_history
   */

  export type AggregateBalance_operation_history = {
    _count: Balance_operation_historyCountAggregateOutputType | null
    _avg: Balance_operation_historyAvgAggregateOutputType | null
    _sum: Balance_operation_historySumAggregateOutputType | null
    _min: Balance_operation_historyMinAggregateOutputType | null
    _max: Balance_operation_historyMaxAggregateOutputType | null
  }

  export type Balance_operation_historyAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
    amount: number | null
  }

  export type Balance_operation_historySumAggregateOutputType = {
    id: number | null
    admin_id: number | null
    amount: number | null
  }

  export type Balance_operation_historyMinAggregateOutputType = {
    id: number | null
    admin_id: number | null
    mt5_login: string | null
    operation_type: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string | null
    error_message: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
  }

  export type Balance_operation_historyMaxAggregateOutputType = {
    id: number | null
    admin_id: number | null
    mt5_login: string | null
    operation_type: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string | null
    error_message: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
  }

  export type Balance_operation_historyCountAggregateOutputType = {
    id: number
    admin_id: number
    mt5_login: number
    operation_type: number
    amount: number
    currency: number
    description: number
    status: number
    error_message: number
    ip_address: number
    user_agent: number
    created_at: number
    _all: number
  }


  export type Balance_operation_historyAvgAggregateInputType = {
    id?: true
    admin_id?: true
    amount?: true
  }

  export type Balance_operation_historySumAggregateInputType = {
    id?: true
    admin_id?: true
    amount?: true
  }

  export type Balance_operation_historyMinAggregateInputType = {
    id?: true
    admin_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    error_message?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
  }

  export type Balance_operation_historyMaxAggregateInputType = {
    id?: true
    admin_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    error_message?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
  }

  export type Balance_operation_historyCountAggregateInputType = {
    id?: true
    admin_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    error_message?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    _all?: true
  }

  export type Balance_operation_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balance_operation_history to aggregate.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned balance_operation_histories
    **/
    _count?: true | Balance_operation_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Balance_operation_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Balance_operation_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Balance_operation_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Balance_operation_historyMaxAggregateInputType
  }

  export type GetBalance_operation_historyAggregateType<T extends Balance_operation_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance_operation_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance_operation_history[P]>
      : GetScalarType<T[P], AggregateBalance_operation_history[P]>
  }




  export type balance_operation_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balance_operation_historyWhereInput
    orderBy?: balance_operation_historyOrderByWithAggregationInput | balance_operation_historyOrderByWithAggregationInput[]
    by: Balance_operation_historyScalarFieldEnum[] | Balance_operation_historyScalarFieldEnum
    having?: balance_operation_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Balance_operation_historyCountAggregateInputType | true
    _avg?: Balance_operation_historyAvgAggregateInputType
    _sum?: Balance_operation_historySumAggregateInputType
    _min?: Balance_operation_historyMinAggregateInputType
    _max?: Balance_operation_historyMaxAggregateInputType
  }

  export type Balance_operation_historyGroupByOutputType = {
    id: number
    admin_id: number
    mt5_login: string
    operation_type: string
    amount: number
    currency: string
    description: string | null
    status: string
    error_message: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date
    _count: Balance_operation_historyCountAggregateOutputType | null
    _avg: Balance_operation_historyAvgAggregateOutputType | null
    _sum: Balance_operation_historySumAggregateOutputType | null
    _min: Balance_operation_historyMinAggregateOutputType | null
    _max: Balance_operation_historyMaxAggregateOutputType | null
  }

  type GetBalance_operation_historyGroupByPayload<T extends balance_operation_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Balance_operation_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Balance_operation_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Balance_operation_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Balance_operation_historyGroupByOutputType[P]>
        }
      >
    >


  export type balance_operation_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance_operation_history"]>

  export type balance_operation_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance_operation_history"]>

  export type balance_operation_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance_operation_history"]>

  export type balance_operation_historySelectScalar = {
    id?: boolean
    admin_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    error_message?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
  }

  export type balance_operation_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "mt5_login" | "operation_type" | "amount" | "currency" | "description" | "status" | "error_message" | "ip_address" | "user_agent" | "created_at", ExtArgs["result"]["balance_operation_history"]>
  export type balance_operation_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type balance_operation_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type balance_operation_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }

  export type $balance_operation_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "balance_operation_history"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      admin_id: number
      mt5_login: string
      operation_type: string
      amount: number
      currency: string
      description: string | null
      status: string
      error_message: string | null
      ip_address: string | null
      user_agent: string | null
      created_at: Date
    }, ExtArgs["result"]["balance_operation_history"]>
    composites: {}
  }

  type balance_operation_historyGetPayload<S extends boolean | null | undefined | balance_operation_historyDefaultArgs> = $Result.GetResult<Prisma.$balance_operation_historyPayload, S>

  type balance_operation_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<balance_operation_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Balance_operation_historyCountAggregateInputType | true
    }

  export interface balance_operation_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['balance_operation_history'], meta: { name: 'balance_operation_history' } }
    /**
     * Find zero or one Balance_operation_history that matches the filter.
     * @param {balance_operation_historyFindUniqueArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends balance_operation_historyFindUniqueArgs>(args: SelectSubset<T, balance_operation_historyFindUniqueArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balance_operation_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {balance_operation_historyFindUniqueOrThrowArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends balance_operation_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, balance_operation_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance_operation_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyFindFirstArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends balance_operation_historyFindFirstArgs>(args?: SelectSubset<T, balance_operation_historyFindFirstArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance_operation_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyFindFirstOrThrowArgs} args - Arguments to find a Balance_operation_history
     * @example
     * // Get one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends balance_operation_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, balance_operation_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balance_operation_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balance_operation_histories
     * const balance_operation_histories = await prisma.balance_operation_history.findMany()
     * 
     * // Get first 10 Balance_operation_histories
     * const balance_operation_histories = await prisma.balance_operation_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balance_operation_historyWithIdOnly = await prisma.balance_operation_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends balance_operation_historyFindManyArgs>(args?: SelectSubset<T, balance_operation_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balance_operation_history.
     * @param {balance_operation_historyCreateArgs} args - Arguments to create a Balance_operation_history.
     * @example
     * // Create one Balance_operation_history
     * const Balance_operation_history = await prisma.balance_operation_history.create({
     *   data: {
     *     // ... data to create a Balance_operation_history
     *   }
     * })
     * 
     */
    create<T extends balance_operation_historyCreateArgs>(args: SelectSubset<T, balance_operation_historyCreateArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balance_operation_histories.
     * @param {balance_operation_historyCreateManyArgs} args - Arguments to create many Balance_operation_histories.
     * @example
     * // Create many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends balance_operation_historyCreateManyArgs>(args?: SelectSubset<T, balance_operation_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balance_operation_histories and returns the data saved in the database.
     * @param {balance_operation_historyCreateManyAndReturnArgs} args - Arguments to create many Balance_operation_histories.
     * @example
     * // Create many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balance_operation_histories and only return the `id`
     * const balance_operation_historyWithIdOnly = await prisma.balance_operation_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends balance_operation_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, balance_operation_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balance_operation_history.
     * @param {balance_operation_historyDeleteArgs} args - Arguments to delete one Balance_operation_history.
     * @example
     * // Delete one Balance_operation_history
     * const Balance_operation_history = await prisma.balance_operation_history.delete({
     *   where: {
     *     // ... filter to delete one Balance_operation_history
     *   }
     * })
     * 
     */
    delete<T extends balance_operation_historyDeleteArgs>(args: SelectSubset<T, balance_operation_historyDeleteArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balance_operation_history.
     * @param {balance_operation_historyUpdateArgs} args - Arguments to update one Balance_operation_history.
     * @example
     * // Update one Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends balance_operation_historyUpdateArgs>(args: SelectSubset<T, balance_operation_historyUpdateArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balance_operation_histories.
     * @param {balance_operation_historyDeleteManyArgs} args - Arguments to filter Balance_operation_histories to delete.
     * @example
     * // Delete a few Balance_operation_histories
     * const { count } = await prisma.balance_operation_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends balance_operation_historyDeleteManyArgs>(args?: SelectSubset<T, balance_operation_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balance_operation_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends balance_operation_historyUpdateManyArgs>(args: SelectSubset<T, balance_operation_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balance_operation_histories and returns the data updated in the database.
     * @param {balance_operation_historyUpdateManyAndReturnArgs} args - Arguments to update many Balance_operation_histories.
     * @example
     * // Update many Balance_operation_histories
     * const balance_operation_history = await prisma.balance_operation_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balance_operation_histories and only return the `id`
     * const balance_operation_historyWithIdOnly = await prisma.balance_operation_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends balance_operation_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, balance_operation_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balance_operation_history.
     * @param {balance_operation_historyUpsertArgs} args - Arguments to update or create a Balance_operation_history.
     * @example
     * // Update or create a Balance_operation_history
     * const balance_operation_history = await prisma.balance_operation_history.upsert({
     *   create: {
     *     // ... data to create a Balance_operation_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance_operation_history we want to update
     *   }
     * })
     */
    upsert<T extends balance_operation_historyUpsertArgs>(args: SelectSubset<T, balance_operation_historyUpsertArgs<ExtArgs>>): Prisma__balance_operation_historyClient<$Result.GetResult<Prisma.$balance_operation_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balance_operation_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyCountArgs} args - Arguments to filter Balance_operation_histories to count.
     * @example
     * // Count the number of Balance_operation_histories
     * const count = await prisma.balance_operation_history.count({
     *   where: {
     *     // ... the filter for the Balance_operation_histories we want to count
     *   }
     * })
    **/
    count<T extends balance_operation_historyCountArgs>(
      args?: Subset<T, balance_operation_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Balance_operation_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance_operation_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Balance_operation_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Balance_operation_historyAggregateArgs>(args: Subset<T, Balance_operation_historyAggregateArgs>): Prisma.PrismaPromise<GetBalance_operation_historyAggregateType<T>>

    /**
     * Group by Balance_operation_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balance_operation_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends balance_operation_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: balance_operation_historyGroupByArgs['orderBy'] }
        : { orderBy?: balance_operation_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, balance_operation_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalance_operation_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the balance_operation_history model
   */
  readonly fields: balance_operation_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for balance_operation_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__balance_operation_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the balance_operation_history model
   */
  interface balance_operation_historyFieldRefs {
    readonly id: FieldRef<"balance_operation_history", 'Int'>
    readonly admin_id: FieldRef<"balance_operation_history", 'Int'>
    readonly mt5_login: FieldRef<"balance_operation_history", 'String'>
    readonly operation_type: FieldRef<"balance_operation_history", 'String'>
    readonly amount: FieldRef<"balance_operation_history", 'Float'>
    readonly currency: FieldRef<"balance_operation_history", 'String'>
    readonly description: FieldRef<"balance_operation_history", 'String'>
    readonly status: FieldRef<"balance_operation_history", 'String'>
    readonly error_message: FieldRef<"balance_operation_history", 'String'>
    readonly ip_address: FieldRef<"balance_operation_history", 'String'>
    readonly user_agent: FieldRef<"balance_operation_history", 'String'>
    readonly created_at: FieldRef<"balance_operation_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * balance_operation_history findUnique
   */
  export type balance_operation_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history findUniqueOrThrow
   */
  export type balance_operation_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history findFirst
   */
  export type balance_operation_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balance_operation_histories.
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balance_operation_histories.
     */
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * balance_operation_history findFirstOrThrow
   */
  export type balance_operation_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_history to fetch.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balance_operation_histories.
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balance_operation_histories.
     */
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * balance_operation_history findMany
   */
  export type balance_operation_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter, which balance_operation_histories to fetch.
     */
    where?: balance_operation_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balance_operation_histories to fetch.
     */
    orderBy?: balance_operation_historyOrderByWithRelationInput | balance_operation_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing balance_operation_histories.
     */
    cursor?: balance_operation_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balance_operation_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balance_operation_histories.
     */
    skip?: number
    distinct?: Balance_operation_historyScalarFieldEnum | Balance_operation_historyScalarFieldEnum[]
  }

  /**
   * balance_operation_history create
   */
  export type balance_operation_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a balance_operation_history.
     */
    data: XOR<balance_operation_historyCreateInput, balance_operation_historyUncheckedCreateInput>
  }

  /**
   * balance_operation_history createMany
   */
  export type balance_operation_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many balance_operation_histories.
     */
    data: balance_operation_historyCreateManyInput | balance_operation_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * balance_operation_history createManyAndReturn
   */
  export type balance_operation_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * The data used to create many balance_operation_histories.
     */
    data: balance_operation_historyCreateManyInput | balance_operation_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * balance_operation_history update
   */
  export type balance_operation_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a balance_operation_history.
     */
    data: XOR<balance_operation_historyUpdateInput, balance_operation_historyUncheckedUpdateInput>
    /**
     * Choose, which balance_operation_history to update.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history updateMany
   */
  export type balance_operation_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update balance_operation_histories.
     */
    data: XOR<balance_operation_historyUpdateManyMutationInput, balance_operation_historyUncheckedUpdateManyInput>
    /**
     * Filter which balance_operation_histories to update
     */
    where?: balance_operation_historyWhereInput
    /**
     * Limit how many balance_operation_histories to update.
     */
    limit?: number
  }

  /**
   * balance_operation_history updateManyAndReturn
   */
  export type balance_operation_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * The data used to update balance_operation_histories.
     */
    data: XOR<balance_operation_historyUpdateManyMutationInput, balance_operation_historyUncheckedUpdateManyInput>
    /**
     * Filter which balance_operation_histories to update
     */
    where?: balance_operation_historyWhereInput
    /**
     * Limit how many balance_operation_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * balance_operation_history upsert
   */
  export type balance_operation_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the balance_operation_history to update in case it exists.
     */
    where: balance_operation_historyWhereUniqueInput
    /**
     * In case the balance_operation_history found by the `where` argument doesn't exist, create a new balance_operation_history with this data.
     */
    create: XOR<balance_operation_historyCreateInput, balance_operation_historyUncheckedCreateInput>
    /**
     * In case the balance_operation_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<balance_operation_historyUpdateInput, balance_operation_historyUncheckedUpdateInput>
  }

  /**
   * balance_operation_history delete
   */
  export type balance_operation_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
    /**
     * Filter which balance_operation_history to delete.
     */
    where: balance_operation_historyWhereUniqueInput
  }

  /**
   * balance_operation_history deleteMany
   */
  export type balance_operation_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balance_operation_histories to delete
     */
    where?: balance_operation_historyWhereInput
    /**
     * Limit how many balance_operation_histories to delete.
     */
    limit?: number
  }

  /**
   * balance_operation_history without action
   */
  export type balance_operation_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balance_operation_history
     */
    select?: balance_operation_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the balance_operation_history
     */
    omit?: balance_operation_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balance_operation_historyInclude<ExtArgs> | null
  }


  /**
   * Model chat_conversations
   */

  export type AggregateChat_conversations = {
    _count: Chat_conversationsCountAggregateOutputType | null
    _avg: Chat_conversationsAvgAggregateOutputType | null
    _sum: Chat_conversationsSumAggregateOutputType | null
    _min: Chat_conversationsMinAggregateOutputType | null
    _max: Chat_conversationsMaxAggregateOutputType | null
  }

  export type Chat_conversationsAvgAggregateOutputType = {
    id: number | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsSumAggregateOutputType = {
    id: number | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    admin_id: string | null
    status: string | null
    priority: string | null
    subject: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    admin_id: string | null
    status: string | null
    priority: string | null
    subject: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    unread_count_admin: number | null
    unread_count_user: number | null
  }

  export type Chat_conversationsCountAggregateOutputType = {
    id: number
    user_id: number
    user_name: number
    user_email: number
    admin_id: number
    status: number
    priority: number
    subject: number
    last_message_at: number
    created_at: number
    updated_at: number
    closed_at: number
    closed_by: number
    tags: number
    unread_count_admin: number
    unread_count_user: number
    _all: number
  }


  export type Chat_conversationsAvgAggregateInputType = {
    id?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsSumAggregateInputType = {
    id?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsMinAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    admin_id?: true
    status?: true
    priority?: true
    subject?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    closed_at?: true
    closed_by?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    admin_id?: true
    status?: true
    priority?: true
    subject?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    closed_at?: true
    closed_by?: true
    unread_count_admin?: true
    unread_count_user?: true
  }

  export type Chat_conversationsCountAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    admin_id?: true
    status?: true
    priority?: true
    subject?: true
    last_message_at?: true
    created_at?: true
    updated_at?: true
    closed_at?: true
    closed_by?: true
    tags?: true
    unread_count_admin?: true
    unread_count_user?: true
    _all?: true
  }

  export type Chat_conversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_conversations to aggregate.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_conversations
    **/
    _count?: true | Chat_conversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_conversationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_conversationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_conversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_conversationsMaxAggregateInputType
  }

  export type GetChat_conversationsAggregateType<T extends Chat_conversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_conversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_conversations[P]>
      : GetScalarType<T[P], AggregateChat_conversations[P]>
  }




  export type chat_conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_conversationsWhereInput
    orderBy?: chat_conversationsOrderByWithAggregationInput | chat_conversationsOrderByWithAggregationInput[]
    by: Chat_conversationsScalarFieldEnum[] | Chat_conversationsScalarFieldEnum
    having?: chat_conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_conversationsCountAggregateInputType | true
    _avg?: Chat_conversationsAvgAggregateInputType
    _sum?: Chat_conversationsSumAggregateInputType
    _min?: Chat_conversationsMinAggregateInputType
    _max?: Chat_conversationsMaxAggregateInputType
  }

  export type Chat_conversationsGroupByOutputType = {
    id: number
    user_id: string
    user_name: string
    user_email: string
    admin_id: string | null
    status: string | null
    priority: string | null
    subject: string | null
    last_message_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    tags: string[]
    unread_count_admin: number | null
    unread_count_user: number | null
    _count: Chat_conversationsCountAggregateOutputType | null
    _avg: Chat_conversationsAvgAggregateOutputType | null
    _sum: Chat_conversationsSumAggregateOutputType | null
    _min: Chat_conversationsMinAggregateOutputType | null
    _max: Chat_conversationsMaxAggregateOutputType | null
  }

  type GetChat_conversationsGroupByPayload<T extends chat_conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_conversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_conversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_conversationsGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_conversationsGroupByOutputType[P]>
        }
      >
    >


  export type chat_conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
    chat_messages?: boolean | chat_conversations$chat_messagesArgs<ExtArgs>
    chat_participants?: boolean | chat_conversations$chat_participantsArgs<ExtArgs>
    _count?: boolean | Chat_conversationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat_conversations"]>

  export type chat_conversationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
  }, ExtArgs["result"]["chat_conversations"]>

  export type chat_conversationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
  }, ExtArgs["result"]["chat_conversations"]>

  export type chat_conversationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    admin_id?: boolean
    status?: boolean
    priority?: boolean
    subject?: boolean
    last_message_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
    tags?: boolean
    unread_count_admin?: boolean
    unread_count_user?: boolean
  }

  export type chat_conversationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "user_name" | "user_email" | "admin_id" | "status" | "priority" | "subject" | "last_message_at" | "created_at" | "updated_at" | "closed_at" | "closed_by" | "tags" | "unread_count_admin" | "unread_count_user", ExtArgs["result"]["chat_conversations"]>
  export type chat_conversationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_messages?: boolean | chat_conversations$chat_messagesArgs<ExtArgs>
    chat_participants?: boolean | chat_conversations$chat_participantsArgs<ExtArgs>
    _count?: boolean | Chat_conversationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chat_conversationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type chat_conversationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $chat_conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_conversations"
    objects: {
      chat_messages: Prisma.$chat_messagesPayload<ExtArgs>[]
      chat_participants: Prisma.$chat_participantsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      user_name: string
      user_email: string
      admin_id: string | null
      status: string | null
      priority: string | null
      subject: string | null
      last_message_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      closed_at: Date | null
      closed_by: string | null
      tags: string[]
      unread_count_admin: number | null
      unread_count_user: number | null
    }, ExtArgs["result"]["chat_conversations"]>
    composites: {}
  }

  type chat_conversationsGetPayload<S extends boolean | null | undefined | chat_conversationsDefaultArgs> = $Result.GetResult<Prisma.$chat_conversationsPayload, S>

  type chat_conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_conversationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_conversationsCountAggregateInputType | true
    }

  export interface chat_conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_conversations'], meta: { name: 'chat_conversations' } }
    /**
     * Find zero or one Chat_conversations that matches the filter.
     * @param {chat_conversationsFindUniqueArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_conversationsFindUniqueArgs>(args: SelectSubset<T, chat_conversationsFindUniqueArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_conversations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_conversationsFindUniqueOrThrowArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_conversationsFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_conversationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsFindFirstArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_conversationsFindFirstArgs>(args?: SelectSubset<T, chat_conversationsFindFirstArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsFindFirstOrThrowArgs} args - Arguments to find a Chat_conversations
     * @example
     * // Get one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_conversationsFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_conversationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findMany()
     * 
     * // Get first 10 Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_conversationsWithIdOnly = await prisma.chat_conversations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_conversationsFindManyArgs>(args?: SelectSubset<T, chat_conversationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_conversations.
     * @param {chat_conversationsCreateArgs} args - Arguments to create a Chat_conversations.
     * @example
     * // Create one Chat_conversations
     * const Chat_conversations = await prisma.chat_conversations.create({
     *   data: {
     *     // ... data to create a Chat_conversations
     *   }
     * })
     * 
     */
    create<T extends chat_conversationsCreateArgs>(args: SelectSubset<T, chat_conversationsCreateArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_conversations.
     * @param {chat_conversationsCreateManyArgs} args - Arguments to create many Chat_conversations.
     * @example
     * // Create many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_conversationsCreateManyArgs>(args?: SelectSubset<T, chat_conversationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_conversations and returns the data saved in the database.
     * @param {chat_conversationsCreateManyAndReturnArgs} args - Arguments to create many Chat_conversations.
     * @example
     * // Create many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_conversations and only return the `id`
     * const chat_conversationsWithIdOnly = await prisma.chat_conversations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_conversationsCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_conversationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_conversations.
     * @param {chat_conversationsDeleteArgs} args - Arguments to delete one Chat_conversations.
     * @example
     * // Delete one Chat_conversations
     * const Chat_conversations = await prisma.chat_conversations.delete({
     *   where: {
     *     // ... filter to delete one Chat_conversations
     *   }
     * })
     * 
     */
    delete<T extends chat_conversationsDeleteArgs>(args: SelectSubset<T, chat_conversationsDeleteArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_conversations.
     * @param {chat_conversationsUpdateArgs} args - Arguments to update one Chat_conversations.
     * @example
     * // Update one Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_conversationsUpdateArgs>(args: SelectSubset<T, chat_conversationsUpdateArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_conversations.
     * @param {chat_conversationsDeleteManyArgs} args - Arguments to filter Chat_conversations to delete.
     * @example
     * // Delete a few Chat_conversations
     * const { count } = await prisma.chat_conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_conversationsDeleteManyArgs>(args?: SelectSubset<T, chat_conversationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_conversationsUpdateManyArgs>(args: SelectSubset<T, chat_conversationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_conversations and returns the data updated in the database.
     * @param {chat_conversationsUpdateManyAndReturnArgs} args - Arguments to update many Chat_conversations.
     * @example
     * // Update many Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_conversations and only return the `id`
     * const chat_conversationsWithIdOnly = await prisma.chat_conversations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_conversationsUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_conversationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_conversations.
     * @param {chat_conversationsUpsertArgs} args - Arguments to update or create a Chat_conversations.
     * @example
     * // Update or create a Chat_conversations
     * const chat_conversations = await prisma.chat_conversations.upsert({
     *   create: {
     *     // ... data to create a Chat_conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_conversations we want to update
     *   }
     * })
     */
    upsert<T extends chat_conversationsUpsertArgs>(args: SelectSubset<T, chat_conversationsUpsertArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsCountArgs} args - Arguments to filter Chat_conversations to count.
     * @example
     * // Count the number of Chat_conversations
     * const count = await prisma.chat_conversations.count({
     *   where: {
     *     // ... the filter for the Chat_conversations we want to count
     *   }
     * })
    **/
    count<T extends chat_conversationsCountArgs>(
      args?: Subset<T, chat_conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_conversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_conversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_conversationsAggregateArgs>(args: Subset<T, Chat_conversationsAggregateArgs>): Prisma.PrismaPromise<GetChat_conversationsAggregateType<T>>

    /**
     * Group by Chat_conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_conversationsGroupByArgs['orderBy'] }
        : { orderBy?: chat_conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_conversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_conversations model
   */
  readonly fields: chat_conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_messages<T extends chat_conversations$chat_messagesArgs<ExtArgs> = {}>(args?: Subset<T, chat_conversations$chat_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat_participants<T extends chat_conversations$chat_participantsArgs<ExtArgs> = {}>(args?: Subset<T, chat_conversations$chat_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_conversations model
   */
  interface chat_conversationsFieldRefs {
    readonly id: FieldRef<"chat_conversations", 'Int'>
    readonly user_id: FieldRef<"chat_conversations", 'String'>
    readonly user_name: FieldRef<"chat_conversations", 'String'>
    readonly user_email: FieldRef<"chat_conversations", 'String'>
    readonly admin_id: FieldRef<"chat_conversations", 'String'>
    readonly status: FieldRef<"chat_conversations", 'String'>
    readonly priority: FieldRef<"chat_conversations", 'String'>
    readonly subject: FieldRef<"chat_conversations", 'String'>
    readonly last_message_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly created_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly updated_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly closed_at: FieldRef<"chat_conversations", 'DateTime'>
    readonly closed_by: FieldRef<"chat_conversations", 'String'>
    readonly tags: FieldRef<"chat_conversations", 'String[]'>
    readonly unread_count_admin: FieldRef<"chat_conversations", 'Int'>
    readonly unread_count_user: FieldRef<"chat_conversations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * chat_conversations findUnique
   */
  export type chat_conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations findUniqueOrThrow
   */
  export type chat_conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations findFirst
   */
  export type chat_conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_conversations.
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_conversations.
     */
    distinct?: Chat_conversationsScalarFieldEnum | Chat_conversationsScalarFieldEnum[]
  }

  /**
   * chat_conversations findFirstOrThrow
   */
  export type chat_conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_conversations.
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_conversations.
     */
    distinct?: Chat_conversationsScalarFieldEnum | Chat_conversationsScalarFieldEnum[]
  }

  /**
   * chat_conversations findMany
   */
  export type chat_conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter, which chat_conversations to fetch.
     */
    where?: chat_conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_conversations to fetch.
     */
    orderBy?: chat_conversationsOrderByWithRelationInput | chat_conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_conversations.
     */
    cursor?: chat_conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_conversations.
     */
    skip?: number
    distinct?: Chat_conversationsScalarFieldEnum | Chat_conversationsScalarFieldEnum[]
  }

  /**
   * chat_conversations create
   */
  export type chat_conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_conversations.
     */
    data: XOR<chat_conversationsCreateInput, chat_conversationsUncheckedCreateInput>
  }

  /**
   * chat_conversations createMany
   */
  export type chat_conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_conversations.
     */
    data: chat_conversationsCreateManyInput | chat_conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_conversations createManyAndReturn
   */
  export type chat_conversationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * The data used to create many chat_conversations.
     */
    data: chat_conversationsCreateManyInput | chat_conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_conversations update
   */
  export type chat_conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_conversations.
     */
    data: XOR<chat_conversationsUpdateInput, chat_conversationsUncheckedUpdateInput>
    /**
     * Choose, which chat_conversations to update.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations updateMany
   */
  export type chat_conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_conversations.
     */
    data: XOR<chat_conversationsUpdateManyMutationInput, chat_conversationsUncheckedUpdateManyInput>
    /**
     * Filter which chat_conversations to update
     */
    where?: chat_conversationsWhereInput
    /**
     * Limit how many chat_conversations to update.
     */
    limit?: number
  }

  /**
   * chat_conversations updateManyAndReturn
   */
  export type chat_conversationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * The data used to update chat_conversations.
     */
    data: XOR<chat_conversationsUpdateManyMutationInput, chat_conversationsUncheckedUpdateManyInput>
    /**
     * Filter which chat_conversations to update
     */
    where?: chat_conversationsWhereInput
    /**
     * Limit how many chat_conversations to update.
     */
    limit?: number
  }

  /**
   * chat_conversations upsert
   */
  export type chat_conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_conversations to update in case it exists.
     */
    where: chat_conversationsWhereUniqueInput
    /**
     * In case the chat_conversations found by the `where` argument doesn't exist, create a new chat_conversations with this data.
     */
    create: XOR<chat_conversationsCreateInput, chat_conversationsUncheckedCreateInput>
    /**
     * In case the chat_conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_conversationsUpdateInput, chat_conversationsUncheckedUpdateInput>
  }

  /**
   * chat_conversations delete
   */
  export type chat_conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    /**
     * Filter which chat_conversations to delete.
     */
    where: chat_conversationsWhereUniqueInput
  }

  /**
   * chat_conversations deleteMany
   */
  export type chat_conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_conversations to delete
     */
    where?: chat_conversationsWhereInput
    /**
     * Limit how many chat_conversations to delete.
     */
    limit?: number
  }

  /**
   * chat_conversations.chat_messages
   */
  export type chat_conversations$chat_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    cursor?: chat_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_conversations.chat_participants
   */
  export type chat_conversations$chat_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    where?: chat_participantsWhereInput
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    cursor?: chat_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_conversations without action
   */
  export type chat_conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
  }


  /**
   * Model chat_messages
   */

  export type AggregateChat_messages = {
    _count: Chat_messagesCountAggregateOutputType | null
    _avg: Chat_messagesAvgAggregateOutputType | null
    _sum: Chat_messagesSumAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  export type Chat_messagesAvgAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_messagesSumAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_messagesMinAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    message_type: string | null
    content: string | null
    is_read: boolean | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Chat_messagesMaxAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    message_type: string | null
    content: string | null
    is_read: boolean | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Chat_messagesCountAggregateOutputType = {
    id: number
    conversation_id: number
    sender_id: number
    sender_name: number
    sender_type: number
    message_type: number
    content: number
    metadata: number
    is_read: number
    read_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Chat_messagesAvgAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_messagesSumAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_messagesMinAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    message_type?: true
    content?: true
    is_read?: true
    read_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Chat_messagesMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    message_type?: true
    content?: true
    is_read?: true
    read_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Chat_messagesCountAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    message_type?: true
    content?: true
    metadata?: true
    is_read?: true
    read_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Chat_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to aggregate.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_messages
    **/
    _count?: true | Chat_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_messagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_messagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type GetChat_messagesAggregateType<T extends Chat_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_messages[P]>
      : GetScalarType<T[P], AggregateChat_messages[P]>
  }




  export type chat_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_messagesWhereInput
    orderBy?: chat_messagesOrderByWithAggregationInput | chat_messagesOrderByWithAggregationInput[]
    by: Chat_messagesScalarFieldEnum[] | Chat_messagesScalarFieldEnum
    having?: chat_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_messagesCountAggregateInputType | true
    _avg?: Chat_messagesAvgAggregateInputType
    _sum?: Chat_messagesSumAggregateInputType
    _min?: Chat_messagesMinAggregateInputType
    _max?: Chat_messagesMaxAggregateInputType
  }

  export type Chat_messagesGroupByOutputType = {
    id: number
    conversation_id: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    message_type: string | null
    content: string
    metadata: JsonValue | null
    is_read: boolean | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Chat_messagesCountAggregateOutputType | null
    _avg: Chat_messagesAvgAggregateOutputType | null
    _sum: Chat_messagesSumAggregateOutputType | null
    _min: Chat_messagesMinAggregateOutputType | null
    _max: Chat_messagesMaxAggregateOutputType | null
  }

  type GetChat_messagesGroupByPayload<T extends chat_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_messagesGroupByOutputType[P]>
        }
      >
    >


  export type chat_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_messages"]>

  export type chat_messagesSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    message_type?: boolean
    content?: boolean
    metadata?: boolean
    is_read?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chat_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversation_id" | "sender_id" | "sender_name" | "sender_type" | "message_type" | "content" | "metadata" | "is_read" | "read_at" | "created_at" | "updated_at", ExtArgs["result"]["chat_messages"]>
  export type chat_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }
  export type chat_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }
  export type chat_messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_messages$chat_conversationsArgs<ExtArgs>
  }

  export type $chat_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_messages"
    objects: {
      chat_conversations: Prisma.$chat_conversationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversation_id: number | null
      sender_id: string
      sender_name: string
      sender_type: string
      message_type: string | null
      content: string
      metadata: Prisma.JsonValue | null
      is_read: boolean | null
      read_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["chat_messages"]>
    composites: {}
  }

  type chat_messagesGetPayload<S extends boolean | null | undefined | chat_messagesDefaultArgs> = $Result.GetResult<Prisma.$chat_messagesPayload, S>

  type chat_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_messagesCountAggregateInputType | true
    }

  export interface chat_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_messages'], meta: { name: 'chat_messages' } }
    /**
     * Find zero or one Chat_messages that matches the filter.
     * @param {chat_messagesFindUniqueArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_messagesFindUniqueArgs>(args: SelectSubset<T, chat_messagesFindUniqueArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_messagesFindUniqueOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_messagesFindFirstArgs>(args?: SelectSubset<T, chat_messagesFindFirstArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindFirstOrThrowArgs} args - Arguments to find a Chat_messages
     * @example
     * // Get one Chat_messages
     * const chat_messages = await prisma.chat_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany()
     * 
     * // Get first 10 Chat_messages
     * const chat_messages = await prisma.chat_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_messagesFindManyArgs>(args?: SelectSubset<T, chat_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_messages.
     * @param {chat_messagesCreateArgs} args - Arguments to create a Chat_messages.
     * @example
     * // Create one Chat_messages
     * const Chat_messages = await prisma.chat_messages.create({
     *   data: {
     *     // ... data to create a Chat_messages
     *   }
     * })
     * 
     */
    create<T extends chat_messagesCreateArgs>(args: SelectSubset<T, chat_messagesCreateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_messages.
     * @param {chat_messagesCreateManyArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_messagesCreateManyArgs>(args?: SelectSubset<T, chat_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_messages and returns the data saved in the database.
     * @param {chat_messagesCreateManyAndReturnArgs} args - Arguments to create many Chat_messages.
     * @example
     * // Create many Chat_messages
     * const chat_messages = await prisma.chat_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_messages.
     * @param {chat_messagesDeleteArgs} args - Arguments to delete one Chat_messages.
     * @example
     * // Delete one Chat_messages
     * const Chat_messages = await prisma.chat_messages.delete({
     *   where: {
     *     // ... filter to delete one Chat_messages
     *   }
     * })
     * 
     */
    delete<T extends chat_messagesDeleteArgs>(args: SelectSubset<T, chat_messagesDeleteArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_messages.
     * @param {chat_messagesUpdateArgs} args - Arguments to update one Chat_messages.
     * @example
     * // Update one Chat_messages
     * const chat_messages = await prisma.chat_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_messagesUpdateArgs>(args: SelectSubset<T, chat_messagesUpdateArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_messages.
     * @param {chat_messagesDeleteManyArgs} args - Arguments to filter Chat_messages to delete.
     * @example
     * // Delete a few Chat_messages
     * const { count } = await prisma.chat_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_messagesDeleteManyArgs>(args?: SelectSubset<T, chat_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_messagesUpdateManyArgs>(args: SelectSubset<T, chat_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_messages and returns the data updated in the database.
     * @param {chat_messagesUpdateManyAndReturnArgs} args - Arguments to update many Chat_messages.
     * @example
     * // Update many Chat_messages
     * const chat_messages = await prisma.chat_messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_messages and only return the `id`
     * const chat_messagesWithIdOnly = await prisma.chat_messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_messages.
     * @param {chat_messagesUpsertArgs} args - Arguments to update or create a Chat_messages.
     * @example
     * // Update or create a Chat_messages
     * const chat_messages = await prisma.chat_messages.upsert({
     *   create: {
     *     // ... data to create a Chat_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_messages we want to update
     *   }
     * })
     */
    upsert<T extends chat_messagesUpsertArgs>(args: SelectSubset<T, chat_messagesUpsertArgs<ExtArgs>>): Prisma__chat_messagesClient<$Result.GetResult<Prisma.$chat_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesCountArgs} args - Arguments to filter Chat_messages to count.
     * @example
     * // Count the number of Chat_messages
     * const count = await prisma.chat_messages.count({
     *   where: {
     *     // ... the filter for the Chat_messages we want to count
     *   }
     * })
    **/
    count<T extends chat_messagesCountArgs>(
      args?: Subset<T, chat_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_messagesAggregateArgs>(args: Subset<T, Chat_messagesAggregateArgs>): Prisma.PrismaPromise<GetChat_messagesAggregateType<T>>

    /**
     * Group by Chat_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_messagesGroupByArgs['orderBy'] }
        : { orderBy?: chat_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_messages model
   */
  readonly fields: chat_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_conversations<T extends chat_messages$chat_conversationsArgs<ExtArgs> = {}>(args?: Subset<T, chat_messages$chat_conversationsArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_messages model
   */
  interface chat_messagesFieldRefs {
    readonly id: FieldRef<"chat_messages", 'Int'>
    readonly conversation_id: FieldRef<"chat_messages", 'Int'>
    readonly sender_id: FieldRef<"chat_messages", 'String'>
    readonly sender_name: FieldRef<"chat_messages", 'String'>
    readonly sender_type: FieldRef<"chat_messages", 'String'>
    readonly message_type: FieldRef<"chat_messages", 'String'>
    readonly content: FieldRef<"chat_messages", 'String'>
    readonly metadata: FieldRef<"chat_messages", 'Json'>
    readonly is_read: FieldRef<"chat_messages", 'Boolean'>
    readonly read_at: FieldRef<"chat_messages", 'DateTime'>
    readonly created_at: FieldRef<"chat_messages", 'DateTime'>
    readonly updated_at: FieldRef<"chat_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chat_messages findUnique
   */
  export type chat_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findUniqueOrThrow
   */
  export type chat_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages findFirst
   */
  export type chat_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findFirstOrThrow
   */
  export type chat_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_messages.
     */
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages findMany
   */
  export type chat_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter, which chat_messages to fetch.
     */
    where?: chat_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_messages to fetch.
     */
    orderBy?: chat_messagesOrderByWithRelationInput | chat_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_messages.
     */
    cursor?: chat_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_messages.
     */
    skip?: number
    distinct?: Chat_messagesScalarFieldEnum | Chat_messagesScalarFieldEnum[]
  }

  /**
   * chat_messages create
   */
  export type chat_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_messages.
     */
    data: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
  }

  /**
   * chat_messages createMany
   */
  export type chat_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_messages createManyAndReturn
   */
  export type chat_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * The data used to create many chat_messages.
     */
    data: chat_messagesCreateManyInput | chat_messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages update
   */
  export type chat_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_messages.
     */
    data: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
    /**
     * Choose, which chat_messages to update.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages updateMany
   */
  export type chat_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to update.
     */
    limit?: number
  }

  /**
   * chat_messages updateManyAndReturn
   */
  export type chat_messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * The data used to update chat_messages.
     */
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyInput>
    /**
     * Filter which chat_messages to update
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_messages upsert
   */
  export type chat_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_messages to update in case it exists.
     */
    where: chat_messagesWhereUniqueInput
    /**
     * In case the chat_messages found by the `where` argument doesn't exist, create a new chat_messages with this data.
     */
    create: XOR<chat_messagesCreateInput, chat_messagesUncheckedCreateInput>
    /**
     * In case the chat_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_messagesUpdateInput, chat_messagesUncheckedUpdateInput>
  }

  /**
   * chat_messages delete
   */
  export type chat_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
    /**
     * Filter which chat_messages to delete.
     */
    where: chat_messagesWhereUniqueInput
  }

  /**
   * chat_messages deleteMany
   */
  export type chat_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_messages to delete
     */
    where?: chat_messagesWhereInput
    /**
     * Limit how many chat_messages to delete.
     */
    limit?: number
  }

  /**
   * chat_messages.chat_conversations
   */
  export type chat_messages$chat_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    where?: chat_conversationsWhereInput
  }

  /**
   * chat_messages without action
   */
  export type chat_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_messages
     */
    select?: chat_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_messages
     */
    omit?: chat_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_messagesInclude<ExtArgs> | null
  }


  /**
   * Model chat_participants
   */

  export type AggregateChat_participants = {
    _count: Chat_participantsCountAggregateOutputType | null
    _avg: Chat_participantsAvgAggregateOutputType | null
    _sum: Chat_participantsSumAggregateOutputType | null
    _min: Chat_participantsMinAggregateOutputType | null
    _max: Chat_participantsMaxAggregateOutputType | null
  }

  export type Chat_participantsAvgAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_participantsSumAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type Chat_participantsMinAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    user_id: string | null
    user_name: string | null
    user_type: string | null
    role: string | null
    joined_at: Date | null
    left_at: Date | null
    is_active: boolean | null
  }

  export type Chat_participantsMaxAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    user_id: string | null
    user_name: string | null
    user_type: string | null
    role: string | null
    joined_at: Date | null
    left_at: Date | null
    is_active: boolean | null
  }

  export type Chat_participantsCountAggregateOutputType = {
    id: number
    conversation_id: number
    user_id: number
    user_name: number
    user_type: number
    role: number
    joined_at: number
    left_at: number
    is_active: number
    _all: number
  }


  export type Chat_participantsAvgAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_participantsSumAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type Chat_participantsMinAggregateInputType = {
    id?: true
    conversation_id?: true
    user_id?: true
    user_name?: true
    user_type?: true
    role?: true
    joined_at?: true
    left_at?: true
    is_active?: true
  }

  export type Chat_participantsMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    user_id?: true
    user_name?: true
    user_type?: true
    role?: true
    joined_at?: true
    left_at?: true
    is_active?: true
  }

  export type Chat_participantsCountAggregateInputType = {
    id?: true
    conversation_id?: true
    user_id?: true
    user_name?: true
    user_type?: true
    role?: true
    joined_at?: true
    left_at?: true
    is_active?: true
    _all?: true
  }

  export type Chat_participantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_participants to aggregate.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_participants
    **/
    _count?: true | Chat_participantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_participantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_participantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_participantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_participantsMaxAggregateInputType
  }

  export type GetChat_participantsAggregateType<T extends Chat_participantsAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_participants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_participants[P]>
      : GetScalarType<T[P], AggregateChat_participants[P]>
  }




  export type chat_participantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_participantsWhereInput
    orderBy?: chat_participantsOrderByWithAggregationInput | chat_participantsOrderByWithAggregationInput[]
    by: Chat_participantsScalarFieldEnum[] | Chat_participantsScalarFieldEnum
    having?: chat_participantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_participantsCountAggregateInputType | true
    _avg?: Chat_participantsAvgAggregateInputType
    _sum?: Chat_participantsSumAggregateInputType
    _min?: Chat_participantsMinAggregateInputType
    _max?: Chat_participantsMaxAggregateInputType
  }

  export type Chat_participantsGroupByOutputType = {
    id: number
    conversation_id: number | null
    user_id: string
    user_name: string
    user_type: string
    role: string | null
    joined_at: Date | null
    left_at: Date | null
    is_active: boolean | null
    _count: Chat_participantsCountAggregateOutputType | null
    _avg: Chat_participantsAvgAggregateOutputType | null
    _sum: Chat_participantsSumAggregateOutputType | null
    _min: Chat_participantsMinAggregateOutputType | null
    _max: Chat_participantsMaxAggregateOutputType | null
  }

  type GetChat_participantsGroupByPayload<T extends chat_participantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_participantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_participantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_participantsGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_participantsGroupByOutputType[P]>
        }
      >
    >


  export type chat_participantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_participants"]>

  export type chat_participantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_participants"]>

  export type chat_participantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }, ExtArgs["result"]["chat_participants"]>

  export type chat_participantsSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_type?: boolean
    role?: boolean
    joined_at?: boolean
    left_at?: boolean
    is_active?: boolean
  }

  export type chat_participantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversation_id" | "user_id" | "user_name" | "user_type" | "role" | "joined_at" | "left_at" | "is_active", ExtArgs["result"]["chat_participants"]>
  export type chat_participantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }
  export type chat_participantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }
  export type chat_participantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_conversations?: boolean | chat_participants$chat_conversationsArgs<ExtArgs>
  }

  export type $chat_participantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_participants"
    objects: {
      chat_conversations: Prisma.$chat_conversationsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversation_id: number | null
      user_id: string
      user_name: string
      user_type: string
      role: string | null
      joined_at: Date | null
      left_at: Date | null
      is_active: boolean | null
    }, ExtArgs["result"]["chat_participants"]>
    composites: {}
  }

  type chat_participantsGetPayload<S extends boolean | null | undefined | chat_participantsDefaultArgs> = $Result.GetResult<Prisma.$chat_participantsPayload, S>

  type chat_participantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_participantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_participantsCountAggregateInputType | true
    }

  export interface chat_participantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_participants'], meta: { name: 'chat_participants' } }
    /**
     * Find zero or one Chat_participants that matches the filter.
     * @param {chat_participantsFindUniqueArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_participantsFindUniqueArgs>(args: SelectSubset<T, chat_participantsFindUniqueArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat_participants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_participantsFindUniqueOrThrowArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_participantsFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_participantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsFindFirstArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_participantsFindFirstArgs>(args?: SelectSubset<T, chat_participantsFindFirstArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat_participants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsFindFirstOrThrowArgs} args - Arguments to find a Chat_participants
     * @example
     * // Get one Chat_participants
     * const chat_participants = await prisma.chat_participants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_participantsFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_participantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chat_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_participants
     * const chat_participants = await prisma.chat_participants.findMany()
     * 
     * // Get first 10 Chat_participants
     * const chat_participants = await prisma.chat_participants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_participantsWithIdOnly = await prisma.chat_participants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_participantsFindManyArgs>(args?: SelectSubset<T, chat_participantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat_participants.
     * @param {chat_participantsCreateArgs} args - Arguments to create a Chat_participants.
     * @example
     * // Create one Chat_participants
     * const Chat_participants = await prisma.chat_participants.create({
     *   data: {
     *     // ... data to create a Chat_participants
     *   }
     * })
     * 
     */
    create<T extends chat_participantsCreateArgs>(args: SelectSubset<T, chat_participantsCreateArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chat_participants.
     * @param {chat_participantsCreateManyArgs} args - Arguments to create many Chat_participants.
     * @example
     * // Create many Chat_participants
     * const chat_participants = await prisma.chat_participants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_participantsCreateManyArgs>(args?: SelectSubset<T, chat_participantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_participants and returns the data saved in the database.
     * @param {chat_participantsCreateManyAndReturnArgs} args - Arguments to create many Chat_participants.
     * @example
     * // Create many Chat_participants
     * const chat_participants = await prisma.chat_participants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_participants and only return the `id`
     * const chat_participantsWithIdOnly = await prisma.chat_participants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_participantsCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_participantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat_participants.
     * @param {chat_participantsDeleteArgs} args - Arguments to delete one Chat_participants.
     * @example
     * // Delete one Chat_participants
     * const Chat_participants = await prisma.chat_participants.delete({
     *   where: {
     *     // ... filter to delete one Chat_participants
     *   }
     * })
     * 
     */
    delete<T extends chat_participantsDeleteArgs>(args: SelectSubset<T, chat_participantsDeleteArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat_participants.
     * @param {chat_participantsUpdateArgs} args - Arguments to update one Chat_participants.
     * @example
     * // Update one Chat_participants
     * const chat_participants = await prisma.chat_participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_participantsUpdateArgs>(args: SelectSubset<T, chat_participantsUpdateArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chat_participants.
     * @param {chat_participantsDeleteManyArgs} args - Arguments to filter Chat_participants to delete.
     * @example
     * // Delete a few Chat_participants
     * const { count } = await prisma.chat_participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_participantsDeleteManyArgs>(args?: SelectSubset<T, chat_participantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_participants
     * const chat_participants = await prisma.chat_participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_participantsUpdateManyArgs>(args: SelectSubset<T, chat_participantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_participants and returns the data updated in the database.
     * @param {chat_participantsUpdateManyAndReturnArgs} args - Arguments to update many Chat_participants.
     * @example
     * // Update many Chat_participants
     * const chat_participants = await prisma.chat_participants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_participants and only return the `id`
     * const chat_participantsWithIdOnly = await prisma.chat_participants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_participantsUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_participantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat_participants.
     * @param {chat_participantsUpsertArgs} args - Arguments to update or create a Chat_participants.
     * @example
     * // Update or create a Chat_participants
     * const chat_participants = await prisma.chat_participants.upsert({
     *   create: {
     *     // ... data to create a Chat_participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_participants we want to update
     *   }
     * })
     */
    upsert<T extends chat_participantsUpsertArgs>(args: SelectSubset<T, chat_participantsUpsertArgs<ExtArgs>>): Prisma__chat_participantsClient<$Result.GetResult<Prisma.$chat_participantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsCountArgs} args - Arguments to filter Chat_participants to count.
     * @example
     * // Count the number of Chat_participants
     * const count = await prisma.chat_participants.count({
     *   where: {
     *     // ... the filter for the Chat_participants we want to count
     *   }
     * })
    **/
    count<T extends chat_participantsCountArgs>(
      args?: Subset<T, chat_participantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_participantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_participantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_participantsAggregateArgs>(args: Subset<T, Chat_participantsAggregateArgs>): Prisma.PrismaPromise<GetChat_participantsAggregateType<T>>

    /**
     * Group by Chat_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_participantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_participantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_participantsGroupByArgs['orderBy'] }
        : { orderBy?: chat_participantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_participantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_participantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_participants model
   */
  readonly fields: chat_participantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_participantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_conversations<T extends chat_participants$chat_conversationsArgs<ExtArgs> = {}>(args?: Subset<T, chat_participants$chat_conversationsArgs<ExtArgs>>): Prisma__chat_conversationsClient<$Result.GetResult<Prisma.$chat_conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_participants model
   */
  interface chat_participantsFieldRefs {
    readonly id: FieldRef<"chat_participants", 'Int'>
    readonly conversation_id: FieldRef<"chat_participants", 'Int'>
    readonly user_id: FieldRef<"chat_participants", 'String'>
    readonly user_name: FieldRef<"chat_participants", 'String'>
    readonly user_type: FieldRef<"chat_participants", 'String'>
    readonly role: FieldRef<"chat_participants", 'String'>
    readonly joined_at: FieldRef<"chat_participants", 'DateTime'>
    readonly left_at: FieldRef<"chat_participants", 'DateTime'>
    readonly is_active: FieldRef<"chat_participants", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * chat_participants findUnique
   */
  export type chat_participantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants findUniqueOrThrow
   */
  export type chat_participantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants findFirst
   */
  export type chat_participantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_participants.
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_participants.
     */
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_participants findFirstOrThrow
   */
  export type chat_participantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_participants.
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_participants.
     */
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_participants findMany
   */
  export type chat_participantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter, which chat_participants to fetch.
     */
    where?: chat_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_participants to fetch.
     */
    orderBy?: chat_participantsOrderByWithRelationInput | chat_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_participants.
     */
    cursor?: chat_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_participants.
     */
    skip?: number
    distinct?: Chat_participantsScalarFieldEnum | Chat_participantsScalarFieldEnum[]
  }

  /**
   * chat_participants create
   */
  export type chat_participantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_participants.
     */
    data: XOR<chat_participantsCreateInput, chat_participantsUncheckedCreateInput>
  }

  /**
   * chat_participants createMany
   */
  export type chat_participantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_participants.
     */
    data: chat_participantsCreateManyInput | chat_participantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_participants createManyAndReturn
   */
  export type chat_participantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * The data used to create many chat_participants.
     */
    data: chat_participantsCreateManyInput | chat_participantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_participants update
   */
  export type chat_participantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_participants.
     */
    data: XOR<chat_participantsUpdateInput, chat_participantsUncheckedUpdateInput>
    /**
     * Choose, which chat_participants to update.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants updateMany
   */
  export type chat_participantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_participants.
     */
    data: XOR<chat_participantsUpdateManyMutationInput, chat_participantsUncheckedUpdateManyInput>
    /**
     * Filter which chat_participants to update
     */
    where?: chat_participantsWhereInput
    /**
     * Limit how many chat_participants to update.
     */
    limit?: number
  }

  /**
   * chat_participants updateManyAndReturn
   */
  export type chat_participantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * The data used to update chat_participants.
     */
    data: XOR<chat_participantsUpdateManyMutationInput, chat_participantsUncheckedUpdateManyInput>
    /**
     * Filter which chat_participants to update
     */
    where?: chat_participantsWhereInput
    /**
     * Limit how many chat_participants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_participants upsert
   */
  export type chat_participantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_participants to update in case it exists.
     */
    where: chat_participantsWhereUniqueInput
    /**
     * In case the chat_participants found by the `where` argument doesn't exist, create a new chat_participants with this data.
     */
    create: XOR<chat_participantsCreateInput, chat_participantsUncheckedCreateInput>
    /**
     * In case the chat_participants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_participantsUpdateInput, chat_participantsUncheckedUpdateInput>
  }

  /**
   * chat_participants delete
   */
  export type chat_participantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
    /**
     * Filter which chat_participants to delete.
     */
    where: chat_participantsWhereUniqueInput
  }

  /**
   * chat_participants deleteMany
   */
  export type chat_participantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_participants to delete
     */
    where?: chat_participantsWhereInput
    /**
     * Limit how many chat_participants to delete.
     */
    limit?: number
  }

  /**
   * chat_participants.chat_conversations
   */
  export type chat_participants$chat_conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_conversations
     */
    select?: chat_conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_conversations
     */
    omit?: chat_conversationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_conversationsInclude<ExtArgs> | null
    where?: chat_conversationsWhereInput
  }

  /**
   * chat_participants without action
   */
  export type chat_participantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_participants
     */
    select?: chat_participantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_participants
     */
    omit?: chat_participantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_participantsInclude<ExtArgs> | null
  }


  /**
   * Model group_commission_structures
   */

  export type AggregateGroup_commission_structures = {
    _count: Group_commission_structuresCountAggregateOutputType | null
    _avg: Group_commission_structuresAvgAggregateOutputType | null
    _sum: Group_commission_structuresSumAggregateOutputType | null
    _min: Group_commission_structuresMinAggregateOutputType | null
    _max: Group_commission_structuresMaxAggregateOutputType | null
  }

  export type Group_commission_structuresAvgAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    level_order: number | null
    min_trading_volume: Decimal | null
    max_trading_volume: Decimal | null
    min_active_clients: number | null
  }

  export type Group_commission_structuresSumAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    level_order: number | null
    min_trading_volume: Decimal | null
    max_trading_volume: Decimal | null
    min_active_clients: number | null
  }

  export type Group_commission_structuresMinAggregateOutputType = {
    id: number | null
    group_id: string | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    level_order: number | null
    min_trading_volume: Decimal | null
    max_trading_volume: Decimal | null
    min_active_clients: number | null
  }

  export type Group_commission_structuresMaxAggregateOutputType = {
    id: number | null
    group_id: string | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    level_order: number | null
    min_trading_volume: Decimal | null
    max_trading_volume: Decimal | null
    min_active_clients: number | null
  }

  export type Group_commission_structuresCountAggregateOutputType = {
    id: number
    group_id: number
    structure_name: number
    usd_per_lot: number
    spread_share_percentage: number
    is_active: number
    created_at: number
    updated_at: number
    level_order: number
    min_trading_volume: number
    max_trading_volume: number
    min_active_clients: number
    _all: number
  }


  export type Group_commission_structuresAvgAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    level_order?: true
    min_trading_volume?: true
    max_trading_volume?: true
    min_active_clients?: true
  }

  export type Group_commission_structuresSumAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    level_order?: true
    min_trading_volume?: true
    max_trading_volume?: true
    min_active_clients?: true
  }

  export type Group_commission_structuresMinAggregateInputType = {
    id?: true
    group_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    level_order?: true
    min_trading_volume?: true
    max_trading_volume?: true
    min_active_clients?: true
  }

  export type Group_commission_structuresMaxAggregateInputType = {
    id?: true
    group_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    level_order?: true
    min_trading_volume?: true
    max_trading_volume?: true
    min_active_clients?: true
  }

  export type Group_commission_structuresCountAggregateInputType = {
    id?: true
    group_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    level_order?: true
    min_trading_volume?: true
    max_trading_volume?: true
    min_active_clients?: true
    _all?: true
  }

  export type Group_commission_structuresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_commission_structures to aggregate.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_commission_structures
    **/
    _count?: true | Group_commission_structuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_commission_structuresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_commission_structuresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_commission_structuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_commission_structuresMaxAggregateInputType
  }

  export type GetGroup_commission_structuresAggregateType<T extends Group_commission_structuresAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_commission_structures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_commission_structures[P]>
      : GetScalarType<T[P], AggregateGroup_commission_structures[P]>
  }




  export type group_commission_structuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_commission_structuresWhereInput
    orderBy?: group_commission_structuresOrderByWithAggregationInput | group_commission_structuresOrderByWithAggregationInput[]
    by: Group_commission_structuresScalarFieldEnum[] | Group_commission_structuresScalarFieldEnum
    having?: group_commission_structuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_commission_structuresCountAggregateInputType | true
    _avg?: Group_commission_structuresAvgAggregateInputType
    _sum?: Group_commission_structuresSumAggregateInputType
    _min?: Group_commission_structuresMinAggregateInputType
    _max?: Group_commission_structuresMaxAggregateInputType
  }

  export type Group_commission_structuresGroupByOutputType = {
    id: number
    group_id: string
    structure_name: string
    usd_per_lot: Decimal
    spread_share_percentage: Decimal
    is_active: boolean
    created_at: Date | null
    updated_at: Date | null
    level_order: number
    min_trading_volume: Decimal | null
    max_trading_volume: Decimal | null
    min_active_clients: number | null
    _count: Group_commission_structuresCountAggregateOutputType | null
    _avg: Group_commission_structuresAvgAggregateOutputType | null
    _sum: Group_commission_structuresSumAggregateOutputType | null
    _min: Group_commission_structuresMinAggregateOutputType | null
    _max: Group_commission_structuresMaxAggregateOutputType | null
  }

  type GetGroup_commission_structuresGroupByPayload<T extends group_commission_structuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_commission_structuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_commission_structuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_commission_structuresGroupByOutputType[P]>
            : GetScalarType<T[P], Group_commission_structuresGroupByOutputType[P]>
        }
      >
    >


  export type group_commission_structuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    level_order?: boolean
    min_trading_volume?: boolean
    max_trading_volume?: boolean
    min_active_clients?: boolean
  }, ExtArgs["result"]["group_commission_structures"]>

  export type group_commission_structuresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    level_order?: boolean
    min_trading_volume?: boolean
    max_trading_volume?: boolean
    min_active_clients?: boolean
  }, ExtArgs["result"]["group_commission_structures"]>

  export type group_commission_structuresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    level_order?: boolean
    min_trading_volume?: boolean
    max_trading_volume?: boolean
    min_active_clients?: boolean
  }, ExtArgs["result"]["group_commission_structures"]>

  export type group_commission_structuresSelectScalar = {
    id?: boolean
    group_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    level_order?: boolean
    min_trading_volume?: boolean
    max_trading_volume?: boolean
    min_active_clients?: boolean
  }

  export type group_commission_structuresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "group_id" | "structure_name" | "usd_per_lot" | "spread_share_percentage" | "is_active" | "created_at" | "updated_at" | "level_order" | "min_trading_volume" | "max_trading_volume" | "min_active_clients", ExtArgs["result"]["group_commission_structures"]>

  export type $group_commission_structuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_commission_structures"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      group_id: string
      structure_name: string
      usd_per_lot: Prisma.Decimal
      spread_share_percentage: Prisma.Decimal
      is_active: boolean
      created_at: Date | null
      updated_at: Date | null
      level_order: number
      min_trading_volume: Prisma.Decimal | null
      max_trading_volume: Prisma.Decimal | null
      min_active_clients: number | null
    }, ExtArgs["result"]["group_commission_structures"]>
    composites: {}
  }

  type group_commission_structuresGetPayload<S extends boolean | null | undefined | group_commission_structuresDefaultArgs> = $Result.GetResult<Prisma.$group_commission_structuresPayload, S>

  type group_commission_structuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<group_commission_structuresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Group_commission_structuresCountAggregateInputType | true
    }

  export interface group_commission_structuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_commission_structures'], meta: { name: 'group_commission_structures' } }
    /**
     * Find zero or one Group_commission_structures that matches the filter.
     * @param {group_commission_structuresFindUniqueArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_commission_structuresFindUniqueArgs>(args: SelectSubset<T, group_commission_structuresFindUniqueArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group_commission_structures that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {group_commission_structuresFindUniqueOrThrowArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_commission_structuresFindUniqueOrThrowArgs>(args: SelectSubset<T, group_commission_structuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_commission_structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresFindFirstArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_commission_structuresFindFirstArgs>(args?: SelectSubset<T, group_commission_structuresFindFirstArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_commission_structures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresFindFirstOrThrowArgs} args - Arguments to find a Group_commission_structures
     * @example
     * // Get one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_commission_structuresFindFirstOrThrowArgs>(args?: SelectSubset<T, group_commission_structuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Group_commission_structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findMany()
     * 
     * // Get first 10 Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const group_commission_structuresWithIdOnly = await prisma.group_commission_structures.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends group_commission_structuresFindManyArgs>(args?: SelectSubset<T, group_commission_structuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group_commission_structures.
     * @param {group_commission_structuresCreateArgs} args - Arguments to create a Group_commission_structures.
     * @example
     * // Create one Group_commission_structures
     * const Group_commission_structures = await prisma.group_commission_structures.create({
     *   data: {
     *     // ... data to create a Group_commission_structures
     *   }
     * })
     * 
     */
    create<T extends group_commission_structuresCreateArgs>(args: SelectSubset<T, group_commission_structuresCreateArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Group_commission_structures.
     * @param {group_commission_structuresCreateManyArgs} args - Arguments to create many Group_commission_structures.
     * @example
     * // Create many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_commission_structuresCreateManyArgs>(args?: SelectSubset<T, group_commission_structuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Group_commission_structures and returns the data saved in the database.
     * @param {group_commission_structuresCreateManyAndReturnArgs} args - Arguments to create many Group_commission_structures.
     * @example
     * // Create many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Group_commission_structures and only return the `id`
     * const group_commission_structuresWithIdOnly = await prisma.group_commission_structures.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends group_commission_structuresCreateManyAndReturnArgs>(args?: SelectSubset<T, group_commission_structuresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group_commission_structures.
     * @param {group_commission_structuresDeleteArgs} args - Arguments to delete one Group_commission_structures.
     * @example
     * // Delete one Group_commission_structures
     * const Group_commission_structures = await prisma.group_commission_structures.delete({
     *   where: {
     *     // ... filter to delete one Group_commission_structures
     *   }
     * })
     * 
     */
    delete<T extends group_commission_structuresDeleteArgs>(args: SelectSubset<T, group_commission_structuresDeleteArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group_commission_structures.
     * @param {group_commission_structuresUpdateArgs} args - Arguments to update one Group_commission_structures.
     * @example
     * // Update one Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_commission_structuresUpdateArgs>(args: SelectSubset<T, group_commission_structuresUpdateArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Group_commission_structures.
     * @param {group_commission_structuresDeleteManyArgs} args - Arguments to filter Group_commission_structures to delete.
     * @example
     * // Delete a few Group_commission_structures
     * const { count } = await prisma.group_commission_structures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_commission_structuresDeleteManyArgs>(args?: SelectSubset<T, group_commission_structuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_commission_structuresUpdateManyArgs>(args: SelectSubset<T, group_commission_structuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_commission_structures and returns the data updated in the database.
     * @param {group_commission_structuresUpdateManyAndReturnArgs} args - Arguments to update many Group_commission_structures.
     * @example
     * // Update many Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Group_commission_structures and only return the `id`
     * const group_commission_structuresWithIdOnly = await prisma.group_commission_structures.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends group_commission_structuresUpdateManyAndReturnArgs>(args: SelectSubset<T, group_commission_structuresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group_commission_structures.
     * @param {group_commission_structuresUpsertArgs} args - Arguments to update or create a Group_commission_structures.
     * @example
     * // Update or create a Group_commission_structures
     * const group_commission_structures = await prisma.group_commission_structures.upsert({
     *   create: {
     *     // ... data to create a Group_commission_structures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_commission_structures we want to update
     *   }
     * })
     */
    upsert<T extends group_commission_structuresUpsertArgs>(args: SelectSubset<T, group_commission_structuresUpsertArgs<ExtArgs>>): Prisma__group_commission_structuresClient<$Result.GetResult<Prisma.$group_commission_structuresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresCountArgs} args - Arguments to filter Group_commission_structures to count.
     * @example
     * // Count the number of Group_commission_structures
     * const count = await prisma.group_commission_structures.count({
     *   where: {
     *     // ... the filter for the Group_commission_structures we want to count
     *   }
     * })
    **/
    count<T extends group_commission_structuresCountArgs>(
      args?: Subset<T, group_commission_structuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_commission_structuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_commission_structuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_commission_structuresAggregateArgs>(args: Subset<T, Group_commission_structuresAggregateArgs>): Prisma.PrismaPromise<GetGroup_commission_structuresAggregateType<T>>

    /**
     * Group by Group_commission_structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_commission_structuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_commission_structuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_commission_structuresGroupByArgs['orderBy'] }
        : { orderBy?: group_commission_structuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_commission_structuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_commission_structuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_commission_structures model
   */
  readonly fields: group_commission_structuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_commission_structures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_commission_structuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_commission_structures model
   */
  interface group_commission_structuresFieldRefs {
    readonly id: FieldRef<"group_commission_structures", 'Int'>
    readonly group_id: FieldRef<"group_commission_structures", 'String'>
    readonly structure_name: FieldRef<"group_commission_structures", 'String'>
    readonly usd_per_lot: FieldRef<"group_commission_structures", 'Decimal'>
    readonly spread_share_percentage: FieldRef<"group_commission_structures", 'Decimal'>
    readonly is_active: FieldRef<"group_commission_structures", 'Boolean'>
    readonly created_at: FieldRef<"group_commission_structures", 'DateTime'>
    readonly updated_at: FieldRef<"group_commission_structures", 'DateTime'>
    readonly level_order: FieldRef<"group_commission_structures", 'Int'>
    readonly min_trading_volume: FieldRef<"group_commission_structures", 'Decimal'>
    readonly max_trading_volume: FieldRef<"group_commission_structures", 'Decimal'>
    readonly min_active_clients: FieldRef<"group_commission_structures", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * group_commission_structures findUnique
   */
  export type group_commission_structuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures findUniqueOrThrow
   */
  export type group_commission_structuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures findFirst
   */
  export type group_commission_structuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_commission_structures.
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_commission_structures.
     */
    distinct?: Group_commission_structuresScalarFieldEnum | Group_commission_structuresScalarFieldEnum[]
  }

  /**
   * group_commission_structures findFirstOrThrow
   */
  export type group_commission_structuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_commission_structures.
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_commission_structures.
     */
    distinct?: Group_commission_structuresScalarFieldEnum | Group_commission_structuresScalarFieldEnum[]
  }

  /**
   * group_commission_structures findMany
   */
  export type group_commission_structuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter, which group_commission_structures to fetch.
     */
    where?: group_commission_structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_commission_structures to fetch.
     */
    orderBy?: group_commission_structuresOrderByWithRelationInput | group_commission_structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_commission_structures.
     */
    cursor?: group_commission_structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_commission_structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_commission_structures.
     */
    skip?: number
    distinct?: Group_commission_structuresScalarFieldEnum | Group_commission_structuresScalarFieldEnum[]
  }

  /**
   * group_commission_structures create
   */
  export type group_commission_structuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data needed to create a group_commission_structures.
     */
    data: XOR<group_commission_structuresCreateInput, group_commission_structuresUncheckedCreateInput>
  }

  /**
   * group_commission_structures createMany
   */
  export type group_commission_structuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_commission_structures.
     */
    data: group_commission_structuresCreateManyInput | group_commission_structuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_commission_structures createManyAndReturn
   */
  export type group_commission_structuresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data used to create many group_commission_structures.
     */
    data: group_commission_structuresCreateManyInput | group_commission_structuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_commission_structures update
   */
  export type group_commission_structuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data needed to update a group_commission_structures.
     */
    data: XOR<group_commission_structuresUpdateInput, group_commission_structuresUncheckedUpdateInput>
    /**
     * Choose, which group_commission_structures to update.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures updateMany
   */
  export type group_commission_structuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_commission_structures.
     */
    data: XOR<group_commission_structuresUpdateManyMutationInput, group_commission_structuresUncheckedUpdateManyInput>
    /**
     * Filter which group_commission_structures to update
     */
    where?: group_commission_structuresWhereInput
    /**
     * Limit how many group_commission_structures to update.
     */
    limit?: number
  }

  /**
   * group_commission_structures updateManyAndReturn
   */
  export type group_commission_structuresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The data used to update group_commission_structures.
     */
    data: XOR<group_commission_structuresUpdateManyMutationInput, group_commission_structuresUncheckedUpdateManyInput>
    /**
     * Filter which group_commission_structures to update
     */
    where?: group_commission_structuresWhereInput
    /**
     * Limit how many group_commission_structures to update.
     */
    limit?: number
  }

  /**
   * group_commission_structures upsert
   */
  export type group_commission_structuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * The filter to search for the group_commission_structures to update in case it exists.
     */
    where: group_commission_structuresWhereUniqueInput
    /**
     * In case the group_commission_structures found by the `where` argument doesn't exist, create a new group_commission_structures with this data.
     */
    create: XOR<group_commission_structuresCreateInput, group_commission_structuresUncheckedCreateInput>
    /**
     * In case the group_commission_structures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_commission_structuresUpdateInput, group_commission_structuresUncheckedUpdateInput>
  }

  /**
   * group_commission_structures delete
   */
  export type group_commission_structuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
    /**
     * Filter which group_commission_structures to delete.
     */
    where: group_commission_structuresWhereUniqueInput
  }

  /**
   * group_commission_structures deleteMany
   */
  export type group_commission_structuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_commission_structures to delete
     */
    where?: group_commission_structuresWhereInput
    /**
     * Limit how many group_commission_structures to delete.
     */
    limit?: number
  }

  /**
   * group_commission_structures without action
   */
  export type group_commission_structuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_commission_structures
     */
    select?: group_commission_structuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_commission_structures
     */
    omit?: group_commission_structuresOmit<ExtArgs> | null
  }


  /**
   * Model ib_admin
   */

  export type AggregateIb_admin = {
    _count: Ib_adminCountAggregateOutputType | null
    _avg: Ib_adminAvgAggregateOutputType | null
    _sum: Ib_adminSumAggregateOutputType | null
    _min: Ib_adminMinAggregateOutputType | null
    _max: Ib_adminMaxAggregateOutputType | null
  }

  export type Ib_adminAvgAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type Ib_adminSumAggregateOutputType = {
    id: number | null
    login_attempts: number | null
  }

  export type Ib_adminMinAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_adminMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_adminCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    role: number
    is_active: number
    last_login: number
    login_attempts: number
    locked_until: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ib_adminAvgAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type Ib_adminSumAggregateInputType = {
    id?: true
    login_attempts?: true
  }

  export type Ib_adminMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_adminMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_adminCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    login_attempts?: true
    locked_until?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ib_adminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_admin to aggregate.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_admins
    **/
    _count?: true | Ib_adminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_adminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_adminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_adminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_adminMaxAggregateInputType
  }

  export type GetIb_adminAggregateType<T extends Ib_adminAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_admin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_admin[P]>
      : GetScalarType<T[P], AggregateIb_admin[P]>
  }




  export type ib_adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_adminWhereInput
    orderBy?: ib_adminOrderByWithAggregationInput | ib_adminOrderByWithAggregationInput[]
    by: Ib_adminScalarFieldEnum[] | Ib_adminScalarFieldEnum
    having?: ib_adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_adminCountAggregateInputType | true
    _avg?: Ib_adminAvgAggregateInputType
    _sum?: Ib_adminSumAggregateInputType
    _min?: Ib_adminMinAggregateInputType
    _max?: Ib_adminMaxAggregateInputType
  }

  export type Ib_adminGroupByOutputType = {
    id: number
    email: string
    password_hash: string
    role: string | null
    is_active: boolean | null
    last_login: Date | null
    login_attempts: number | null
    locked_until: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Ib_adminCountAggregateOutputType | null
    _avg: Ib_adminAvgAggregateOutputType | null
    _sum: Ib_adminSumAggregateOutputType | null
    _min: Ib_adminMinAggregateOutputType | null
    _max: Ib_adminMaxAggregateOutputType | null
  }

  type GetIb_adminGroupByPayload<T extends ib_adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_adminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_adminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_adminGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_adminGroupByOutputType[P]>
        }
      >
    >


  export type ib_adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_admin"]>

  export type ib_adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_admin"]>

  export type ib_adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_admin"]>

  export type ib_adminSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ib_adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "role" | "is_active" | "last_login" | "login_attempts" | "locked_until" | "created_at" | "updated_at", ExtArgs["result"]["ib_admin"]>

  export type $ib_adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password_hash: string
      role: string | null
      is_active: boolean | null
      last_login: Date | null
      login_attempts: number | null
      locked_until: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ib_admin"]>
    composites: {}
  }

  type ib_adminGetPayload<S extends boolean | null | undefined | ib_adminDefaultArgs> = $Result.GetResult<Prisma.$ib_adminPayload, S>

  type ib_adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_adminCountAggregateInputType | true
    }

  export interface ib_adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_admin'], meta: { name: 'ib_admin' } }
    /**
     * Find zero or one Ib_admin that matches the filter.
     * @param {ib_adminFindUniqueArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_adminFindUniqueArgs>(args: SelectSubset<T, ib_adminFindUniqueArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_adminFindUniqueOrThrowArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_adminFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminFindFirstArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_adminFindFirstArgs>(args?: SelectSubset<T, ib_adminFindFirstArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminFindFirstOrThrowArgs} args - Arguments to find a Ib_admin
     * @example
     * // Get one Ib_admin
     * const ib_admin = await prisma.ib_admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_adminFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_admins
     * const ib_admins = await prisma.ib_admin.findMany()
     * 
     * // Get first 10 Ib_admins
     * const ib_admins = await prisma.ib_admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_adminWithIdOnly = await prisma.ib_admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_adminFindManyArgs>(args?: SelectSubset<T, ib_adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_admin.
     * @param {ib_adminCreateArgs} args - Arguments to create a Ib_admin.
     * @example
     * // Create one Ib_admin
     * const Ib_admin = await prisma.ib_admin.create({
     *   data: {
     *     // ... data to create a Ib_admin
     *   }
     * })
     * 
     */
    create<T extends ib_adminCreateArgs>(args: SelectSubset<T, ib_adminCreateArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_admins.
     * @param {ib_adminCreateManyArgs} args - Arguments to create many Ib_admins.
     * @example
     * // Create many Ib_admins
     * const ib_admin = await prisma.ib_admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_adminCreateManyArgs>(args?: SelectSubset<T, ib_adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_admins and returns the data saved in the database.
     * @param {ib_adminCreateManyAndReturnArgs} args - Arguments to create many Ib_admins.
     * @example
     * // Create many Ib_admins
     * const ib_admin = await prisma.ib_admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_admins and only return the `id`
     * const ib_adminWithIdOnly = await prisma.ib_admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_adminCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_admin.
     * @param {ib_adminDeleteArgs} args - Arguments to delete one Ib_admin.
     * @example
     * // Delete one Ib_admin
     * const Ib_admin = await prisma.ib_admin.delete({
     *   where: {
     *     // ... filter to delete one Ib_admin
     *   }
     * })
     * 
     */
    delete<T extends ib_adminDeleteArgs>(args: SelectSubset<T, ib_adminDeleteArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_admin.
     * @param {ib_adminUpdateArgs} args - Arguments to update one Ib_admin.
     * @example
     * // Update one Ib_admin
     * const ib_admin = await prisma.ib_admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_adminUpdateArgs>(args: SelectSubset<T, ib_adminUpdateArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_admins.
     * @param {ib_adminDeleteManyArgs} args - Arguments to filter Ib_admins to delete.
     * @example
     * // Delete a few Ib_admins
     * const { count } = await prisma.ib_admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_adminDeleteManyArgs>(args?: SelectSubset<T, ib_adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_admins
     * const ib_admin = await prisma.ib_admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_adminUpdateManyArgs>(args: SelectSubset<T, ib_adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_admins and returns the data updated in the database.
     * @param {ib_adminUpdateManyAndReturnArgs} args - Arguments to update many Ib_admins.
     * @example
     * // Update many Ib_admins
     * const ib_admin = await prisma.ib_admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_admins and only return the `id`
     * const ib_adminWithIdOnly = await prisma.ib_admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_adminUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_admin.
     * @param {ib_adminUpsertArgs} args - Arguments to update or create a Ib_admin.
     * @example
     * // Update or create a Ib_admin
     * const ib_admin = await prisma.ib_admin.upsert({
     *   create: {
     *     // ... data to create a Ib_admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_admin we want to update
     *   }
     * })
     */
    upsert<T extends ib_adminUpsertArgs>(args: SelectSubset<T, ib_adminUpsertArgs<ExtArgs>>): Prisma__ib_adminClient<$Result.GetResult<Prisma.$ib_adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminCountArgs} args - Arguments to filter Ib_admins to count.
     * @example
     * // Count the number of Ib_admins
     * const count = await prisma.ib_admin.count({
     *   where: {
     *     // ... the filter for the Ib_admins we want to count
     *   }
     * })
    **/
    count<T extends ib_adminCountArgs>(
      args?: Subset<T, ib_adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_adminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_adminAggregateArgs>(args: Subset<T, Ib_adminAggregateArgs>): Prisma.PrismaPromise<GetIb_adminAggregateType<T>>

    /**
     * Group by Ib_admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_adminGroupByArgs['orderBy'] }
        : { orderBy?: ib_adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_admin model
   */
  readonly fields: ib_adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_admin model
   */
  interface ib_adminFieldRefs {
    readonly id: FieldRef<"ib_admin", 'Int'>
    readonly email: FieldRef<"ib_admin", 'String'>
    readonly password_hash: FieldRef<"ib_admin", 'String'>
    readonly role: FieldRef<"ib_admin", 'String'>
    readonly is_active: FieldRef<"ib_admin", 'Boolean'>
    readonly last_login: FieldRef<"ib_admin", 'DateTime'>
    readonly login_attempts: FieldRef<"ib_admin", 'Int'>
    readonly locked_until: FieldRef<"ib_admin", 'DateTime'>
    readonly created_at: FieldRef<"ib_admin", 'DateTime'>
    readonly updated_at: FieldRef<"ib_admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_admin findUnique
   */
  export type ib_adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin findUniqueOrThrow
   */
  export type ib_adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin findFirst
   */
  export type ib_adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_admins.
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_admins.
     */
    distinct?: Ib_adminScalarFieldEnum | Ib_adminScalarFieldEnum[]
  }

  /**
   * ib_admin findFirstOrThrow
   */
  export type ib_adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admin to fetch.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_admins.
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_admins.
     */
    distinct?: Ib_adminScalarFieldEnum | Ib_adminScalarFieldEnum[]
  }

  /**
   * ib_admin findMany
   */
  export type ib_adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter, which ib_admins to fetch.
     */
    where?: ib_adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_admins to fetch.
     */
    orderBy?: ib_adminOrderByWithRelationInput | ib_adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_admins.
     */
    cursor?: ib_adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_admins.
     */
    skip?: number
    distinct?: Ib_adminScalarFieldEnum | Ib_adminScalarFieldEnum[]
  }

  /**
   * ib_admin create
   */
  export type ib_adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_admin.
     */
    data: XOR<ib_adminCreateInput, ib_adminUncheckedCreateInput>
  }

  /**
   * ib_admin createMany
   */
  export type ib_adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_admins.
     */
    data: ib_adminCreateManyInput | ib_adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_admin createManyAndReturn
   */
  export type ib_adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data used to create many ib_admins.
     */
    data: ib_adminCreateManyInput | ib_adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_admin update
   */
  export type ib_adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_admin.
     */
    data: XOR<ib_adminUpdateInput, ib_adminUncheckedUpdateInput>
    /**
     * Choose, which ib_admin to update.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin updateMany
   */
  export type ib_adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_admins.
     */
    data: XOR<ib_adminUpdateManyMutationInput, ib_adminUncheckedUpdateManyInput>
    /**
     * Filter which ib_admins to update
     */
    where?: ib_adminWhereInput
    /**
     * Limit how many ib_admins to update.
     */
    limit?: number
  }

  /**
   * ib_admin updateManyAndReturn
   */
  export type ib_adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The data used to update ib_admins.
     */
    data: XOR<ib_adminUpdateManyMutationInput, ib_adminUncheckedUpdateManyInput>
    /**
     * Filter which ib_admins to update
     */
    where?: ib_adminWhereInput
    /**
     * Limit how many ib_admins to update.
     */
    limit?: number
  }

  /**
   * ib_admin upsert
   */
  export type ib_adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_admin to update in case it exists.
     */
    where: ib_adminWhereUniqueInput
    /**
     * In case the ib_admin found by the `where` argument doesn't exist, create a new ib_admin with this data.
     */
    create: XOR<ib_adminCreateInput, ib_adminUncheckedCreateInput>
    /**
     * In case the ib_admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_adminUpdateInput, ib_adminUncheckedUpdateInput>
  }

  /**
   * ib_admin delete
   */
  export type ib_adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
    /**
     * Filter which ib_admin to delete.
     */
    where: ib_adminWhereUniqueInput
  }

  /**
   * ib_admin deleteMany
   */
  export type ib_adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_admins to delete
     */
    where?: ib_adminWhereInput
    /**
     * Limit how many ib_admins to delete.
     */
    limit?: number
  }

  /**
   * ib_admin without action
   */
  export type ib_adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_admin
     */
    select?: ib_adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_admin
     */
    omit?: ib_adminOmit<ExtArgs> | null
  }


  /**
   * Model ib_requests
   */

  export type AggregateIb_requests = {
    _count: Ib_requestsCountAggregateOutputType | null
    _avg: Ib_requestsAvgAggregateOutputType | null
    _sum: Ib_requestsSumAggregateOutputType | null
    _min: Ib_requestsMinAggregateOutputType | null
    _max: Ib_requestsMaxAggregateOutputType | null
  }

  export type Ib_requestsAvgAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    structure_id: number | null
    referred_by: number | null
  }

  export type Ib_requestsSumAggregateOutputType = {
    id: number | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    structure_id: number | null
    referred_by: number | null
  }

  export type Ib_requestsMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password_hash: string | null
    status: string | null
    ib_type: string | null
    submitted_at: Date | null
    approved_at: Date | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    admin_comments: string | null
    group_id: string | null
    structure_id: number | null
    created_at: Date | null
    updated_at: Date | null
    referral_code: string | null
    referred_by: number | null
    country: string | null
  }

  export type Ib_requestsMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    email: string | null
    password_hash: string | null
    status: string | null
    ib_type: string | null
    submitted_at: Date | null
    approved_at: Date | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    admin_comments: string | null
    group_id: string | null
    structure_id: number | null
    created_at: Date | null
    updated_at: Date | null
    referral_code: string | null
    referred_by: number | null
    country: string | null
  }

  export type Ib_requestsCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    password_hash: number
    status: number
    ib_type: number
    submitted_at: number
    approved_at: number
    usd_per_lot: number
    spread_percentage_per_lot: number
    admin_comments: number
    group_id: number
    structure_id: number
    created_at: number
    updated_at: number
    referral_code: number
    referred_by: number
    country: number
    _all: number
  }


  export type Ib_requestsAvgAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    structure_id?: true
    referred_by?: true
  }

  export type Ib_requestsSumAggregateInputType = {
    id?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    structure_id?: true
    referred_by?: true
  }

  export type Ib_requestsMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    status?: true
    ib_type?: true
    submitted_at?: true
    approved_at?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    admin_comments?: true
    group_id?: true
    structure_id?: true
    created_at?: true
    updated_at?: true
    referral_code?: true
    referred_by?: true
    country?: true
  }

  export type Ib_requestsMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    status?: true
    ib_type?: true
    submitted_at?: true
    approved_at?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    admin_comments?: true
    group_id?: true
    structure_id?: true
    created_at?: true
    updated_at?: true
    referral_code?: true
    referred_by?: true
    country?: true
  }

  export type Ib_requestsCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    status?: true
    ib_type?: true
    submitted_at?: true
    approved_at?: true
    usd_per_lot?: true
    spread_percentage_per_lot?: true
    admin_comments?: true
    group_id?: true
    structure_id?: true
    created_at?: true
    updated_at?: true
    referral_code?: true
    referred_by?: true
    country?: true
    _all?: true
  }

  export type Ib_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_requests to aggregate.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_requests
    **/
    _count?: true | Ib_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_requestsMaxAggregateInputType
  }

  export type GetIb_requestsAggregateType<T extends Ib_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_requests[P]>
      : GetScalarType<T[P], AggregateIb_requests[P]>
  }




  export type ib_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_requestsWhereInput
    orderBy?: ib_requestsOrderByWithAggregationInput | ib_requestsOrderByWithAggregationInput[]
    by: Ib_requestsScalarFieldEnum[] | Ib_requestsScalarFieldEnum
    having?: ib_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_requestsCountAggregateInputType | true
    _avg?: Ib_requestsAvgAggregateInputType
    _sum?: Ib_requestsSumAggregateInputType
    _min?: Ib_requestsMinAggregateInputType
    _max?: Ib_requestsMaxAggregateInputType
  }

  export type Ib_requestsGroupByOutputType = {
    id: number
    full_name: string
    email: string
    password_hash: string
    status: string
    ib_type: string
    submitted_at: Date | null
    approved_at: Date | null
    usd_per_lot: Decimal | null
    spread_percentage_per_lot: Decimal | null
    admin_comments: string | null
    group_id: string | null
    structure_id: number | null
    created_at: Date | null
    updated_at: Date | null
    referral_code: string | null
    referred_by: number | null
    country: string | null
    _count: Ib_requestsCountAggregateOutputType | null
    _avg: Ib_requestsAvgAggregateOutputType | null
    _sum: Ib_requestsSumAggregateOutputType | null
    _min: Ib_requestsMinAggregateOutputType | null
    _max: Ib_requestsMaxAggregateOutputType | null
  }

  type GetIb_requestsGroupByPayload<T extends ib_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_requestsGroupByOutputType[P]>
        }
      >
    >


  export type ib_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    referral_code?: boolean
    referred_by?: boolean
    country?: boolean
    ib_group_assignments?: boolean | ib_requests$ib_group_assignmentsArgs<ExtArgs>
    _count?: boolean | Ib_requestsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ib_requests"]>

  export type ib_requestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    referral_code?: boolean
    referred_by?: boolean
    country?: boolean
  }, ExtArgs["result"]["ib_requests"]>

  export type ib_requestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    referral_code?: boolean
    referred_by?: boolean
    country?: boolean
  }, ExtArgs["result"]["ib_requests"]>

  export type ib_requestsSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    status?: boolean
    ib_type?: boolean
    submitted_at?: boolean
    approved_at?: boolean
    usd_per_lot?: boolean
    spread_percentage_per_lot?: boolean
    admin_comments?: boolean
    group_id?: boolean
    structure_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    referral_code?: boolean
    referred_by?: boolean
    country?: boolean
  }

  export type ib_requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "email" | "password_hash" | "status" | "ib_type" | "submitted_at" | "approved_at" | "usd_per_lot" | "spread_percentage_per_lot" | "admin_comments" | "group_id" | "structure_id" | "created_at" | "updated_at" | "referral_code" | "referred_by" | "country", ExtArgs["result"]["ib_requests"]>
  export type ib_requestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_group_assignments?: boolean | ib_requests$ib_group_assignmentsArgs<ExtArgs>
    _count?: boolean | Ib_requestsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ib_requestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ib_requestsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ib_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_requests"
    objects: {
      ib_group_assignments: Prisma.$ib_group_assignmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      email: string
      password_hash: string
      status: string
      ib_type: string
      submitted_at: Date | null
      approved_at: Date | null
      usd_per_lot: Prisma.Decimal | null
      spread_percentage_per_lot: Prisma.Decimal | null
      admin_comments: string | null
      group_id: string | null
      structure_id: number | null
      created_at: Date | null
      updated_at: Date | null
      referral_code: string | null
      referred_by: number | null
      country: string | null
    }, ExtArgs["result"]["ib_requests"]>
    composites: {}
  }

  type ib_requestsGetPayload<S extends boolean | null | undefined | ib_requestsDefaultArgs> = $Result.GetResult<Prisma.$ib_requestsPayload, S>

  type ib_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_requestsCountAggregateInputType | true
    }

  export interface ib_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_requests'], meta: { name: 'ib_requests' } }
    /**
     * Find zero or one Ib_requests that matches the filter.
     * @param {ib_requestsFindUniqueArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_requestsFindUniqueArgs>(args: SelectSubset<T, ib_requestsFindUniqueArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_requestsFindUniqueOrThrowArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsFindFirstArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_requestsFindFirstArgs>(args?: SelectSubset<T, ib_requestsFindFirstArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsFindFirstOrThrowArgs} args - Arguments to find a Ib_requests
     * @example
     * // Get one Ib_requests
     * const ib_requests = await prisma.ib_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_requests
     * const ib_requests = await prisma.ib_requests.findMany()
     * 
     * // Get first 10 Ib_requests
     * const ib_requests = await prisma.ib_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_requestsWithIdOnly = await prisma.ib_requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_requestsFindManyArgs>(args?: SelectSubset<T, ib_requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_requests.
     * @param {ib_requestsCreateArgs} args - Arguments to create a Ib_requests.
     * @example
     * // Create one Ib_requests
     * const Ib_requests = await prisma.ib_requests.create({
     *   data: {
     *     // ... data to create a Ib_requests
     *   }
     * })
     * 
     */
    create<T extends ib_requestsCreateArgs>(args: SelectSubset<T, ib_requestsCreateArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_requests.
     * @param {ib_requestsCreateManyArgs} args - Arguments to create many Ib_requests.
     * @example
     * // Create many Ib_requests
     * const ib_requests = await prisma.ib_requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_requestsCreateManyArgs>(args?: SelectSubset<T, ib_requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_requests and returns the data saved in the database.
     * @param {ib_requestsCreateManyAndReturnArgs} args - Arguments to create many Ib_requests.
     * @example
     * // Create many Ib_requests
     * const ib_requests = await prisma.ib_requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_requests and only return the `id`
     * const ib_requestsWithIdOnly = await prisma.ib_requests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_requestsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_requestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_requests.
     * @param {ib_requestsDeleteArgs} args - Arguments to delete one Ib_requests.
     * @example
     * // Delete one Ib_requests
     * const Ib_requests = await prisma.ib_requests.delete({
     *   where: {
     *     // ... filter to delete one Ib_requests
     *   }
     * })
     * 
     */
    delete<T extends ib_requestsDeleteArgs>(args: SelectSubset<T, ib_requestsDeleteArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_requests.
     * @param {ib_requestsUpdateArgs} args - Arguments to update one Ib_requests.
     * @example
     * // Update one Ib_requests
     * const ib_requests = await prisma.ib_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_requestsUpdateArgs>(args: SelectSubset<T, ib_requestsUpdateArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_requests.
     * @param {ib_requestsDeleteManyArgs} args - Arguments to filter Ib_requests to delete.
     * @example
     * // Delete a few Ib_requests
     * const { count } = await prisma.ib_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_requestsDeleteManyArgs>(args?: SelectSubset<T, ib_requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_requests
     * const ib_requests = await prisma.ib_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_requestsUpdateManyArgs>(args: SelectSubset<T, ib_requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_requests and returns the data updated in the database.
     * @param {ib_requestsUpdateManyAndReturnArgs} args - Arguments to update many Ib_requests.
     * @example
     * // Update many Ib_requests
     * const ib_requests = await prisma.ib_requests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_requests and only return the `id`
     * const ib_requestsWithIdOnly = await prisma.ib_requests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_requestsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_requestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_requests.
     * @param {ib_requestsUpsertArgs} args - Arguments to update or create a Ib_requests.
     * @example
     * // Update or create a Ib_requests
     * const ib_requests = await prisma.ib_requests.upsert({
     *   create: {
     *     // ... data to create a Ib_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_requests we want to update
     *   }
     * })
     */
    upsert<T extends ib_requestsUpsertArgs>(args: SelectSubset<T, ib_requestsUpsertArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsCountArgs} args - Arguments to filter Ib_requests to count.
     * @example
     * // Count the number of Ib_requests
     * const count = await prisma.ib_requests.count({
     *   where: {
     *     // ... the filter for the Ib_requests we want to count
     *   }
     * })
    **/
    count<T extends ib_requestsCountArgs>(
      args?: Subset<T, ib_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_requestsAggregateArgs>(args: Subset<T, Ib_requestsAggregateArgs>): Prisma.PrismaPromise<GetIb_requestsAggregateType<T>>

    /**
     * Group by Ib_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_requestsGroupByArgs['orderBy'] }
        : { orderBy?: ib_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_requests model
   */
  readonly fields: ib_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ib_group_assignments<T extends ib_requests$ib_group_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ib_requests$ib_group_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_requests model
   */
  interface ib_requestsFieldRefs {
    readonly id: FieldRef<"ib_requests", 'Int'>
    readonly full_name: FieldRef<"ib_requests", 'String'>
    readonly email: FieldRef<"ib_requests", 'String'>
    readonly password_hash: FieldRef<"ib_requests", 'String'>
    readonly status: FieldRef<"ib_requests", 'String'>
    readonly ib_type: FieldRef<"ib_requests", 'String'>
    readonly submitted_at: FieldRef<"ib_requests", 'DateTime'>
    readonly approved_at: FieldRef<"ib_requests", 'DateTime'>
    readonly usd_per_lot: FieldRef<"ib_requests", 'Decimal'>
    readonly spread_percentage_per_lot: FieldRef<"ib_requests", 'Decimal'>
    readonly admin_comments: FieldRef<"ib_requests", 'String'>
    readonly group_id: FieldRef<"ib_requests", 'String'>
    readonly structure_id: FieldRef<"ib_requests", 'Int'>
    readonly created_at: FieldRef<"ib_requests", 'DateTime'>
    readonly updated_at: FieldRef<"ib_requests", 'DateTime'>
    readonly referral_code: FieldRef<"ib_requests", 'String'>
    readonly referred_by: FieldRef<"ib_requests", 'Int'>
    readonly country: FieldRef<"ib_requests", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ib_requests findUnique
   */
  export type ib_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests findUniqueOrThrow
   */
  export type ib_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests findFirst
   */
  export type ib_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_requests.
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_requests.
     */
    distinct?: Ib_requestsScalarFieldEnum | Ib_requestsScalarFieldEnum[]
  }

  /**
   * ib_requests findFirstOrThrow
   */
  export type ib_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_requests.
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_requests.
     */
    distinct?: Ib_requestsScalarFieldEnum | Ib_requestsScalarFieldEnum[]
  }

  /**
   * ib_requests findMany
   */
  export type ib_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter, which ib_requests to fetch.
     */
    where?: ib_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_requests to fetch.
     */
    orderBy?: ib_requestsOrderByWithRelationInput | ib_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_requests.
     */
    cursor?: ib_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_requests.
     */
    skip?: number
    distinct?: Ib_requestsScalarFieldEnum | Ib_requestsScalarFieldEnum[]
  }

  /**
   * ib_requests create
   */
  export type ib_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * The data needed to create a ib_requests.
     */
    data: XOR<ib_requestsCreateInput, ib_requestsUncheckedCreateInput>
  }

  /**
   * ib_requests createMany
   */
  export type ib_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_requests.
     */
    data: ib_requestsCreateManyInput | ib_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_requests createManyAndReturn
   */
  export type ib_requestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_requests.
     */
    data: ib_requestsCreateManyInput | ib_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_requests update
   */
  export type ib_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * The data needed to update a ib_requests.
     */
    data: XOR<ib_requestsUpdateInput, ib_requestsUncheckedUpdateInput>
    /**
     * Choose, which ib_requests to update.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests updateMany
   */
  export type ib_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_requests.
     */
    data: XOR<ib_requestsUpdateManyMutationInput, ib_requestsUncheckedUpdateManyInput>
    /**
     * Filter which ib_requests to update
     */
    where?: ib_requestsWhereInput
    /**
     * Limit how many ib_requests to update.
     */
    limit?: number
  }

  /**
   * ib_requests updateManyAndReturn
   */
  export type ib_requestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * The data used to update ib_requests.
     */
    data: XOR<ib_requestsUpdateManyMutationInput, ib_requestsUncheckedUpdateManyInput>
    /**
     * Filter which ib_requests to update
     */
    where?: ib_requestsWhereInput
    /**
     * Limit how many ib_requests to update.
     */
    limit?: number
  }

  /**
   * ib_requests upsert
   */
  export type ib_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * The filter to search for the ib_requests to update in case it exists.
     */
    where: ib_requestsWhereUniqueInput
    /**
     * In case the ib_requests found by the `where` argument doesn't exist, create a new ib_requests with this data.
     */
    create: XOR<ib_requestsCreateInput, ib_requestsUncheckedCreateInput>
    /**
     * In case the ib_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_requestsUpdateInput, ib_requestsUncheckedUpdateInput>
  }

  /**
   * ib_requests delete
   */
  export type ib_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    /**
     * Filter which ib_requests to delete.
     */
    where: ib_requestsWhereUniqueInput
  }

  /**
   * ib_requests deleteMany
   */
  export type ib_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_requests to delete
     */
    where?: ib_requestsWhereInput
    /**
     * Limit how many ib_requests to delete.
     */
    limit?: number
  }

  /**
   * ib_requests.ib_group_assignments
   */
  export type ib_requests$ib_group_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    where?: ib_group_assignmentsWhereInput
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    cursor?: ib_group_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_requests without action
   */
  export type ib_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
  }


  /**
   * Model manual_gateway
   */

  export type AggregateManual_gateway = {
    _count: Manual_gatewayCountAggregateOutputType | null
    _avg: Manual_gatewayAvgAggregateOutputType | null
    _sum: Manual_gatewaySumAggregateOutputType | null
    _min: Manual_gatewayMinAggregateOutputType | null
    _max: Manual_gatewayMaxAggregateOutputType | null
  }

  export type Manual_gatewayAvgAggregateOutputType = {
    id: number | null
  }

  export type Manual_gatewaySumAggregateOutputType = {
    id: number | null
  }

  export type Manual_gatewayMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    details: string | null
    icon_url: string | null
    qr_code_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    vpa_address: string | null
    crypto_address: string | null
    bank_name: string | null
    account_name: string | null
    account_number: string | null
    ifsc_code: string | null
    swift_code: string | null
    account_type: string | null
    country_code: string | null
  }

  export type Manual_gatewayMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    details: string | null
    icon_url: string | null
    qr_code_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    vpa_address: string | null
    crypto_address: string | null
    bank_name: string | null
    account_name: string | null
    account_number: string | null
    ifsc_code: string | null
    swift_code: string | null
    account_type: string | null
    country_code: string | null
  }

  export type Manual_gatewayCountAggregateOutputType = {
    id: number
    type: number
    name: number
    details: number
    icon_url: number
    qr_code_url: number
    is_active: number
    created_at: number
    updated_at: number
    vpa_address: number
    crypto_address: number
    bank_name: number
    account_name: number
    account_number: number
    ifsc_code: number
    swift_code: number
    account_type: number
    country_code: number
    _all: number
  }


  export type Manual_gatewayAvgAggregateInputType = {
    id?: true
  }

  export type Manual_gatewaySumAggregateInputType = {
    id?: true
  }

  export type Manual_gatewayMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    details?: true
    icon_url?: true
    qr_code_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    vpa_address?: true
    crypto_address?: true
    bank_name?: true
    account_name?: true
    account_number?: true
    ifsc_code?: true
    swift_code?: true
    account_type?: true
    country_code?: true
  }

  export type Manual_gatewayMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    details?: true
    icon_url?: true
    qr_code_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    vpa_address?: true
    crypto_address?: true
    bank_name?: true
    account_name?: true
    account_number?: true
    ifsc_code?: true
    swift_code?: true
    account_type?: true
    country_code?: true
  }

  export type Manual_gatewayCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    details?: true
    icon_url?: true
    qr_code_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    vpa_address?: true
    crypto_address?: true
    bank_name?: true
    account_name?: true
    account_number?: true
    ifsc_code?: true
    swift_code?: true
    account_type?: true
    country_code?: true
    _all?: true
  }

  export type Manual_gatewayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_gateway to aggregate.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manual_gateways
    **/
    _count?: true | Manual_gatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Manual_gatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Manual_gatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Manual_gatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Manual_gatewayMaxAggregateInputType
  }

  export type GetManual_gatewayAggregateType<T extends Manual_gatewayAggregateArgs> = {
        [P in keyof T & keyof AggregateManual_gateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManual_gateway[P]>
      : GetScalarType<T[P], AggregateManual_gateway[P]>
  }




  export type manual_gatewayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manual_gatewayWhereInput
    orderBy?: manual_gatewayOrderByWithAggregationInput | manual_gatewayOrderByWithAggregationInput[]
    by: Manual_gatewayScalarFieldEnum[] | Manual_gatewayScalarFieldEnum
    having?: manual_gatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Manual_gatewayCountAggregateInputType | true
    _avg?: Manual_gatewayAvgAggregateInputType
    _sum?: Manual_gatewaySumAggregateInputType
    _min?: Manual_gatewayMinAggregateInputType
    _max?: Manual_gatewayMaxAggregateInputType
  }

  export type Manual_gatewayGroupByOutputType = {
    id: number
    type: string
    name: string
    details: string
    icon_url: string | null
    qr_code_url: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    vpa_address: string | null
    crypto_address: string | null
    bank_name: string | null
    account_name: string | null
    account_number: string | null
    ifsc_code: string | null
    swift_code: string | null
    account_type: string | null
    country_code: string | null
    _count: Manual_gatewayCountAggregateOutputType | null
    _avg: Manual_gatewayAvgAggregateOutputType | null
    _sum: Manual_gatewaySumAggregateOutputType | null
    _min: Manual_gatewayMinAggregateOutputType | null
    _max: Manual_gatewayMaxAggregateOutputType | null
  }

  type GetManual_gatewayGroupByPayload<T extends manual_gatewayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Manual_gatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Manual_gatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Manual_gatewayGroupByOutputType[P]>
            : GetScalarType<T[P], Manual_gatewayGroupByOutputType[P]>
        }
      >
    >


  export type manual_gatewaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vpa_address?: boolean
    crypto_address?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    ifsc_code?: boolean
    swift_code?: boolean
    account_type?: boolean
    country_code?: boolean
  }, ExtArgs["result"]["manual_gateway"]>

  export type manual_gatewaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vpa_address?: boolean
    crypto_address?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    ifsc_code?: boolean
    swift_code?: boolean
    account_type?: boolean
    country_code?: boolean
  }, ExtArgs["result"]["manual_gateway"]>

  export type manual_gatewaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vpa_address?: boolean
    crypto_address?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    ifsc_code?: boolean
    swift_code?: boolean
    account_type?: boolean
    country_code?: boolean
  }, ExtArgs["result"]["manual_gateway"]>

  export type manual_gatewaySelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    details?: boolean
    icon_url?: boolean
    qr_code_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    vpa_address?: boolean
    crypto_address?: boolean
    bank_name?: boolean
    account_name?: boolean
    account_number?: boolean
    ifsc_code?: boolean
    swift_code?: boolean
    account_type?: boolean
    country_code?: boolean
  }

  export type manual_gatewayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "details" | "icon_url" | "qr_code_url" | "is_active" | "created_at" | "updated_at" | "vpa_address" | "crypto_address" | "bank_name" | "account_name" | "account_number" | "ifsc_code" | "swift_code" | "account_type" | "country_code", ExtArgs["result"]["manual_gateway"]>

  export type $manual_gatewayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manual_gateway"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      name: string
      details: string
      icon_url: string | null
      qr_code_url: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
      vpa_address: string | null
      crypto_address: string | null
      bank_name: string | null
      account_name: string | null
      account_number: string | null
      ifsc_code: string | null
      swift_code: string | null
      account_type: string | null
      country_code: string | null
    }, ExtArgs["result"]["manual_gateway"]>
    composites: {}
  }

  type manual_gatewayGetPayload<S extends boolean | null | undefined | manual_gatewayDefaultArgs> = $Result.GetResult<Prisma.$manual_gatewayPayload, S>

  type manual_gatewayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<manual_gatewayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Manual_gatewayCountAggregateInputType | true
    }

  export interface manual_gatewayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manual_gateway'], meta: { name: 'manual_gateway' } }
    /**
     * Find zero or one Manual_gateway that matches the filter.
     * @param {manual_gatewayFindUniqueArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends manual_gatewayFindUniqueArgs>(args: SelectSubset<T, manual_gatewayFindUniqueArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manual_gateway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {manual_gatewayFindUniqueOrThrowArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends manual_gatewayFindUniqueOrThrowArgs>(args: SelectSubset<T, manual_gatewayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manual_gateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayFindFirstArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends manual_gatewayFindFirstArgs>(args?: SelectSubset<T, manual_gatewayFindFirstArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manual_gateway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayFindFirstOrThrowArgs} args - Arguments to find a Manual_gateway
     * @example
     * // Get one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends manual_gatewayFindFirstOrThrowArgs>(args?: SelectSubset<T, manual_gatewayFindFirstOrThrowArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manual_gateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manual_gateways
     * const manual_gateways = await prisma.manual_gateway.findMany()
     * 
     * // Get first 10 Manual_gateways
     * const manual_gateways = await prisma.manual_gateway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manual_gatewayWithIdOnly = await prisma.manual_gateway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends manual_gatewayFindManyArgs>(args?: SelectSubset<T, manual_gatewayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manual_gateway.
     * @param {manual_gatewayCreateArgs} args - Arguments to create a Manual_gateway.
     * @example
     * // Create one Manual_gateway
     * const Manual_gateway = await prisma.manual_gateway.create({
     *   data: {
     *     // ... data to create a Manual_gateway
     *   }
     * })
     * 
     */
    create<T extends manual_gatewayCreateArgs>(args: SelectSubset<T, manual_gatewayCreateArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manual_gateways.
     * @param {manual_gatewayCreateManyArgs} args - Arguments to create many Manual_gateways.
     * @example
     * // Create many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends manual_gatewayCreateManyArgs>(args?: SelectSubset<T, manual_gatewayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Manual_gateways and returns the data saved in the database.
     * @param {manual_gatewayCreateManyAndReturnArgs} args - Arguments to create many Manual_gateways.
     * @example
     * // Create many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Manual_gateways and only return the `id`
     * const manual_gatewayWithIdOnly = await prisma.manual_gateway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends manual_gatewayCreateManyAndReturnArgs>(args?: SelectSubset<T, manual_gatewayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manual_gateway.
     * @param {manual_gatewayDeleteArgs} args - Arguments to delete one Manual_gateway.
     * @example
     * // Delete one Manual_gateway
     * const Manual_gateway = await prisma.manual_gateway.delete({
     *   where: {
     *     // ... filter to delete one Manual_gateway
     *   }
     * })
     * 
     */
    delete<T extends manual_gatewayDeleteArgs>(args: SelectSubset<T, manual_gatewayDeleteArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manual_gateway.
     * @param {manual_gatewayUpdateArgs} args - Arguments to update one Manual_gateway.
     * @example
     * // Update one Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends manual_gatewayUpdateArgs>(args: SelectSubset<T, manual_gatewayUpdateArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manual_gateways.
     * @param {manual_gatewayDeleteManyArgs} args - Arguments to filter Manual_gateways to delete.
     * @example
     * // Delete a few Manual_gateways
     * const { count } = await prisma.manual_gateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends manual_gatewayDeleteManyArgs>(args?: SelectSubset<T, manual_gatewayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manual_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends manual_gatewayUpdateManyArgs>(args: SelectSubset<T, manual_gatewayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manual_gateways and returns the data updated in the database.
     * @param {manual_gatewayUpdateManyAndReturnArgs} args - Arguments to update many Manual_gateways.
     * @example
     * // Update many Manual_gateways
     * const manual_gateway = await prisma.manual_gateway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Manual_gateways and only return the `id`
     * const manual_gatewayWithIdOnly = await prisma.manual_gateway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends manual_gatewayUpdateManyAndReturnArgs>(args: SelectSubset<T, manual_gatewayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manual_gateway.
     * @param {manual_gatewayUpsertArgs} args - Arguments to update or create a Manual_gateway.
     * @example
     * // Update or create a Manual_gateway
     * const manual_gateway = await prisma.manual_gateway.upsert({
     *   create: {
     *     // ... data to create a Manual_gateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manual_gateway we want to update
     *   }
     * })
     */
    upsert<T extends manual_gatewayUpsertArgs>(args: SelectSubset<T, manual_gatewayUpsertArgs<ExtArgs>>): Prisma__manual_gatewayClient<$Result.GetResult<Prisma.$manual_gatewayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manual_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayCountArgs} args - Arguments to filter Manual_gateways to count.
     * @example
     * // Count the number of Manual_gateways
     * const count = await prisma.manual_gateway.count({
     *   where: {
     *     // ... the filter for the Manual_gateways we want to count
     *   }
     * })
    **/
    count<T extends manual_gatewayCountArgs>(
      args?: Subset<T, manual_gatewayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Manual_gatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manual_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Manual_gatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Manual_gatewayAggregateArgs>(args: Subset<T, Manual_gatewayAggregateArgs>): Prisma.PrismaPromise<GetManual_gatewayAggregateType<T>>

    /**
     * Group by Manual_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_gatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manual_gatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manual_gatewayGroupByArgs['orderBy'] }
        : { orderBy?: manual_gatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manual_gatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManual_gatewayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manual_gateway model
   */
  readonly fields: manual_gatewayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manual_gateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manual_gatewayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the manual_gateway model
   */
  interface manual_gatewayFieldRefs {
    readonly id: FieldRef<"manual_gateway", 'Int'>
    readonly type: FieldRef<"manual_gateway", 'String'>
    readonly name: FieldRef<"manual_gateway", 'String'>
    readonly details: FieldRef<"manual_gateway", 'String'>
    readonly icon_url: FieldRef<"manual_gateway", 'String'>
    readonly qr_code_url: FieldRef<"manual_gateway", 'String'>
    readonly is_active: FieldRef<"manual_gateway", 'Boolean'>
    readonly created_at: FieldRef<"manual_gateway", 'DateTime'>
    readonly updated_at: FieldRef<"manual_gateway", 'DateTime'>
    readonly vpa_address: FieldRef<"manual_gateway", 'String'>
    readonly crypto_address: FieldRef<"manual_gateway", 'String'>
    readonly bank_name: FieldRef<"manual_gateway", 'String'>
    readonly account_name: FieldRef<"manual_gateway", 'String'>
    readonly account_number: FieldRef<"manual_gateway", 'String'>
    readonly ifsc_code: FieldRef<"manual_gateway", 'String'>
    readonly swift_code: FieldRef<"manual_gateway", 'String'>
    readonly account_type: FieldRef<"manual_gateway", 'String'>
    readonly country_code: FieldRef<"manual_gateway", 'String'>
  }
    

  // Custom InputTypes
  /**
   * manual_gateway findUnique
   */
  export type manual_gatewayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway findUniqueOrThrow
   */
  export type manual_gatewayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway findFirst
   */
  export type manual_gatewayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_gateways.
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_gateways.
     */
    distinct?: Manual_gatewayScalarFieldEnum | Manual_gatewayScalarFieldEnum[]
  }

  /**
   * manual_gateway findFirstOrThrow
   */
  export type manual_gatewayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateway to fetch.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_gateways.
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_gateways.
     */
    distinct?: Manual_gatewayScalarFieldEnum | Manual_gatewayScalarFieldEnum[]
  }

  /**
   * manual_gateway findMany
   */
  export type manual_gatewayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which manual_gateways to fetch.
     */
    where?: manual_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_gateways to fetch.
     */
    orderBy?: manual_gatewayOrderByWithRelationInput | manual_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manual_gateways.
     */
    cursor?: manual_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_gateways.
     */
    skip?: number
    distinct?: Manual_gatewayScalarFieldEnum | Manual_gatewayScalarFieldEnum[]
  }

  /**
   * manual_gateway create
   */
  export type manual_gatewayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to create a manual_gateway.
     */
    data: XOR<manual_gatewayCreateInput, manual_gatewayUncheckedCreateInput>
  }

  /**
   * manual_gateway createMany
   */
  export type manual_gatewayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manual_gateways.
     */
    data: manual_gatewayCreateManyInput | manual_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manual_gateway createManyAndReturn
   */
  export type manual_gatewayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data used to create many manual_gateways.
     */
    data: manual_gatewayCreateManyInput | manual_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manual_gateway update
   */
  export type manual_gatewayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to update a manual_gateway.
     */
    data: XOR<manual_gatewayUpdateInput, manual_gatewayUncheckedUpdateInput>
    /**
     * Choose, which manual_gateway to update.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway updateMany
   */
  export type manual_gatewayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manual_gateways.
     */
    data: XOR<manual_gatewayUpdateManyMutationInput, manual_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which manual_gateways to update
     */
    where?: manual_gatewayWhereInput
    /**
     * Limit how many manual_gateways to update.
     */
    limit?: number
  }

  /**
   * manual_gateway updateManyAndReturn
   */
  export type manual_gatewayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The data used to update manual_gateways.
     */
    data: XOR<manual_gatewayUpdateManyMutationInput, manual_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which manual_gateways to update
     */
    where?: manual_gatewayWhereInput
    /**
     * Limit how many manual_gateways to update.
     */
    limit?: number
  }

  /**
   * manual_gateway upsert
   */
  export type manual_gatewayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * The filter to search for the manual_gateway to update in case it exists.
     */
    where: manual_gatewayWhereUniqueInput
    /**
     * In case the manual_gateway found by the `where` argument doesn't exist, create a new manual_gateway with this data.
     */
    create: XOR<manual_gatewayCreateInput, manual_gatewayUncheckedCreateInput>
    /**
     * In case the manual_gateway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manual_gatewayUpdateInput, manual_gatewayUncheckedUpdateInput>
  }

  /**
   * manual_gateway delete
   */
  export type manual_gatewayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
    /**
     * Filter which manual_gateway to delete.
     */
    where: manual_gatewayWhereUniqueInput
  }

  /**
   * manual_gateway deleteMany
   */
  export type manual_gatewayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_gateways to delete
     */
    where?: manual_gatewayWhereInput
    /**
     * Limit how many manual_gateways to delete.
     */
    limit?: number
  }

  /**
   * manual_gateway without action
   */
  export type manual_gatewayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_gateway
     */
    select?: manual_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the manual_gateway
     */
    omit?: manual_gatewayOmit<ExtArgs> | null
  }


  /**
   * Model mt5_groups
   */

  export type AggregateMt5_groups = {
    _count: Mt5_groupsCountAggregateOutputType | null
    _avg: Mt5_groupsAvgAggregateOutputType | null
    _sum: Mt5_groupsSumAggregateOutputType | null
    _min: Mt5_groupsMinAggregateOutputType | null
    _max: Mt5_groupsMaxAggregateOutputType | null
  }

  export type Mt5_groupsAvgAggregateOutputType = {
    id: number | null
  }

  export type Mt5_groupsSumAggregateOutputType = {
    id: number | null
  }

  export type Mt5_groupsMinAggregateOutputType = {
    id: number | null
    group_id: string | null
    name: string | null
    description: string | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Mt5_groupsMaxAggregateOutputType = {
    id: number | null
    group_id: string | null
    name: string | null
    description: string | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Mt5_groupsCountAggregateOutputType = {
    id: number
    group_id: number
    name: number
    description: number
    synced_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Mt5_groupsAvgAggregateInputType = {
    id?: true
  }

  export type Mt5_groupsSumAggregateInputType = {
    id?: true
  }

  export type Mt5_groupsMinAggregateInputType = {
    id?: true
    group_id?: true
    name?: true
    description?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Mt5_groupsMaxAggregateInputType = {
    id?: true
    group_id?: true
    name?: true
    description?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Mt5_groupsCountAggregateInputType = {
    id?: true
    group_id?: true
    name?: true
    description?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Mt5_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mt5_groups to aggregate.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mt5_groups
    **/
    _count?: true | Mt5_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mt5_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mt5_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mt5_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mt5_groupsMaxAggregateInputType
  }

  export type GetMt5_groupsAggregateType<T extends Mt5_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateMt5_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMt5_groups[P]>
      : GetScalarType<T[P], AggregateMt5_groups[P]>
  }




  export type mt5_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mt5_groupsWhereInput
    orderBy?: mt5_groupsOrderByWithAggregationInput | mt5_groupsOrderByWithAggregationInput[]
    by: Mt5_groupsScalarFieldEnum[] | Mt5_groupsScalarFieldEnum
    having?: mt5_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mt5_groupsCountAggregateInputType | true
    _avg?: Mt5_groupsAvgAggregateInputType
    _sum?: Mt5_groupsSumAggregateInputType
    _min?: Mt5_groupsMinAggregateInputType
    _max?: Mt5_groupsMaxAggregateInputType
  }

  export type Mt5_groupsGroupByOutputType = {
    id: number
    group_id: string
    name: string
    description: string | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Mt5_groupsCountAggregateOutputType | null
    _avg: Mt5_groupsAvgAggregateOutputType | null
    _sum: Mt5_groupsSumAggregateOutputType | null
    _min: Mt5_groupsMinAggregateOutputType | null
    _max: Mt5_groupsMaxAggregateOutputType | null
  }

  type GetMt5_groupsGroupByPayload<T extends mt5_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mt5_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mt5_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mt5_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Mt5_groupsGroupByOutputType[P]>
        }
      >
    >


  export type mt5_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mt5_groups"]>

  export type mt5_groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mt5_groups"]>

  export type mt5_groupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mt5_groups"]>

  export type mt5_groupsSelectScalar = {
    id?: boolean
    group_id?: boolean
    name?: boolean
    description?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type mt5_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "group_id" | "name" | "description" | "synced_at" | "created_at" | "updated_at", ExtArgs["result"]["mt5_groups"]>

  export type $mt5_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mt5_groups"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      group_id: string
      name: string
      description: string | null
      synced_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["mt5_groups"]>
    composites: {}
  }

  type mt5_groupsGetPayload<S extends boolean | null | undefined | mt5_groupsDefaultArgs> = $Result.GetResult<Prisma.$mt5_groupsPayload, S>

  type mt5_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mt5_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mt5_groupsCountAggregateInputType | true
    }

  export interface mt5_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mt5_groups'], meta: { name: 'mt5_groups' } }
    /**
     * Find zero or one Mt5_groups that matches the filter.
     * @param {mt5_groupsFindUniqueArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mt5_groupsFindUniqueArgs>(args: SelectSubset<T, mt5_groupsFindUniqueArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mt5_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mt5_groupsFindUniqueOrThrowArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mt5_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, mt5_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mt5_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsFindFirstArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mt5_groupsFindFirstArgs>(args?: SelectSubset<T, mt5_groupsFindFirstArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mt5_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsFindFirstOrThrowArgs} args - Arguments to find a Mt5_groups
     * @example
     * // Get one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mt5_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, mt5_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mt5_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findMany()
     * 
     * // Get first 10 Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mt5_groupsWithIdOnly = await prisma.mt5_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mt5_groupsFindManyArgs>(args?: SelectSubset<T, mt5_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mt5_groups.
     * @param {mt5_groupsCreateArgs} args - Arguments to create a Mt5_groups.
     * @example
     * // Create one Mt5_groups
     * const Mt5_groups = await prisma.mt5_groups.create({
     *   data: {
     *     // ... data to create a Mt5_groups
     *   }
     * })
     * 
     */
    create<T extends mt5_groupsCreateArgs>(args: SelectSubset<T, mt5_groupsCreateArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mt5_groups.
     * @param {mt5_groupsCreateManyArgs} args - Arguments to create many Mt5_groups.
     * @example
     * // Create many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mt5_groupsCreateManyArgs>(args?: SelectSubset<T, mt5_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mt5_groups and returns the data saved in the database.
     * @param {mt5_groupsCreateManyAndReturnArgs} args - Arguments to create many Mt5_groups.
     * @example
     * // Create many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mt5_groups and only return the `id`
     * const mt5_groupsWithIdOnly = await prisma.mt5_groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mt5_groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, mt5_groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mt5_groups.
     * @param {mt5_groupsDeleteArgs} args - Arguments to delete one Mt5_groups.
     * @example
     * // Delete one Mt5_groups
     * const Mt5_groups = await prisma.mt5_groups.delete({
     *   where: {
     *     // ... filter to delete one Mt5_groups
     *   }
     * })
     * 
     */
    delete<T extends mt5_groupsDeleteArgs>(args: SelectSubset<T, mt5_groupsDeleteArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mt5_groups.
     * @param {mt5_groupsUpdateArgs} args - Arguments to update one Mt5_groups.
     * @example
     * // Update one Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mt5_groupsUpdateArgs>(args: SelectSubset<T, mt5_groupsUpdateArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mt5_groups.
     * @param {mt5_groupsDeleteManyArgs} args - Arguments to filter Mt5_groups to delete.
     * @example
     * // Delete a few Mt5_groups
     * const { count } = await prisma.mt5_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mt5_groupsDeleteManyArgs>(args?: SelectSubset<T, mt5_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mt5_groupsUpdateManyArgs>(args: SelectSubset<T, mt5_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mt5_groups and returns the data updated in the database.
     * @param {mt5_groupsUpdateManyAndReturnArgs} args - Arguments to update many Mt5_groups.
     * @example
     * // Update many Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mt5_groups and only return the `id`
     * const mt5_groupsWithIdOnly = await prisma.mt5_groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mt5_groupsUpdateManyAndReturnArgs>(args: SelectSubset<T, mt5_groupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mt5_groups.
     * @param {mt5_groupsUpsertArgs} args - Arguments to update or create a Mt5_groups.
     * @example
     * // Update or create a Mt5_groups
     * const mt5_groups = await prisma.mt5_groups.upsert({
     *   create: {
     *     // ... data to create a Mt5_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mt5_groups we want to update
     *   }
     * })
     */
    upsert<T extends mt5_groupsUpsertArgs>(args: SelectSubset<T, mt5_groupsUpsertArgs<ExtArgs>>): Prisma__mt5_groupsClient<$Result.GetResult<Prisma.$mt5_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsCountArgs} args - Arguments to filter Mt5_groups to count.
     * @example
     * // Count the number of Mt5_groups
     * const count = await prisma.mt5_groups.count({
     *   where: {
     *     // ... the filter for the Mt5_groups we want to count
     *   }
     * })
    **/
    count<T extends mt5_groupsCountArgs>(
      args?: Subset<T, mt5_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mt5_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mt5_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mt5_groupsAggregateArgs>(args: Subset<T, Mt5_groupsAggregateArgs>): Prisma.PrismaPromise<GetMt5_groupsAggregateType<T>>

    /**
     * Group by Mt5_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mt5_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mt5_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mt5_groupsGroupByArgs['orderBy'] }
        : { orderBy?: mt5_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mt5_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMt5_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mt5_groups model
   */
  readonly fields: mt5_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mt5_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mt5_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mt5_groups model
   */
  interface mt5_groupsFieldRefs {
    readonly id: FieldRef<"mt5_groups", 'Int'>
    readonly group_id: FieldRef<"mt5_groups", 'String'>
    readonly name: FieldRef<"mt5_groups", 'String'>
    readonly description: FieldRef<"mt5_groups", 'String'>
    readonly synced_at: FieldRef<"mt5_groups", 'DateTime'>
    readonly created_at: FieldRef<"mt5_groups", 'DateTime'>
    readonly updated_at: FieldRef<"mt5_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mt5_groups findUnique
   */
  export type mt5_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups findUniqueOrThrow
   */
  export type mt5_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups findFirst
   */
  export type mt5_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mt5_groups.
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mt5_groups.
     */
    distinct?: Mt5_groupsScalarFieldEnum | Mt5_groupsScalarFieldEnum[]
  }

  /**
   * mt5_groups findFirstOrThrow
   */
  export type mt5_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mt5_groups.
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mt5_groups.
     */
    distinct?: Mt5_groupsScalarFieldEnum | Mt5_groupsScalarFieldEnum[]
  }

  /**
   * mt5_groups findMany
   */
  export type mt5_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter, which mt5_groups to fetch.
     */
    where?: mt5_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mt5_groups to fetch.
     */
    orderBy?: mt5_groupsOrderByWithRelationInput | mt5_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mt5_groups.
     */
    cursor?: mt5_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mt5_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mt5_groups.
     */
    skip?: number
    distinct?: Mt5_groupsScalarFieldEnum | Mt5_groupsScalarFieldEnum[]
  }

  /**
   * mt5_groups create
   */
  export type mt5_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data needed to create a mt5_groups.
     */
    data: XOR<mt5_groupsCreateInput, mt5_groupsUncheckedCreateInput>
  }

  /**
   * mt5_groups createMany
   */
  export type mt5_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mt5_groups.
     */
    data: mt5_groupsCreateManyInput | mt5_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mt5_groups createManyAndReturn
   */
  export type mt5_groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data used to create many mt5_groups.
     */
    data: mt5_groupsCreateManyInput | mt5_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mt5_groups update
   */
  export type mt5_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data needed to update a mt5_groups.
     */
    data: XOR<mt5_groupsUpdateInput, mt5_groupsUncheckedUpdateInput>
    /**
     * Choose, which mt5_groups to update.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups updateMany
   */
  export type mt5_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mt5_groups.
     */
    data: XOR<mt5_groupsUpdateManyMutationInput, mt5_groupsUncheckedUpdateManyInput>
    /**
     * Filter which mt5_groups to update
     */
    where?: mt5_groupsWhereInput
    /**
     * Limit how many mt5_groups to update.
     */
    limit?: number
  }

  /**
   * mt5_groups updateManyAndReturn
   */
  export type mt5_groupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The data used to update mt5_groups.
     */
    data: XOR<mt5_groupsUpdateManyMutationInput, mt5_groupsUncheckedUpdateManyInput>
    /**
     * Filter which mt5_groups to update
     */
    where?: mt5_groupsWhereInput
    /**
     * Limit how many mt5_groups to update.
     */
    limit?: number
  }

  /**
   * mt5_groups upsert
   */
  export type mt5_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * The filter to search for the mt5_groups to update in case it exists.
     */
    where: mt5_groupsWhereUniqueInput
    /**
     * In case the mt5_groups found by the `where` argument doesn't exist, create a new mt5_groups with this data.
     */
    create: XOR<mt5_groupsCreateInput, mt5_groupsUncheckedCreateInput>
    /**
     * In case the mt5_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mt5_groupsUpdateInput, mt5_groupsUncheckedUpdateInput>
  }

  /**
   * mt5_groups delete
   */
  export type mt5_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
    /**
     * Filter which mt5_groups to delete.
     */
    where: mt5_groupsWhereUniqueInput
  }

  /**
   * mt5_groups deleteMany
   */
  export type mt5_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mt5_groups to delete
     */
    where?: mt5_groupsWhereInput
    /**
     * Limit how many mt5_groups to delete.
     */
    limit?: number
  }

  /**
   * mt5_groups without action
   */
  export type mt5_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mt5_groups
     */
    select?: mt5_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mt5_groups
     */
    omit?: mt5_groupsOmit<ExtArgs> | null
  }


  /**
   * Model payment_gateway
   */

  export type AggregatePayment_gateway = {
    _count: Payment_gatewayCountAggregateOutputType | null
    _avg: Payment_gatewayAvgAggregateOutputType | null
    _sum: Payment_gatewaySumAggregateOutputType | null
    _min: Payment_gatewayMinAggregateOutputType | null
    _max: Payment_gatewayMaxAggregateOutputType | null
  }

  export type Payment_gatewayAvgAggregateOutputType = {
    id: number | null
  }

  export type Payment_gatewaySumAggregateOutputType = {
    id: number | null
  }

  export type Payment_gatewayMinAggregateOutputType = {
    id: number | null
    wallet_name: string | null
    deposit_wallet_address: string | null
    api_key: string | null
    secret_key: string | null
    gateway_type: string | null
    is_active: boolean | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_gatewayMaxAggregateOutputType = {
    id: number | null
    wallet_name: string | null
    deposit_wallet_address: string | null
    api_key: string | null
    secret_key: string | null
    gateway_type: string | null
    is_active: boolean | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_gatewayCountAggregateOutputType = {
    id: number
    wallet_name: number
    deposit_wallet_address: number
    api_key: number
    secret_key: number
    gateway_type: number
    is_active: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Payment_gatewayAvgAggregateInputType = {
    id?: true
  }

  export type Payment_gatewaySumAggregateInputType = {
    id?: true
  }

  export type Payment_gatewayMinAggregateInputType = {
    id?: true
    wallet_name?: true
    deposit_wallet_address?: true
    api_key?: true
    secret_key?: true
    gateway_type?: true
    is_active?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_gatewayMaxAggregateInputType = {
    id?: true
    wallet_name?: true
    deposit_wallet_address?: true
    api_key?: true
    secret_key?: true
    gateway_type?: true
    is_active?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_gatewayCountAggregateInputType = {
    id?: true
    wallet_name?: true
    deposit_wallet_address?: true
    api_key?: true
    secret_key?: true
    gateway_type?: true
    is_active?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Payment_gatewayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_gateway to aggregate.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_gateways
    **/
    _count?: true | Payment_gatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_gatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_gatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_gatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_gatewayMaxAggregateInputType
  }

  export type GetPayment_gatewayAggregateType<T extends Payment_gatewayAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_gateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_gateway[P]>
      : GetScalarType<T[P], AggregatePayment_gateway[P]>
  }




  export type payment_gatewayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_gatewayWhereInput
    orderBy?: payment_gatewayOrderByWithAggregationInput | payment_gatewayOrderByWithAggregationInput[]
    by: Payment_gatewayScalarFieldEnum[] | Payment_gatewayScalarFieldEnum
    having?: payment_gatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_gatewayCountAggregateInputType | true
    _avg?: Payment_gatewayAvgAggregateInputType
    _sum?: Payment_gatewaySumAggregateInputType
    _min?: Payment_gatewayMinAggregateInputType
    _max?: Payment_gatewayMaxAggregateInputType
  }

  export type Payment_gatewayGroupByOutputType = {
    id: number
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active: boolean
    description: string | null
    created_at: Date
    updated_at: Date
    _count: Payment_gatewayCountAggregateOutputType | null
    _avg: Payment_gatewayAvgAggregateOutputType | null
    _sum: Payment_gatewaySumAggregateOutputType | null
    _min: Payment_gatewayMinAggregateOutputType | null
    _max: Payment_gatewayMaxAggregateOutputType | null
  }

  type GetPayment_gatewayGroupByPayload<T extends payment_gatewayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_gatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_gatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_gatewayGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_gatewayGroupByOutputType[P]>
        }
      >
    >


  export type payment_gatewaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_gateway"]>

  export type payment_gatewaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_gateway"]>

  export type payment_gatewaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payment_gateway"]>

  export type payment_gatewaySelectScalar = {
    id?: boolean
    wallet_name?: boolean
    deposit_wallet_address?: boolean
    api_key?: boolean
    secret_key?: boolean
    gateway_type?: boolean
    is_active?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type payment_gatewayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wallet_name" | "deposit_wallet_address" | "api_key" | "secret_key" | "gateway_type" | "is_active" | "description" | "created_at" | "updated_at", ExtArgs["result"]["payment_gateway"]>

  export type $payment_gatewayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_gateway"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wallet_name: string
      deposit_wallet_address: string
      api_key: string
      secret_key: string
      gateway_type: string
      is_active: boolean
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payment_gateway"]>
    composites: {}
  }

  type payment_gatewayGetPayload<S extends boolean | null | undefined | payment_gatewayDefaultArgs> = $Result.GetResult<Prisma.$payment_gatewayPayload, S>

  type payment_gatewayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_gatewayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_gatewayCountAggregateInputType | true
    }

  export interface payment_gatewayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_gateway'], meta: { name: 'payment_gateway' } }
    /**
     * Find zero or one Payment_gateway that matches the filter.
     * @param {payment_gatewayFindUniqueArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_gatewayFindUniqueArgs>(args: SelectSubset<T, payment_gatewayFindUniqueArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_gateway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_gatewayFindUniqueOrThrowArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_gatewayFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_gatewayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_gateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayFindFirstArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_gatewayFindFirstArgs>(args?: SelectSubset<T, payment_gatewayFindFirstArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_gateway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayFindFirstOrThrowArgs} args - Arguments to find a Payment_gateway
     * @example
     * // Get one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_gatewayFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_gatewayFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_gateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_gateways
     * const payment_gateways = await prisma.payment_gateway.findMany()
     * 
     * // Get first 10 Payment_gateways
     * const payment_gateways = await prisma.payment_gateway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_gatewayWithIdOnly = await prisma.payment_gateway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_gatewayFindManyArgs>(args?: SelectSubset<T, payment_gatewayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_gateway.
     * @param {payment_gatewayCreateArgs} args - Arguments to create a Payment_gateway.
     * @example
     * // Create one Payment_gateway
     * const Payment_gateway = await prisma.payment_gateway.create({
     *   data: {
     *     // ... data to create a Payment_gateway
     *   }
     * })
     * 
     */
    create<T extends payment_gatewayCreateArgs>(args: SelectSubset<T, payment_gatewayCreateArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_gateways.
     * @param {payment_gatewayCreateManyArgs} args - Arguments to create many Payment_gateways.
     * @example
     * // Create many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_gatewayCreateManyArgs>(args?: SelectSubset<T, payment_gatewayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_gateways and returns the data saved in the database.
     * @param {payment_gatewayCreateManyAndReturnArgs} args - Arguments to create many Payment_gateways.
     * @example
     * // Create many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_gateways and only return the `id`
     * const payment_gatewayWithIdOnly = await prisma.payment_gateway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_gatewayCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_gatewayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_gateway.
     * @param {payment_gatewayDeleteArgs} args - Arguments to delete one Payment_gateway.
     * @example
     * // Delete one Payment_gateway
     * const Payment_gateway = await prisma.payment_gateway.delete({
     *   where: {
     *     // ... filter to delete one Payment_gateway
     *   }
     * })
     * 
     */
    delete<T extends payment_gatewayDeleteArgs>(args: SelectSubset<T, payment_gatewayDeleteArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_gateway.
     * @param {payment_gatewayUpdateArgs} args - Arguments to update one Payment_gateway.
     * @example
     * // Update one Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_gatewayUpdateArgs>(args: SelectSubset<T, payment_gatewayUpdateArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_gateways.
     * @param {payment_gatewayDeleteManyArgs} args - Arguments to filter Payment_gateways to delete.
     * @example
     * // Delete a few Payment_gateways
     * const { count } = await prisma.payment_gateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_gatewayDeleteManyArgs>(args?: SelectSubset<T, payment_gatewayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_gatewayUpdateManyArgs>(args: SelectSubset<T, payment_gatewayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_gateways and returns the data updated in the database.
     * @param {payment_gatewayUpdateManyAndReturnArgs} args - Arguments to update many Payment_gateways.
     * @example
     * // Update many Payment_gateways
     * const payment_gateway = await prisma.payment_gateway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_gateways and only return the `id`
     * const payment_gatewayWithIdOnly = await prisma.payment_gateway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_gatewayUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_gatewayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_gateway.
     * @param {payment_gatewayUpsertArgs} args - Arguments to update or create a Payment_gateway.
     * @example
     * // Update or create a Payment_gateway
     * const payment_gateway = await prisma.payment_gateway.upsert({
     *   create: {
     *     // ... data to create a Payment_gateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_gateway we want to update
     *   }
     * })
     */
    upsert<T extends payment_gatewayUpsertArgs>(args: SelectSubset<T, payment_gatewayUpsertArgs<ExtArgs>>): Prisma__payment_gatewayClient<$Result.GetResult<Prisma.$payment_gatewayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayCountArgs} args - Arguments to filter Payment_gateways to count.
     * @example
     * // Count the number of Payment_gateways
     * const count = await prisma.payment_gateway.count({
     *   where: {
     *     // ... the filter for the Payment_gateways we want to count
     *   }
     * })
    **/
    count<T extends payment_gatewayCountArgs>(
      args?: Subset<T, payment_gatewayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_gatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_gatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_gatewayAggregateArgs>(args: Subset<T, Payment_gatewayAggregateArgs>): Prisma.PrismaPromise<GetPayment_gatewayAggregateType<T>>

    /**
     * Group by Payment_gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_gatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_gatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_gatewayGroupByArgs['orderBy'] }
        : { orderBy?: payment_gatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_gatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_gatewayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_gateway model
   */
  readonly fields: payment_gatewayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_gateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_gatewayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_gateway model
   */
  interface payment_gatewayFieldRefs {
    readonly id: FieldRef<"payment_gateway", 'Int'>
    readonly wallet_name: FieldRef<"payment_gateway", 'String'>
    readonly deposit_wallet_address: FieldRef<"payment_gateway", 'String'>
    readonly api_key: FieldRef<"payment_gateway", 'String'>
    readonly secret_key: FieldRef<"payment_gateway", 'String'>
    readonly gateway_type: FieldRef<"payment_gateway", 'String'>
    readonly is_active: FieldRef<"payment_gateway", 'Boolean'>
    readonly description: FieldRef<"payment_gateway", 'String'>
    readonly created_at: FieldRef<"payment_gateway", 'DateTime'>
    readonly updated_at: FieldRef<"payment_gateway", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_gateway findUnique
   */
  export type payment_gatewayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway findUniqueOrThrow
   */
  export type payment_gatewayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway findFirst
   */
  export type payment_gatewayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_gateways.
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_gateways.
     */
    distinct?: Payment_gatewayScalarFieldEnum | Payment_gatewayScalarFieldEnum[]
  }

  /**
   * payment_gateway findFirstOrThrow
   */
  export type payment_gatewayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateway to fetch.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_gateways.
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_gateways.
     */
    distinct?: Payment_gatewayScalarFieldEnum | Payment_gatewayScalarFieldEnum[]
  }

  /**
   * payment_gateway findMany
   */
  export type payment_gatewayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter, which payment_gateways to fetch.
     */
    where?: payment_gatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_gateways to fetch.
     */
    orderBy?: payment_gatewayOrderByWithRelationInput | payment_gatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_gateways.
     */
    cursor?: payment_gatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_gateways.
     */
    skip?: number
    distinct?: Payment_gatewayScalarFieldEnum | Payment_gatewayScalarFieldEnum[]
  }

  /**
   * payment_gateway create
   */
  export type payment_gatewayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to create a payment_gateway.
     */
    data: XOR<payment_gatewayCreateInput, payment_gatewayUncheckedCreateInput>
  }

  /**
   * payment_gateway createMany
   */
  export type payment_gatewayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_gateways.
     */
    data: payment_gatewayCreateManyInput | payment_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_gateway createManyAndReturn
   */
  export type payment_gatewayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data used to create many payment_gateways.
     */
    data: payment_gatewayCreateManyInput | payment_gatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_gateway update
   */
  export type payment_gatewayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data needed to update a payment_gateway.
     */
    data: XOR<payment_gatewayUpdateInput, payment_gatewayUncheckedUpdateInput>
    /**
     * Choose, which payment_gateway to update.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway updateMany
   */
  export type payment_gatewayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_gateways.
     */
    data: XOR<payment_gatewayUpdateManyMutationInput, payment_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which payment_gateways to update
     */
    where?: payment_gatewayWhereInput
    /**
     * Limit how many payment_gateways to update.
     */
    limit?: number
  }

  /**
   * payment_gateway updateManyAndReturn
   */
  export type payment_gatewayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The data used to update payment_gateways.
     */
    data: XOR<payment_gatewayUpdateManyMutationInput, payment_gatewayUncheckedUpdateManyInput>
    /**
     * Filter which payment_gateways to update
     */
    where?: payment_gatewayWhereInput
    /**
     * Limit how many payment_gateways to update.
     */
    limit?: number
  }

  /**
   * payment_gateway upsert
   */
  export type payment_gatewayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * The filter to search for the payment_gateway to update in case it exists.
     */
    where: payment_gatewayWhereUniqueInput
    /**
     * In case the payment_gateway found by the `where` argument doesn't exist, create a new payment_gateway with this data.
     */
    create: XOR<payment_gatewayCreateInput, payment_gatewayUncheckedCreateInput>
    /**
     * In case the payment_gateway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_gatewayUpdateInput, payment_gatewayUncheckedUpdateInput>
  }

  /**
   * payment_gateway delete
   */
  export type payment_gatewayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
    /**
     * Filter which payment_gateway to delete.
     */
    where: payment_gatewayWhereUniqueInput
  }

  /**
   * payment_gateway deleteMany
   */
  export type payment_gatewayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_gateways to delete
     */
    where?: payment_gatewayWhereInput
    /**
     * Limit how many payment_gateways to delete.
     */
    limit?: number
  }

  /**
   * payment_gateway without action
   */
  export type payment_gatewayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_gateway
     */
    select?: payment_gatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_gateway
     */
    omit?: payment_gatewayOmit<ExtArgs> | null
  }


  /**
   * Model symbols
   */

  export type AggregateSymbols = {
    _count: SymbolsCountAggregateOutputType | null
    _avg: SymbolsAvgAggregateOutputType | null
    _sum: SymbolsSumAggregateOutputType | null
    _min: SymbolsMinAggregateOutputType | null
    _max: SymbolsMaxAggregateOutputType | null
  }

  export type SymbolsAvgAggregateOutputType = {
    id: number | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    swap_long: number | null
    swap_short: number | null
  }

  export type SymbolsSumAggregateOutputType = {
    id: number | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    swap_long: number | null
    swap_short: number | null
  }

  export type SymbolsMinAggregateOutputType = {
    id: number | null
    symbol_name: string | null
    description: string | null
    symbol_type: string | null
    group_name: string | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    profit_mode: string | null
    enable: boolean | null
    swap_mode: string | null
    swap_long: number | null
    swap_short: number | null
    swap3_day: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SymbolsMaxAggregateOutputType = {
    id: number | null
    symbol_name: string | null
    description: string | null
    symbol_type: string | null
    group_name: string | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    profit_mode: string | null
    enable: boolean | null
    swap_mode: string | null
    swap_long: number | null
    swap_short: number | null
    swap3_day: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SymbolsCountAggregateOutputType = {
    id: number
    symbol_name: number
    description: number
    symbol_type: number
    group_name: number
    digits: number
    spread: number
    contract_size: number
    profit_mode: number
    enable: number
    swap_mode: number
    swap_long: number
    swap_short: number
    swap3_day: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SymbolsAvgAggregateInputType = {
    id?: true
    digits?: true
    spread?: true
    contract_size?: true
    swap_long?: true
    swap_short?: true
  }

  export type SymbolsSumAggregateInputType = {
    id?: true
    digits?: true
    spread?: true
    contract_size?: true
    swap_long?: true
    swap_short?: true
  }

  export type SymbolsMinAggregateInputType = {
    id?: true
    symbol_name?: true
    description?: true
    symbol_type?: true
    group_name?: true
    digits?: true
    spread?: true
    contract_size?: true
    profit_mode?: true
    enable?: true
    swap_mode?: true
    swap_long?: true
    swap_short?: true
    swap3_day?: true
    created_at?: true
    updated_at?: true
  }

  export type SymbolsMaxAggregateInputType = {
    id?: true
    symbol_name?: true
    description?: true
    symbol_type?: true
    group_name?: true
    digits?: true
    spread?: true
    contract_size?: true
    profit_mode?: true
    enable?: true
    swap_mode?: true
    swap_long?: true
    swap_short?: true
    swap3_day?: true
    created_at?: true
    updated_at?: true
  }

  export type SymbolsCountAggregateInputType = {
    id?: true
    symbol_name?: true
    description?: true
    symbol_type?: true
    group_name?: true
    digits?: true
    spread?: true
    contract_size?: true
    profit_mode?: true
    enable?: true
    swap_mode?: true
    swap_long?: true
    swap_short?: true
    swap3_day?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SymbolsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which symbols to aggregate.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned symbols
    **/
    _count?: true | SymbolsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymbolsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymbolsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymbolsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymbolsMaxAggregateInputType
  }

  export type GetSymbolsAggregateType<T extends SymbolsAggregateArgs> = {
        [P in keyof T & keyof AggregateSymbols]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbols[P]>
      : GetScalarType<T[P], AggregateSymbols[P]>
  }




  export type symbolsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: symbolsWhereInput
    orderBy?: symbolsOrderByWithAggregationInput | symbolsOrderByWithAggregationInput[]
    by: SymbolsScalarFieldEnum[] | SymbolsScalarFieldEnum
    having?: symbolsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymbolsCountAggregateInputType | true
    _avg?: SymbolsAvgAggregateInputType
    _sum?: SymbolsSumAggregateInputType
    _min?: SymbolsMinAggregateInputType
    _max?: SymbolsMaxAggregateInputType
  }

  export type SymbolsGroupByOutputType = {
    id: number
    symbol_name: string
    description: string | null
    symbol_type: string | null
    group_name: string | null
    digits: number | null
    spread: number | null
    contract_size: number | null
    profit_mode: string | null
    enable: boolean | null
    swap_mode: string | null
    swap_long: number | null
    swap_short: number | null
    swap3_day: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: SymbolsCountAggregateOutputType | null
    _avg: SymbolsAvgAggregateOutputType | null
    _sum: SymbolsSumAggregateOutputType | null
    _min: SymbolsMinAggregateOutputType | null
    _max: SymbolsMaxAggregateOutputType | null
  }

  type GetSymbolsGroupByPayload<T extends symbolsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymbolsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymbolsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolsGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolsGroupByOutputType[P]>
        }
      >
    >


  export type symbolsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols"]>

  export type symbolsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols"]>

  export type symbolsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols"]>

  export type symbolsSelectScalar = {
    id?: boolean
    symbol_name?: boolean
    description?: boolean
    symbol_type?: boolean
    group_name?: boolean
    digits?: boolean
    spread?: boolean
    contract_size?: boolean
    profit_mode?: boolean
    enable?: boolean
    swap_mode?: boolean
    swap_long?: boolean
    swap_short?: boolean
    swap3_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type symbolsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol_name" | "description" | "symbol_type" | "group_name" | "digits" | "spread" | "contract_size" | "profit_mode" | "enable" | "swap_mode" | "swap_long" | "swap_short" | "swap3_day" | "created_at" | "updated_at", ExtArgs["result"]["symbols"]>

  export type $symbolsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "symbols"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol_name: string
      description: string | null
      symbol_type: string | null
      group_name: string | null
      digits: number | null
      spread: number | null
      contract_size: number | null
      profit_mode: string | null
      enable: boolean | null
      swap_mode: string | null
      swap_long: number | null
      swap_short: number | null
      swap3_day: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["symbols"]>
    composites: {}
  }

  type symbolsGetPayload<S extends boolean | null | undefined | symbolsDefaultArgs> = $Result.GetResult<Prisma.$symbolsPayload, S>

  type symbolsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<symbolsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SymbolsCountAggregateInputType | true
    }

  export interface symbolsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['symbols'], meta: { name: 'symbols' } }
    /**
     * Find zero or one Symbols that matches the filter.
     * @param {symbolsFindUniqueArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends symbolsFindUniqueArgs>(args: SelectSubset<T, symbolsFindUniqueArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Symbols that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {symbolsFindUniqueOrThrowArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends symbolsFindUniqueOrThrowArgs>(args: SelectSubset<T, symbolsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsFindFirstArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends symbolsFindFirstArgs>(args?: SelectSubset<T, symbolsFindFirstArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbols that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsFindFirstOrThrowArgs} args - Arguments to find a Symbols
     * @example
     * // Get one Symbols
     * const symbols = await prisma.symbols.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends symbolsFindFirstOrThrowArgs>(args?: SelectSubset<T, symbolsFindFirstOrThrowArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Symbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols
     * const symbols = await prisma.symbols.findMany()
     * 
     * // Get first 10 Symbols
     * const symbols = await prisma.symbols.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symbolsWithIdOnly = await prisma.symbols.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends symbolsFindManyArgs>(args?: SelectSubset<T, symbolsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Symbols.
     * @param {symbolsCreateArgs} args - Arguments to create a Symbols.
     * @example
     * // Create one Symbols
     * const Symbols = await prisma.symbols.create({
     *   data: {
     *     // ... data to create a Symbols
     *   }
     * })
     * 
     */
    create<T extends symbolsCreateArgs>(args: SelectSubset<T, symbolsCreateArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Symbols.
     * @param {symbolsCreateManyArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbols = await prisma.symbols.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends symbolsCreateManyArgs>(args?: SelectSubset<T, symbolsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Symbols and returns the data saved in the database.
     * @param {symbolsCreateManyAndReturnArgs} args - Arguments to create many Symbols.
     * @example
     * // Create many Symbols
     * const symbols = await prisma.symbols.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Symbols and only return the `id`
     * const symbolsWithIdOnly = await prisma.symbols.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends symbolsCreateManyAndReturnArgs>(args?: SelectSubset<T, symbolsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Symbols.
     * @param {symbolsDeleteArgs} args - Arguments to delete one Symbols.
     * @example
     * // Delete one Symbols
     * const Symbols = await prisma.symbols.delete({
     *   where: {
     *     // ... filter to delete one Symbols
     *   }
     * })
     * 
     */
    delete<T extends symbolsDeleteArgs>(args: SelectSubset<T, symbolsDeleteArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Symbols.
     * @param {symbolsUpdateArgs} args - Arguments to update one Symbols.
     * @example
     * // Update one Symbols
     * const symbols = await prisma.symbols.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends symbolsUpdateArgs>(args: SelectSubset<T, symbolsUpdateArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Symbols.
     * @param {symbolsDeleteManyArgs} args - Arguments to filter Symbols to delete.
     * @example
     * // Delete a few Symbols
     * const { count } = await prisma.symbols.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends symbolsDeleteManyArgs>(args?: SelectSubset<T, symbolsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols
     * const symbols = await prisma.symbols.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends symbolsUpdateManyArgs>(args: SelectSubset<T, symbolsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols and returns the data updated in the database.
     * @param {symbolsUpdateManyAndReturnArgs} args - Arguments to update many Symbols.
     * @example
     * // Update many Symbols
     * const symbols = await prisma.symbols.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Symbols and only return the `id`
     * const symbolsWithIdOnly = await prisma.symbols.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends symbolsUpdateManyAndReturnArgs>(args: SelectSubset<T, symbolsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Symbols.
     * @param {symbolsUpsertArgs} args - Arguments to update or create a Symbols.
     * @example
     * // Update or create a Symbols
     * const symbols = await prisma.symbols.upsert({
     *   create: {
     *     // ... data to create a Symbols
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbols we want to update
     *   }
     * })
     */
    upsert<T extends symbolsUpsertArgs>(args: SelectSubset<T, symbolsUpsertArgs<ExtArgs>>): Prisma__symbolsClient<$Result.GetResult<Prisma.$symbolsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsCountArgs} args - Arguments to filter Symbols to count.
     * @example
     * // Count the number of Symbols
     * const count = await prisma.symbols.count({
     *   where: {
     *     // ... the filter for the Symbols we want to count
     *   }
     * })
    **/
    count<T extends symbolsCountArgs>(
      args?: Subset<T, symbolsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymbolsAggregateArgs>(args: Subset<T, SymbolsAggregateArgs>): Prisma.PrismaPromise<GetSymbolsAggregateType<T>>

    /**
     * Group by Symbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends symbolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: symbolsGroupByArgs['orderBy'] }
        : { orderBy?: symbolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, symbolsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymbolsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the symbols model
   */
  readonly fields: symbolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for symbols.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__symbolsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the symbols model
   */
  interface symbolsFieldRefs {
    readonly id: FieldRef<"symbols", 'Int'>
    readonly symbol_name: FieldRef<"symbols", 'String'>
    readonly description: FieldRef<"symbols", 'String'>
    readonly symbol_type: FieldRef<"symbols", 'String'>
    readonly group_name: FieldRef<"symbols", 'String'>
    readonly digits: FieldRef<"symbols", 'Int'>
    readonly spread: FieldRef<"symbols", 'Float'>
    readonly contract_size: FieldRef<"symbols", 'Int'>
    readonly profit_mode: FieldRef<"symbols", 'String'>
    readonly enable: FieldRef<"symbols", 'Boolean'>
    readonly swap_mode: FieldRef<"symbols", 'String'>
    readonly swap_long: FieldRef<"symbols", 'Float'>
    readonly swap_short: FieldRef<"symbols", 'Float'>
    readonly swap3_day: FieldRef<"symbols", 'String'>
    readonly created_at: FieldRef<"symbols", 'DateTime'>
    readonly updated_at: FieldRef<"symbols", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * symbols findUnique
   */
  export type symbolsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols findUniqueOrThrow
   */
  export type symbolsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols findFirst
   */
  export type symbolsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for symbols.
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of symbols.
     */
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[]
  }

  /**
   * symbols findFirstOrThrow
   */
  export type symbolsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for symbols.
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of symbols.
     */
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[]
  }

  /**
   * symbols findMany
   */
  export type symbolsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter, which symbols to fetch.
     */
    where?: symbolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols to fetch.
     */
    orderBy?: symbolsOrderByWithRelationInput | symbolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing symbols.
     */
    cursor?: symbolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols.
     */
    skip?: number
    distinct?: SymbolsScalarFieldEnum | SymbolsScalarFieldEnum[]
  }

  /**
   * symbols create
   */
  export type symbolsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data needed to create a symbols.
     */
    data: XOR<symbolsCreateInput, symbolsUncheckedCreateInput>
  }

  /**
   * symbols createMany
   */
  export type symbolsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many symbols.
     */
    data: symbolsCreateManyInput | symbolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * symbols createManyAndReturn
   */
  export type symbolsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data used to create many symbols.
     */
    data: symbolsCreateManyInput | symbolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * symbols update
   */
  export type symbolsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data needed to update a symbols.
     */
    data: XOR<symbolsUpdateInput, symbolsUncheckedUpdateInput>
    /**
     * Choose, which symbols to update.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols updateMany
   */
  export type symbolsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update symbols.
     */
    data: XOR<symbolsUpdateManyMutationInput, symbolsUncheckedUpdateManyInput>
    /**
     * Filter which symbols to update
     */
    where?: symbolsWhereInput
    /**
     * Limit how many symbols to update.
     */
    limit?: number
  }

  /**
   * symbols updateManyAndReturn
   */
  export type symbolsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The data used to update symbols.
     */
    data: XOR<symbolsUpdateManyMutationInput, symbolsUncheckedUpdateManyInput>
    /**
     * Filter which symbols to update
     */
    where?: symbolsWhereInput
    /**
     * Limit how many symbols to update.
     */
    limit?: number
  }

  /**
   * symbols upsert
   */
  export type symbolsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * The filter to search for the symbols to update in case it exists.
     */
    where: symbolsWhereUniqueInput
    /**
     * In case the symbols found by the `where` argument doesn't exist, create a new symbols with this data.
     */
    create: XOR<symbolsCreateInput, symbolsUncheckedCreateInput>
    /**
     * In case the symbols was found with the provided `where` argument, update it with this data.
     */
    update: XOR<symbolsUpdateInput, symbolsUncheckedUpdateInput>
  }

  /**
   * symbols delete
   */
  export type symbolsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
    /**
     * Filter which symbols to delete.
     */
    where: symbolsWhereUniqueInput
  }

  /**
   * symbols deleteMany
   */
  export type symbolsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which symbols to delete
     */
    where?: symbolsWhereInput
    /**
     * Limit how many symbols to delete.
     */
    limit?: number
  }

  /**
   * symbols without action
   */
  export type symbolsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols
     */
    select?: symbolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols
     */
    omit?: symbolsOmit<ExtArgs> | null
  }


  /**
   * Model ib_group_assignments
   */

  export type AggregateIb_group_assignments = {
    _count: Ib_group_assignmentsCountAggregateOutputType | null
    _avg: Ib_group_assignmentsAvgAggregateOutputType | null
    _sum: Ib_group_assignmentsSumAggregateOutputType | null
    _min: Ib_group_assignmentsMinAggregateOutputType | null
    _max: Ib_group_assignmentsMaxAggregateOutputType | null
  }

  export type Ib_group_assignmentsAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    structure_id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
  }

  export type Ib_group_assignmentsSumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    structure_id: number | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
  }

  export type Ib_group_assignmentsMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    group_id: string | null
    group_name: string | null
    structure_id: number | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_group_assignmentsMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    group_id: string | null
    group_name: string | null
    structure_id: number | null
    structure_name: string | null
    usd_per_lot: Decimal | null
    spread_share_percentage: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ib_group_assignmentsCountAggregateOutputType = {
    id: number
    ib_request_id: number
    group_id: number
    group_name: number
    structure_id: number
    structure_name: number
    usd_per_lot: number
    spread_share_percentage: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ib_group_assignmentsAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
    structure_id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
  }

  export type Ib_group_assignmentsSumAggregateInputType = {
    id?: true
    ib_request_id?: true
    structure_id?: true
    usd_per_lot?: true
    spread_share_percentage?: true
  }

  export type Ib_group_assignmentsMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    group_id?: true
    group_name?: true
    structure_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_group_assignmentsMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    group_id?: true
    group_name?: true
    structure_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    created_at?: true
    updated_at?: true
  }

  export type Ib_group_assignmentsCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    group_id?: true
    group_name?: true
    structure_id?: true
    structure_name?: true
    usd_per_lot?: true
    spread_share_percentage?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ib_group_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_group_assignments to aggregate.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_group_assignments
    **/
    _count?: true | Ib_group_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_group_assignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_group_assignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_group_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_group_assignmentsMaxAggregateInputType
  }

  export type GetIb_group_assignmentsAggregateType<T extends Ib_group_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_group_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_group_assignments[P]>
      : GetScalarType<T[P], AggregateIb_group_assignments[P]>
  }




  export type ib_group_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_group_assignmentsWhereInput
    orderBy?: ib_group_assignmentsOrderByWithAggregationInput | ib_group_assignmentsOrderByWithAggregationInput[]
    by: Ib_group_assignmentsScalarFieldEnum[] | Ib_group_assignmentsScalarFieldEnum
    having?: ib_group_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_group_assignmentsCountAggregateInputType | true
    _avg?: Ib_group_assignmentsAvgAggregateInputType
    _sum?: Ib_group_assignmentsSumAggregateInputType
    _min?: Ib_group_assignmentsMinAggregateInputType
    _max?: Ib_group_assignmentsMaxAggregateInputType
  }

  export type Ib_group_assignmentsGroupByOutputType = {
    id: number
    ib_request_id: number | null
    group_id: string
    group_name: string | null
    structure_id: number | null
    structure_name: string | null
    usd_per_lot: Decimal
    spread_share_percentage: Decimal
    created_at: Date | null
    updated_at: Date | null
    _count: Ib_group_assignmentsCountAggregateOutputType | null
    _avg: Ib_group_assignmentsAvgAggregateOutputType | null
    _sum: Ib_group_assignmentsSumAggregateOutputType | null
    _min: Ib_group_assignmentsMinAggregateOutputType | null
    _max: Ib_group_assignmentsMaxAggregateOutputType | null
  }

  type GetIb_group_assignmentsGroupByPayload<T extends ib_group_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_group_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_group_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_group_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_group_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type ib_group_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }, ExtArgs["result"]["ib_group_assignments"]>

  export type ib_group_assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }, ExtArgs["result"]["ib_group_assignments"]>

  export type ib_group_assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }, ExtArgs["result"]["ib_group_assignments"]>

  export type ib_group_assignmentsSelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    group_id?: boolean
    group_name?: boolean
    structure_id?: boolean
    structure_name?: boolean
    usd_per_lot?: boolean
    spread_share_percentage?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ib_group_assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "group_id" | "group_name" | "structure_id" | "structure_name" | "usd_per_lot" | "spread_share_percentage" | "created_at" | "updated_at", ExtArgs["result"]["ib_group_assignments"]>
  export type ib_group_assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }
  export type ib_group_assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }
  export type ib_group_assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ib_requests?: boolean | ib_group_assignments$ib_requestsArgs<ExtArgs>
  }

  export type $ib_group_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_group_assignments"
    objects: {
      ib_requests: Prisma.$ib_requestsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number | null
      group_id: string
      group_name: string | null
      structure_id: number | null
      structure_name: string | null
      usd_per_lot: Prisma.Decimal
      spread_share_percentage: Prisma.Decimal
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["ib_group_assignments"]>
    composites: {}
  }

  type ib_group_assignmentsGetPayload<S extends boolean | null | undefined | ib_group_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$ib_group_assignmentsPayload, S>

  type ib_group_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_group_assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_group_assignmentsCountAggregateInputType | true
    }

  export interface ib_group_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_group_assignments'], meta: { name: 'ib_group_assignments' } }
    /**
     * Find zero or one Ib_group_assignments that matches the filter.
     * @param {ib_group_assignmentsFindUniqueArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_group_assignmentsFindUniqueArgs>(args: SelectSubset<T, ib_group_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_group_assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_group_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_group_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_group_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_group_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsFindFirstArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_group_assignmentsFindFirstArgs>(args?: SelectSubset<T, ib_group_assignmentsFindFirstArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_group_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsFindFirstOrThrowArgs} args - Arguments to find a Ib_group_assignments
     * @example
     * // Get one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_group_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_group_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_group_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findMany()
     * 
     * // Get first 10 Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_group_assignmentsWithIdOnly = await prisma.ib_group_assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_group_assignmentsFindManyArgs>(args?: SelectSubset<T, ib_group_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_group_assignments.
     * @param {ib_group_assignmentsCreateArgs} args - Arguments to create a Ib_group_assignments.
     * @example
     * // Create one Ib_group_assignments
     * const Ib_group_assignments = await prisma.ib_group_assignments.create({
     *   data: {
     *     // ... data to create a Ib_group_assignments
     *   }
     * })
     * 
     */
    create<T extends ib_group_assignmentsCreateArgs>(args: SelectSubset<T, ib_group_assignmentsCreateArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_group_assignments.
     * @param {ib_group_assignmentsCreateManyArgs} args - Arguments to create many Ib_group_assignments.
     * @example
     * // Create many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_group_assignmentsCreateManyArgs>(args?: SelectSubset<T, ib_group_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_group_assignments and returns the data saved in the database.
     * @param {ib_group_assignmentsCreateManyAndReturnArgs} args - Arguments to create many Ib_group_assignments.
     * @example
     * // Create many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_group_assignments and only return the `id`
     * const ib_group_assignmentsWithIdOnly = await prisma.ib_group_assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_group_assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_group_assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_group_assignments.
     * @param {ib_group_assignmentsDeleteArgs} args - Arguments to delete one Ib_group_assignments.
     * @example
     * // Delete one Ib_group_assignments
     * const Ib_group_assignments = await prisma.ib_group_assignments.delete({
     *   where: {
     *     // ... filter to delete one Ib_group_assignments
     *   }
     * })
     * 
     */
    delete<T extends ib_group_assignmentsDeleteArgs>(args: SelectSubset<T, ib_group_assignmentsDeleteArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_group_assignments.
     * @param {ib_group_assignmentsUpdateArgs} args - Arguments to update one Ib_group_assignments.
     * @example
     * // Update one Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_group_assignmentsUpdateArgs>(args: SelectSubset<T, ib_group_assignmentsUpdateArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_group_assignments.
     * @param {ib_group_assignmentsDeleteManyArgs} args - Arguments to filter Ib_group_assignments to delete.
     * @example
     * // Delete a few Ib_group_assignments
     * const { count } = await prisma.ib_group_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_group_assignmentsDeleteManyArgs>(args?: SelectSubset<T, ib_group_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_group_assignmentsUpdateManyArgs>(args: SelectSubset<T, ib_group_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_group_assignments and returns the data updated in the database.
     * @param {ib_group_assignmentsUpdateManyAndReturnArgs} args - Arguments to update many Ib_group_assignments.
     * @example
     * // Update many Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_group_assignments and only return the `id`
     * const ib_group_assignmentsWithIdOnly = await prisma.ib_group_assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_group_assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_group_assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_group_assignments.
     * @param {ib_group_assignmentsUpsertArgs} args - Arguments to update or create a Ib_group_assignments.
     * @example
     * // Update or create a Ib_group_assignments
     * const ib_group_assignments = await prisma.ib_group_assignments.upsert({
     *   create: {
     *     // ... data to create a Ib_group_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_group_assignments we want to update
     *   }
     * })
     */
    upsert<T extends ib_group_assignmentsUpsertArgs>(args: SelectSubset<T, ib_group_assignmentsUpsertArgs<ExtArgs>>): Prisma__ib_group_assignmentsClient<$Result.GetResult<Prisma.$ib_group_assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsCountArgs} args - Arguments to filter Ib_group_assignments to count.
     * @example
     * // Count the number of Ib_group_assignments
     * const count = await prisma.ib_group_assignments.count({
     *   where: {
     *     // ... the filter for the Ib_group_assignments we want to count
     *   }
     * })
    **/
    count<T extends ib_group_assignmentsCountArgs>(
      args?: Subset<T, ib_group_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_group_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_group_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_group_assignmentsAggregateArgs>(args: Subset<T, Ib_group_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetIb_group_assignmentsAggregateType<T>>

    /**
     * Group by Ib_group_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_group_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_group_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_group_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: ib_group_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_group_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_group_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_group_assignments model
   */
  readonly fields: ib_group_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_group_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_group_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ib_requests<T extends ib_group_assignments$ib_requestsArgs<ExtArgs> = {}>(args?: Subset<T, ib_group_assignments$ib_requestsArgs<ExtArgs>>): Prisma__ib_requestsClient<$Result.GetResult<Prisma.$ib_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_group_assignments model
   */
  interface ib_group_assignmentsFieldRefs {
    readonly id: FieldRef<"ib_group_assignments", 'Int'>
    readonly ib_request_id: FieldRef<"ib_group_assignments", 'Int'>
    readonly group_id: FieldRef<"ib_group_assignments", 'String'>
    readonly group_name: FieldRef<"ib_group_assignments", 'String'>
    readonly structure_id: FieldRef<"ib_group_assignments", 'Int'>
    readonly structure_name: FieldRef<"ib_group_assignments", 'String'>
    readonly usd_per_lot: FieldRef<"ib_group_assignments", 'Decimal'>
    readonly spread_share_percentage: FieldRef<"ib_group_assignments", 'Decimal'>
    readonly created_at: FieldRef<"ib_group_assignments", 'DateTime'>
    readonly updated_at: FieldRef<"ib_group_assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_group_assignments findUnique
   */
  export type ib_group_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments findUniqueOrThrow
   */
  export type ib_group_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments findFirst
   */
  export type ib_group_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_group_assignments.
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_group_assignments.
     */
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_group_assignments findFirstOrThrow
   */
  export type ib_group_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_group_assignments.
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_group_assignments.
     */
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_group_assignments findMany
   */
  export type ib_group_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which ib_group_assignments to fetch.
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_group_assignments to fetch.
     */
    orderBy?: ib_group_assignmentsOrderByWithRelationInput | ib_group_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_group_assignments.
     */
    cursor?: ib_group_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_group_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_group_assignments.
     */
    skip?: number
    distinct?: Ib_group_assignmentsScalarFieldEnum | Ib_group_assignmentsScalarFieldEnum[]
  }

  /**
   * ib_group_assignments create
   */
  export type ib_group_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsCreateInput, ib_group_assignmentsUncheckedCreateInput>
  }

  /**
   * ib_group_assignments createMany
   */
  export type ib_group_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_group_assignments.
     */
    data: ib_group_assignmentsCreateManyInput | ib_group_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_group_assignments createManyAndReturn
   */
  export type ib_group_assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_group_assignments.
     */
    data: ib_group_assignmentsCreateManyInput | ib_group_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ib_group_assignments update
   */
  export type ib_group_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsUpdateInput, ib_group_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which ib_group_assignments to update.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments updateMany
   */
  export type ib_group_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsUpdateManyMutationInput, ib_group_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which ib_group_assignments to update
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * Limit how many ib_group_assignments to update.
     */
    limit?: number
  }

  /**
   * ib_group_assignments updateManyAndReturn
   */
  export type ib_group_assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update ib_group_assignments.
     */
    data: XOR<ib_group_assignmentsUpdateManyMutationInput, ib_group_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which ib_group_assignments to update
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * Limit how many ib_group_assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ib_group_assignments upsert
   */
  export type ib_group_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the ib_group_assignments to update in case it exists.
     */
    where: ib_group_assignmentsWhereUniqueInput
    /**
     * In case the ib_group_assignments found by the `where` argument doesn't exist, create a new ib_group_assignments with this data.
     */
    create: XOR<ib_group_assignmentsCreateInput, ib_group_assignmentsUncheckedCreateInput>
    /**
     * In case the ib_group_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_group_assignmentsUpdateInput, ib_group_assignmentsUncheckedUpdateInput>
  }

  /**
   * ib_group_assignments delete
   */
  export type ib_group_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
    /**
     * Filter which ib_group_assignments to delete.
     */
    where: ib_group_assignmentsWhereUniqueInput
  }

  /**
   * ib_group_assignments deleteMany
   */
  export type ib_group_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_group_assignments to delete
     */
    where?: ib_group_assignmentsWhereInput
    /**
     * Limit how many ib_group_assignments to delete.
     */
    limit?: number
  }

  /**
   * ib_group_assignments.ib_requests
   */
  export type ib_group_assignments$ib_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_requests
     */
    select?: ib_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_requests
     */
    omit?: ib_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_requestsInclude<ExtArgs> | null
    where?: ib_requestsWhereInput
  }

  /**
   * ib_group_assignments without action
   */
  export type ib_group_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_group_assignments
     */
    select?: ib_group_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_group_assignments
     */
    omit?: ib_group_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ib_group_assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model ib_trade_history
   */

  export type AggregateIb_trade_history = {
    _count: Ib_trade_historyCountAggregateOutputType | null
    _avg: Ib_trade_historyAvgAggregateOutputType | null
    _sum: Ib_trade_historySumAggregateOutputType | null
    _min: Ib_trade_historyMinAggregateOutputType | null
    _max: Ib_trade_historyMaxAggregateOutputType | null
  }

  export type Ib_trade_historyAvgAggregateOutputType = {
    ib_request_id: number | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
  }

  export type Ib_trade_historySumAggregateOutputType = {
    ib_request_id: number | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
  }

  export type Ib_trade_historyMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    account_id: string | null
    user_id: string | null
    ib_request_id: number | null
    symbol: string | null
    order_type: string | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    synced_at: Date | null
    group_id: string | null
  }

  export type Ib_trade_historyMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    account_id: string | null
    user_id: string | null
    ib_request_id: number | null
    symbol: string | null
    order_type: string | null
    volume_lots: Decimal | null
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    synced_at: Date | null
    group_id: string | null
  }

  export type Ib_trade_historyCountAggregateOutputType = {
    id: number
    order_id: number
    account_id: number
    user_id: number
    ib_request_id: number
    symbol: number
    order_type: number
    volume_lots: number
    open_price: number
    close_price: number
    profit: number
    ib_commission: number
    take_profit: number
    stop_loss: number
    created_at: number
    updated_at: number
    synced_at: number
    group_id: number
    _all: number
  }


  export type Ib_trade_historyAvgAggregateInputType = {
    ib_request_id?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
  }

  export type Ib_trade_historySumAggregateInputType = {
    ib_request_id?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
  }

  export type Ib_trade_historyMinAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    user_id?: true
    ib_request_id?: true
    symbol?: true
    order_type?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
    created_at?: true
    updated_at?: true
    synced_at?: true
    group_id?: true
  }

  export type Ib_trade_historyMaxAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    user_id?: true
    ib_request_id?: true
    symbol?: true
    order_type?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
    created_at?: true
    updated_at?: true
    synced_at?: true
    group_id?: true
  }

  export type Ib_trade_historyCountAggregateInputType = {
    id?: true
    order_id?: true
    account_id?: true
    user_id?: true
    ib_request_id?: true
    symbol?: true
    order_type?: true
    volume_lots?: true
    open_price?: true
    close_price?: true
    profit?: true
    ib_commission?: true
    take_profit?: true
    stop_loss?: true
    created_at?: true
    updated_at?: true
    synced_at?: true
    group_id?: true
    _all?: true
  }

  export type Ib_trade_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_trade_history to aggregate.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_trade_histories
    **/
    _count?: true | Ib_trade_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_trade_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_trade_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_trade_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_trade_historyMaxAggregateInputType
  }

  export type GetIb_trade_historyAggregateType<T extends Ib_trade_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_trade_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_trade_history[P]>
      : GetScalarType<T[P], AggregateIb_trade_history[P]>
  }




  export type ib_trade_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_trade_historyWhereInput
    orderBy?: ib_trade_historyOrderByWithAggregationInput | ib_trade_historyOrderByWithAggregationInput[]
    by: Ib_trade_historyScalarFieldEnum[] | Ib_trade_historyScalarFieldEnum
    having?: ib_trade_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_trade_historyCountAggregateInputType | true
    _avg?: Ib_trade_historyAvgAggregateInputType
    _sum?: Ib_trade_historySumAggregateInputType
    _min?: Ib_trade_historyMinAggregateInputType
    _max?: Ib_trade_historyMaxAggregateInputType
  }

  export type Ib_trade_historyGroupByOutputType = {
    id: string
    order_id: string
    account_id: string
    user_id: string | null
    ib_request_id: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal
    open_price: Decimal | null
    close_price: Decimal | null
    profit: Decimal | null
    ib_commission: Decimal | null
    take_profit: Decimal | null
    stop_loss: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    synced_at: Date | null
    group_id: string | null
    _count: Ib_trade_historyCountAggregateOutputType | null
    _avg: Ib_trade_historyAvgAggregateOutputType | null
    _sum: Ib_trade_historySumAggregateOutputType | null
    _min: Ib_trade_historyMinAggregateOutputType | null
    _max: Ib_trade_historyMaxAggregateOutputType | null
  }

  type GetIb_trade_historyGroupByPayload<T extends ib_trade_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_trade_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_trade_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_trade_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_trade_historyGroupByOutputType[P]>
        }
      >
    >


  export type ib_trade_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }, ExtArgs["result"]["ib_trade_history"]>

  export type ib_trade_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }, ExtArgs["result"]["ib_trade_history"]>

  export type ib_trade_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }, ExtArgs["result"]["ib_trade_history"]>

  export type ib_trade_historySelectScalar = {
    id?: boolean
    order_id?: boolean
    account_id?: boolean
    user_id?: boolean
    ib_request_id?: boolean
    symbol?: boolean
    order_type?: boolean
    volume_lots?: boolean
    open_price?: boolean
    close_price?: boolean
    profit?: boolean
    ib_commission?: boolean
    take_profit?: boolean
    stop_loss?: boolean
    created_at?: boolean
    updated_at?: boolean
    synced_at?: boolean
    group_id?: boolean
  }

  export type ib_trade_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order_id" | "account_id" | "user_id" | "ib_request_id" | "symbol" | "order_type" | "volume_lots" | "open_price" | "close_price" | "profit" | "ib_commission" | "take_profit" | "stop_loss" | "created_at" | "updated_at" | "synced_at" | "group_id", ExtArgs["result"]["ib_trade_history"]>

  export type $ib_trade_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_trade_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      account_id: string
      user_id: string | null
      ib_request_id: number | null
      symbol: string
      order_type: string
      volume_lots: Prisma.Decimal
      open_price: Prisma.Decimal | null
      close_price: Prisma.Decimal | null
      profit: Prisma.Decimal | null
      ib_commission: Prisma.Decimal | null
      take_profit: Prisma.Decimal | null
      stop_loss: Prisma.Decimal | null
      created_at: Date | null
      updated_at: Date | null
      synced_at: Date | null
      group_id: string | null
    }, ExtArgs["result"]["ib_trade_history"]>
    composites: {}
  }

  type ib_trade_historyGetPayload<S extends boolean | null | undefined | ib_trade_historyDefaultArgs> = $Result.GetResult<Prisma.$ib_trade_historyPayload, S>

  type ib_trade_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_trade_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_trade_historyCountAggregateInputType | true
    }

  export interface ib_trade_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_trade_history'], meta: { name: 'ib_trade_history' } }
    /**
     * Find zero or one Ib_trade_history that matches the filter.
     * @param {ib_trade_historyFindUniqueArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_trade_historyFindUniqueArgs>(args: SelectSubset<T, ib_trade_historyFindUniqueArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_trade_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_trade_historyFindUniqueOrThrowArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_trade_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_trade_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_trade_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyFindFirstArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_trade_historyFindFirstArgs>(args?: SelectSubset<T, ib_trade_historyFindFirstArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_trade_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyFindFirstOrThrowArgs} args - Arguments to find a Ib_trade_history
     * @example
     * // Get one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_trade_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_trade_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_trade_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_trade_histories
     * const ib_trade_histories = await prisma.ib_trade_history.findMany()
     * 
     * // Get first 10 Ib_trade_histories
     * const ib_trade_histories = await prisma.ib_trade_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_trade_historyWithIdOnly = await prisma.ib_trade_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_trade_historyFindManyArgs>(args?: SelectSubset<T, ib_trade_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_trade_history.
     * @param {ib_trade_historyCreateArgs} args - Arguments to create a Ib_trade_history.
     * @example
     * // Create one Ib_trade_history
     * const Ib_trade_history = await prisma.ib_trade_history.create({
     *   data: {
     *     // ... data to create a Ib_trade_history
     *   }
     * })
     * 
     */
    create<T extends ib_trade_historyCreateArgs>(args: SelectSubset<T, ib_trade_historyCreateArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_trade_histories.
     * @param {ib_trade_historyCreateManyArgs} args - Arguments to create many Ib_trade_histories.
     * @example
     * // Create many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_trade_historyCreateManyArgs>(args?: SelectSubset<T, ib_trade_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_trade_histories and returns the data saved in the database.
     * @param {ib_trade_historyCreateManyAndReturnArgs} args - Arguments to create many Ib_trade_histories.
     * @example
     * // Create many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_trade_histories and only return the `id`
     * const ib_trade_historyWithIdOnly = await prisma.ib_trade_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_trade_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_trade_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_trade_history.
     * @param {ib_trade_historyDeleteArgs} args - Arguments to delete one Ib_trade_history.
     * @example
     * // Delete one Ib_trade_history
     * const Ib_trade_history = await prisma.ib_trade_history.delete({
     *   where: {
     *     // ... filter to delete one Ib_trade_history
     *   }
     * })
     * 
     */
    delete<T extends ib_trade_historyDeleteArgs>(args: SelectSubset<T, ib_trade_historyDeleteArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_trade_history.
     * @param {ib_trade_historyUpdateArgs} args - Arguments to update one Ib_trade_history.
     * @example
     * // Update one Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_trade_historyUpdateArgs>(args: SelectSubset<T, ib_trade_historyUpdateArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_trade_histories.
     * @param {ib_trade_historyDeleteManyArgs} args - Arguments to filter Ib_trade_histories to delete.
     * @example
     * // Delete a few Ib_trade_histories
     * const { count } = await prisma.ib_trade_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_trade_historyDeleteManyArgs>(args?: SelectSubset<T, ib_trade_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_trade_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_trade_historyUpdateManyArgs>(args: SelectSubset<T, ib_trade_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_trade_histories and returns the data updated in the database.
     * @param {ib_trade_historyUpdateManyAndReturnArgs} args - Arguments to update many Ib_trade_histories.
     * @example
     * // Update many Ib_trade_histories
     * const ib_trade_history = await prisma.ib_trade_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_trade_histories and only return the `id`
     * const ib_trade_historyWithIdOnly = await prisma.ib_trade_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_trade_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_trade_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_trade_history.
     * @param {ib_trade_historyUpsertArgs} args - Arguments to update or create a Ib_trade_history.
     * @example
     * // Update or create a Ib_trade_history
     * const ib_trade_history = await prisma.ib_trade_history.upsert({
     *   create: {
     *     // ... data to create a Ib_trade_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_trade_history we want to update
     *   }
     * })
     */
    upsert<T extends ib_trade_historyUpsertArgs>(args: SelectSubset<T, ib_trade_historyUpsertArgs<ExtArgs>>): Prisma__ib_trade_historyClient<$Result.GetResult<Prisma.$ib_trade_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_trade_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyCountArgs} args - Arguments to filter Ib_trade_histories to count.
     * @example
     * // Count the number of Ib_trade_histories
     * const count = await prisma.ib_trade_history.count({
     *   where: {
     *     // ... the filter for the Ib_trade_histories we want to count
     *   }
     * })
    **/
    count<T extends ib_trade_historyCountArgs>(
      args?: Subset<T, ib_trade_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_trade_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_trade_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_trade_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_trade_historyAggregateArgs>(args: Subset<T, Ib_trade_historyAggregateArgs>): Prisma.PrismaPromise<GetIb_trade_historyAggregateType<T>>

    /**
     * Group by Ib_trade_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_trade_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_trade_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_trade_historyGroupByArgs['orderBy'] }
        : { orderBy?: ib_trade_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_trade_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_trade_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_trade_history model
   */
  readonly fields: ib_trade_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_trade_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_trade_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_trade_history model
   */
  interface ib_trade_historyFieldRefs {
    readonly id: FieldRef<"ib_trade_history", 'String'>
    readonly order_id: FieldRef<"ib_trade_history", 'String'>
    readonly account_id: FieldRef<"ib_trade_history", 'String'>
    readonly user_id: FieldRef<"ib_trade_history", 'String'>
    readonly ib_request_id: FieldRef<"ib_trade_history", 'Int'>
    readonly symbol: FieldRef<"ib_trade_history", 'String'>
    readonly order_type: FieldRef<"ib_trade_history", 'String'>
    readonly volume_lots: FieldRef<"ib_trade_history", 'Decimal'>
    readonly open_price: FieldRef<"ib_trade_history", 'Decimal'>
    readonly close_price: FieldRef<"ib_trade_history", 'Decimal'>
    readonly profit: FieldRef<"ib_trade_history", 'Decimal'>
    readonly ib_commission: FieldRef<"ib_trade_history", 'Decimal'>
    readonly take_profit: FieldRef<"ib_trade_history", 'Decimal'>
    readonly stop_loss: FieldRef<"ib_trade_history", 'Decimal'>
    readonly created_at: FieldRef<"ib_trade_history", 'DateTime'>
    readonly updated_at: FieldRef<"ib_trade_history", 'DateTime'>
    readonly synced_at: FieldRef<"ib_trade_history", 'DateTime'>
    readonly group_id: FieldRef<"ib_trade_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ib_trade_history findUnique
   */
  export type ib_trade_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history findUniqueOrThrow
   */
  export type ib_trade_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history findFirst
   */
  export type ib_trade_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_trade_histories.
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_trade_histories.
     */
    distinct?: Ib_trade_historyScalarFieldEnum | Ib_trade_historyScalarFieldEnum[]
  }

  /**
   * ib_trade_history findFirstOrThrow
   */
  export type ib_trade_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_history to fetch.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_trade_histories.
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_trade_histories.
     */
    distinct?: Ib_trade_historyScalarFieldEnum | Ib_trade_historyScalarFieldEnum[]
  }

  /**
   * ib_trade_history findMany
   */
  export type ib_trade_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_trade_histories to fetch.
     */
    where?: ib_trade_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_trade_histories to fetch.
     */
    orderBy?: ib_trade_historyOrderByWithRelationInput | ib_trade_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_trade_histories.
     */
    cursor?: ib_trade_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_trade_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_trade_histories.
     */
    skip?: number
    distinct?: Ib_trade_historyScalarFieldEnum | Ib_trade_historyScalarFieldEnum[]
  }

  /**
   * ib_trade_history create
   */
  export type ib_trade_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_trade_history.
     */
    data: XOR<ib_trade_historyCreateInput, ib_trade_historyUncheckedCreateInput>
  }

  /**
   * ib_trade_history createMany
   */
  export type ib_trade_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_trade_histories.
     */
    data: ib_trade_historyCreateManyInput | ib_trade_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_trade_history createManyAndReturn
   */
  export type ib_trade_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data used to create many ib_trade_histories.
     */
    data: ib_trade_historyCreateManyInput | ib_trade_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_trade_history update
   */
  export type ib_trade_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_trade_history.
     */
    data: XOR<ib_trade_historyUpdateInput, ib_trade_historyUncheckedUpdateInput>
    /**
     * Choose, which ib_trade_history to update.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history updateMany
   */
  export type ib_trade_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_trade_histories.
     */
    data: XOR<ib_trade_historyUpdateManyMutationInput, ib_trade_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_trade_histories to update
     */
    where?: ib_trade_historyWhereInput
    /**
     * Limit how many ib_trade_histories to update.
     */
    limit?: number
  }

  /**
   * ib_trade_history updateManyAndReturn
   */
  export type ib_trade_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The data used to update ib_trade_histories.
     */
    data: XOR<ib_trade_historyUpdateManyMutationInput, ib_trade_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_trade_histories to update
     */
    where?: ib_trade_historyWhereInput
    /**
     * Limit how many ib_trade_histories to update.
     */
    limit?: number
  }

  /**
   * ib_trade_history upsert
   */
  export type ib_trade_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_trade_history to update in case it exists.
     */
    where: ib_trade_historyWhereUniqueInput
    /**
     * In case the ib_trade_history found by the `where` argument doesn't exist, create a new ib_trade_history with this data.
     */
    create: XOR<ib_trade_historyCreateInput, ib_trade_historyUncheckedCreateInput>
    /**
     * In case the ib_trade_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_trade_historyUpdateInput, ib_trade_historyUncheckedUpdateInput>
  }

  /**
   * ib_trade_history delete
   */
  export type ib_trade_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
    /**
     * Filter which ib_trade_history to delete.
     */
    where: ib_trade_historyWhereUniqueInput
  }

  /**
   * ib_trade_history deleteMany
   */
  export type ib_trade_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_trade_histories to delete
     */
    where?: ib_trade_historyWhereInput
    /**
     * Limit how many ib_trade_histories to delete.
     */
    limit?: number
  }

  /**
   * ib_trade_history without action
   */
  export type ib_trade_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_trade_history
     */
    select?: ib_trade_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_trade_history
     */
    omit?: ib_trade_historyOmit<ExtArgs> | null
  }


  /**
   * Model support_tickets
   */

  export type AggregateSupport_tickets = {
    _count: Support_ticketsCountAggregateOutputType | null
    _avg: Support_ticketsAvgAggregateOutputType | null
    _sum: Support_ticketsSumAggregateOutputType | null
    _min: Support_ticketsMinAggregateOutputType | null
    _max: Support_ticketsMaxAggregateOutputType | null
  }

  export type Support_ticketsAvgAggregateOutputType = {
    id: number | null
  }

  export type Support_ticketsSumAggregateOutputType = {
    id: number | null
  }

  export type Support_ticketsMinAggregateOutputType = {
    id: number | null
    ticket_no: string | null
    parent_id: string | null
    title: string | null
    description: string | null
    ticket_type: string | null
    status: string | null
    priority: string | null
    assigned_to: string | null
    account_number: string | null
    created_at: Date | null
    updated_at: Date | null
    last_reply_at: Date | null
    closed_at: Date | null
    closed_by: string | null
  }

  export type Support_ticketsMaxAggregateOutputType = {
    id: number | null
    ticket_no: string | null
    parent_id: string | null
    title: string | null
    description: string | null
    ticket_type: string | null
    status: string | null
    priority: string | null
    assigned_to: string | null
    account_number: string | null
    created_at: Date | null
    updated_at: Date | null
    last_reply_at: Date | null
    closed_at: Date | null
    closed_by: string | null
  }

  export type Support_ticketsCountAggregateOutputType = {
    id: number
    ticket_no: number
    parent_id: number
    title: number
    description: number
    ticket_type: number
    status: number
    priority: number
    assigned_to: number
    account_number: number
    tags: number
    created_at: number
    updated_at: number
    last_reply_at: number
    closed_at: number
    closed_by: number
    _all: number
  }


  export type Support_ticketsAvgAggregateInputType = {
    id?: true
  }

  export type Support_ticketsSumAggregateInputType = {
    id?: true
  }

  export type Support_ticketsMinAggregateInputType = {
    id?: true
    ticket_no?: true
    parent_id?: true
    title?: true
    description?: true
    ticket_type?: true
    status?: true
    priority?: true
    assigned_to?: true
    account_number?: true
    created_at?: true
    updated_at?: true
    last_reply_at?: true
    closed_at?: true
    closed_by?: true
  }

  export type Support_ticketsMaxAggregateInputType = {
    id?: true
    ticket_no?: true
    parent_id?: true
    title?: true
    description?: true
    ticket_type?: true
    status?: true
    priority?: true
    assigned_to?: true
    account_number?: true
    created_at?: true
    updated_at?: true
    last_reply_at?: true
    closed_at?: true
    closed_by?: true
  }

  export type Support_ticketsCountAggregateInputType = {
    id?: true
    ticket_no?: true
    parent_id?: true
    title?: true
    description?: true
    ticket_type?: true
    status?: true
    priority?: true
    assigned_to?: true
    account_number?: true
    tags?: true
    created_at?: true
    updated_at?: true
    last_reply_at?: true
    closed_at?: true
    closed_by?: true
    _all?: true
  }

  export type Support_ticketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_tickets to aggregate.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_tickets
    **/
    _count?: true | Support_ticketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_ticketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_ticketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_ticketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_ticketsMaxAggregateInputType
  }

  export type GetSupport_ticketsAggregateType<T extends Support_ticketsAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_tickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_tickets[P]>
      : GetScalarType<T[P], AggregateSupport_tickets[P]>
  }




  export type support_ticketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticketsWhereInput
    orderBy?: support_ticketsOrderByWithAggregationInput | support_ticketsOrderByWithAggregationInput[]
    by: Support_ticketsScalarFieldEnum[] | Support_ticketsScalarFieldEnum
    having?: support_ticketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_ticketsCountAggregateInputType | true
    _avg?: Support_ticketsAvgAggregateInputType
    _sum?: Support_ticketsSumAggregateInputType
    _min?: Support_ticketsMinAggregateInputType
    _max?: Support_ticketsMaxAggregateInputType
  }

  export type Support_ticketsGroupByOutputType = {
    id: number
    ticket_no: string
    parent_id: string
    title: string
    description: string | null
    ticket_type: string | null
    status: string
    priority: string
    assigned_to: string | null
    account_number: string | null
    tags: string[]
    created_at: Date
    updated_at: Date
    last_reply_at: Date | null
    closed_at: Date | null
    closed_by: string | null
    _count: Support_ticketsCountAggregateOutputType | null
    _avg: Support_ticketsAvgAggregateOutputType | null
    _sum: Support_ticketsSumAggregateOutputType | null
    _min: Support_ticketsMinAggregateOutputType | null
    _max: Support_ticketsMaxAggregateOutputType | null
  }

  type GetSupport_ticketsGroupByPayload<T extends support_ticketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_ticketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_ticketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_ticketsGroupByOutputType[P]>
            : GetScalarType<T[P], Support_ticketsGroupByOutputType[P]>
        }
      >
    >


  export type support_ticketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }, ExtArgs["result"]["support_tickets"]>

  export type support_ticketsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }, ExtArgs["result"]["support_tickets"]>

  export type support_ticketsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }, ExtArgs["result"]["support_tickets"]>

  export type support_ticketsSelectScalar = {
    id?: boolean
    ticket_no?: boolean
    parent_id?: boolean
    title?: boolean
    description?: boolean
    ticket_type?: boolean
    status?: boolean
    priority?: boolean
    assigned_to?: boolean
    account_number?: boolean
    tags?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_reply_at?: boolean
    closed_at?: boolean
    closed_by?: boolean
  }

  export type support_ticketsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_no" | "parent_id" | "title" | "description" | "ticket_type" | "status" | "priority" | "assigned_to" | "account_number" | "tags" | "created_at" | "updated_at" | "last_reply_at" | "closed_at" | "closed_by", ExtArgs["result"]["support_tickets"]>

  export type $support_ticketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_tickets"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_no: string
      parent_id: string
      title: string
      description: string | null
      ticket_type: string | null
      status: string
      priority: string
      assigned_to: string | null
      account_number: string | null
      tags: string[]
      created_at: Date
      updated_at: Date
      last_reply_at: Date | null
      closed_at: Date | null
      closed_by: string | null
    }, ExtArgs["result"]["support_tickets"]>
    composites: {}
  }

  type support_ticketsGetPayload<S extends boolean | null | undefined | support_ticketsDefaultArgs> = $Result.GetResult<Prisma.$support_ticketsPayload, S>

  type support_ticketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_ticketsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_ticketsCountAggregateInputType | true
    }

  export interface support_ticketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_tickets'], meta: { name: 'support_tickets' } }
    /**
     * Find zero or one Support_tickets that matches the filter.
     * @param {support_ticketsFindUniqueArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_ticketsFindUniqueArgs>(args: SelectSubset<T, support_ticketsFindUniqueArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_tickets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_ticketsFindUniqueOrThrowArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_ticketsFindUniqueOrThrowArgs>(args: SelectSubset<T, support_ticketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsFindFirstArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_ticketsFindFirstArgs>(args?: SelectSubset<T, support_ticketsFindFirstArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsFindFirstOrThrowArgs} args - Arguments to find a Support_tickets
     * @example
     * // Get one Support_tickets
     * const support_tickets = await prisma.support_tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_ticketsFindFirstOrThrowArgs>(args?: SelectSubset<T, support_ticketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_tickets
     * const support_tickets = await prisma.support_tickets.findMany()
     * 
     * // Get first 10 Support_tickets
     * const support_tickets = await prisma.support_tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_ticketsWithIdOnly = await prisma.support_tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_ticketsFindManyArgs>(args?: SelectSubset<T, support_ticketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_tickets.
     * @param {support_ticketsCreateArgs} args - Arguments to create a Support_tickets.
     * @example
     * // Create one Support_tickets
     * const Support_tickets = await prisma.support_tickets.create({
     *   data: {
     *     // ... data to create a Support_tickets
     *   }
     * })
     * 
     */
    create<T extends support_ticketsCreateArgs>(args: SelectSubset<T, support_ticketsCreateArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_tickets.
     * @param {support_ticketsCreateManyArgs} args - Arguments to create many Support_tickets.
     * @example
     * // Create many Support_tickets
     * const support_tickets = await prisma.support_tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_ticketsCreateManyArgs>(args?: SelectSubset<T, support_ticketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_tickets and returns the data saved in the database.
     * @param {support_ticketsCreateManyAndReturnArgs} args - Arguments to create many Support_tickets.
     * @example
     * // Create many Support_tickets
     * const support_tickets = await prisma.support_tickets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_tickets and only return the `id`
     * const support_ticketsWithIdOnly = await prisma.support_tickets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_ticketsCreateManyAndReturnArgs>(args?: SelectSubset<T, support_ticketsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_tickets.
     * @param {support_ticketsDeleteArgs} args - Arguments to delete one Support_tickets.
     * @example
     * // Delete one Support_tickets
     * const Support_tickets = await prisma.support_tickets.delete({
     *   where: {
     *     // ... filter to delete one Support_tickets
     *   }
     * })
     * 
     */
    delete<T extends support_ticketsDeleteArgs>(args: SelectSubset<T, support_ticketsDeleteArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_tickets.
     * @param {support_ticketsUpdateArgs} args - Arguments to update one Support_tickets.
     * @example
     * // Update one Support_tickets
     * const support_tickets = await prisma.support_tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_ticketsUpdateArgs>(args: SelectSubset<T, support_ticketsUpdateArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_tickets.
     * @param {support_ticketsDeleteManyArgs} args - Arguments to filter Support_tickets to delete.
     * @example
     * // Delete a few Support_tickets
     * const { count } = await prisma.support_tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_ticketsDeleteManyArgs>(args?: SelectSubset<T, support_ticketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_tickets
     * const support_tickets = await prisma.support_tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_ticketsUpdateManyArgs>(args: SelectSubset<T, support_ticketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_tickets and returns the data updated in the database.
     * @param {support_ticketsUpdateManyAndReturnArgs} args - Arguments to update many Support_tickets.
     * @example
     * // Update many Support_tickets
     * const support_tickets = await prisma.support_tickets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_tickets and only return the `id`
     * const support_ticketsWithIdOnly = await prisma.support_tickets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_ticketsUpdateManyAndReturnArgs>(args: SelectSubset<T, support_ticketsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_tickets.
     * @param {support_ticketsUpsertArgs} args - Arguments to update or create a Support_tickets.
     * @example
     * // Update or create a Support_tickets
     * const support_tickets = await prisma.support_tickets.upsert({
     *   create: {
     *     // ... data to create a Support_tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_tickets we want to update
     *   }
     * })
     */
    upsert<T extends support_ticketsUpsertArgs>(args: SelectSubset<T, support_ticketsUpsertArgs<ExtArgs>>): Prisma__support_ticketsClient<$Result.GetResult<Prisma.$support_ticketsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsCountArgs} args - Arguments to filter Support_tickets to count.
     * @example
     * // Count the number of Support_tickets
     * const count = await prisma.support_tickets.count({
     *   where: {
     *     // ... the filter for the Support_tickets we want to count
     *   }
     * })
    **/
    count<T extends support_ticketsCountArgs>(
      args?: Subset<T, support_ticketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_ticketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_ticketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_ticketsAggregateArgs>(args: Subset<T, Support_ticketsAggregateArgs>): Prisma.PrismaPromise<GetSupport_ticketsAggregateType<T>>

    /**
     * Group by Support_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_ticketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_ticketsGroupByArgs['orderBy'] }
        : { orderBy?: support_ticketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_ticketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_ticketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_tickets model
   */
  readonly fields: support_ticketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_ticketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_tickets model
   */
  interface support_ticketsFieldRefs {
    readonly id: FieldRef<"support_tickets", 'Int'>
    readonly ticket_no: FieldRef<"support_tickets", 'String'>
    readonly parent_id: FieldRef<"support_tickets", 'String'>
    readonly title: FieldRef<"support_tickets", 'String'>
    readonly description: FieldRef<"support_tickets", 'String'>
    readonly ticket_type: FieldRef<"support_tickets", 'String'>
    readonly status: FieldRef<"support_tickets", 'String'>
    readonly priority: FieldRef<"support_tickets", 'String'>
    readonly assigned_to: FieldRef<"support_tickets", 'String'>
    readonly account_number: FieldRef<"support_tickets", 'String'>
    readonly tags: FieldRef<"support_tickets", 'String[]'>
    readonly created_at: FieldRef<"support_tickets", 'DateTime'>
    readonly updated_at: FieldRef<"support_tickets", 'DateTime'>
    readonly last_reply_at: FieldRef<"support_tickets", 'DateTime'>
    readonly closed_at: FieldRef<"support_tickets", 'DateTime'>
    readonly closed_by: FieldRef<"support_tickets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * support_tickets findUnique
   */
  export type support_ticketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets findUniqueOrThrow
   */
  export type support_ticketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets findFirst
   */
  export type support_ticketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_tickets.
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_tickets.
     */
    distinct?: Support_ticketsScalarFieldEnum | Support_ticketsScalarFieldEnum[]
  }

  /**
   * support_tickets findFirstOrThrow
   */
  export type support_ticketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_tickets.
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_tickets.
     */
    distinct?: Support_ticketsScalarFieldEnum | Support_ticketsScalarFieldEnum[]
  }

  /**
   * support_tickets findMany
   */
  export type support_ticketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter, which support_tickets to fetch.
     */
    where?: support_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_tickets to fetch.
     */
    orderBy?: support_ticketsOrderByWithRelationInput | support_ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_tickets.
     */
    cursor?: support_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_tickets.
     */
    skip?: number
    distinct?: Support_ticketsScalarFieldEnum | Support_ticketsScalarFieldEnum[]
  }

  /**
   * support_tickets create
   */
  export type support_ticketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data needed to create a support_tickets.
     */
    data: XOR<support_ticketsCreateInput, support_ticketsUncheckedCreateInput>
  }

  /**
   * support_tickets createMany
   */
  export type support_ticketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_tickets.
     */
    data: support_ticketsCreateManyInput | support_ticketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_tickets createManyAndReturn
   */
  export type support_ticketsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data used to create many support_tickets.
     */
    data: support_ticketsCreateManyInput | support_ticketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_tickets update
   */
  export type support_ticketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data needed to update a support_tickets.
     */
    data: XOR<support_ticketsUpdateInput, support_ticketsUncheckedUpdateInput>
    /**
     * Choose, which support_tickets to update.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets updateMany
   */
  export type support_ticketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_tickets.
     */
    data: XOR<support_ticketsUpdateManyMutationInput, support_ticketsUncheckedUpdateManyInput>
    /**
     * Filter which support_tickets to update
     */
    where?: support_ticketsWhereInput
    /**
     * Limit how many support_tickets to update.
     */
    limit?: number
  }

  /**
   * support_tickets updateManyAndReturn
   */
  export type support_ticketsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The data used to update support_tickets.
     */
    data: XOR<support_ticketsUpdateManyMutationInput, support_ticketsUncheckedUpdateManyInput>
    /**
     * Filter which support_tickets to update
     */
    where?: support_ticketsWhereInput
    /**
     * Limit how many support_tickets to update.
     */
    limit?: number
  }

  /**
   * support_tickets upsert
   */
  export type support_ticketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * The filter to search for the support_tickets to update in case it exists.
     */
    where: support_ticketsWhereUniqueInput
    /**
     * In case the support_tickets found by the `where` argument doesn't exist, create a new support_tickets with this data.
     */
    create: XOR<support_ticketsCreateInput, support_ticketsUncheckedCreateInput>
    /**
     * In case the support_tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_ticketsUpdateInput, support_ticketsUncheckedUpdateInput>
  }

  /**
   * support_tickets delete
   */
  export type support_ticketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
    /**
     * Filter which support_tickets to delete.
     */
    where: support_ticketsWhereUniqueInput
  }

  /**
   * support_tickets deleteMany
   */
  export type support_ticketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_tickets to delete
     */
    where?: support_ticketsWhereInput
    /**
     * Limit how many support_tickets to delete.
     */
    limit?: number
  }

  /**
   * support_tickets without action
   */
  export type support_ticketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_tickets
     */
    select?: support_ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_tickets
     */
    omit?: support_ticketsOmit<ExtArgs> | null
  }


  /**
   * Model support_ticket_replies
   */

  export type AggregateSupport_ticket_replies = {
    _count: Support_ticket_repliesCountAggregateOutputType | null
    _avg: Support_ticket_repliesAvgAggregateOutputType | null
    _sum: Support_ticket_repliesSumAggregateOutputType | null
    _min: Support_ticket_repliesMinAggregateOutputType | null
    _max: Support_ticket_repliesMaxAggregateOutputType | null
  }

  export type Support_ticket_repliesAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
  }

  export type Support_ticket_repliesSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
  }

  export type Support_ticket_repliesMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_read: boolean | null
  }

  export type Support_ticket_repliesMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    reply_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
    updated_at: Date | null
    is_read: boolean | null
  }

  export type Support_ticket_repliesCountAggregateOutputType = {
    id: number
    ticket_id: number
    reply_id: number
    sender_id: number
    sender_name: number
    sender_type: number
    content: number
    is_internal: number
    attachments: number
    created_at: number
    updated_at: number
    is_read: number
    _all: number
  }


  export type Support_ticket_repliesAvgAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
  }

  export type Support_ticket_repliesSumAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
  }

  export type Support_ticket_repliesMinAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
    updated_at?: true
    is_read?: true
  }

  export type Support_ticket_repliesMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
    updated_at?: true
    is_read?: true
  }

  export type Support_ticket_repliesCountAggregateInputType = {
    id?: true
    ticket_id?: true
    reply_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    attachments?: true
    created_at?: true
    updated_at?: true
    is_read?: true
    _all?: true
  }

  export type Support_ticket_repliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_ticket_replies to aggregate.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_ticket_replies
    **/
    _count?: true | Support_ticket_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_ticket_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_ticket_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_ticket_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_ticket_repliesMaxAggregateInputType
  }

  export type GetSupport_ticket_repliesAggregateType<T extends Support_ticket_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_ticket_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_ticket_replies[P]>
      : GetScalarType<T[P], AggregateSupport_ticket_replies[P]>
  }




  export type support_ticket_repliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_ticket_repliesWhereInput
    orderBy?: support_ticket_repliesOrderByWithAggregationInput | support_ticket_repliesOrderByWithAggregationInput[]
    by: Support_ticket_repliesScalarFieldEnum[] | Support_ticket_repliesScalarFieldEnum
    having?: support_ticket_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_ticket_repliesCountAggregateInputType | true
    _avg?: Support_ticket_repliesAvgAggregateInputType
    _sum?: Support_ticket_repliesSumAggregateInputType
    _min?: Support_ticket_repliesMinAggregateInputType
    _max?: Support_ticket_repliesMaxAggregateInputType
  }

  export type Support_ticket_repliesGroupByOutputType = {
    id: number
    ticket_id: number
    reply_id: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal: boolean
    attachments: string[]
    created_at: Date
    updated_at: Date
    is_read: boolean
    _count: Support_ticket_repliesCountAggregateOutputType | null
    _avg: Support_ticket_repliesAvgAggregateOutputType | null
    _sum: Support_ticket_repliesSumAggregateOutputType | null
    _min: Support_ticket_repliesMinAggregateOutputType | null
    _max: Support_ticket_repliesMaxAggregateOutputType | null
  }

  type GetSupport_ticket_repliesGroupByPayload<T extends support_ticket_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_ticket_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_ticket_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_ticket_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_ticket_repliesGroupByOutputType[P]>
        }
      >
    >


  export type support_ticket_repliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }, ExtArgs["result"]["support_ticket_replies"]>

  export type support_ticket_repliesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }, ExtArgs["result"]["support_ticket_replies"]>

  export type support_ticket_repliesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }, ExtArgs["result"]["support_ticket_replies"]>

  export type support_ticket_repliesSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    reply_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    attachments?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_read?: boolean
  }

  export type support_ticket_repliesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "reply_id" | "sender_id" | "sender_name" | "sender_type" | "content" | "is_internal" | "attachments" | "created_at" | "updated_at" | "is_read", ExtArgs["result"]["support_ticket_replies"]>

  export type $support_ticket_repliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_ticket_replies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      reply_id: number | null
      sender_id: string
      sender_name: string
      sender_type: string
      content: string
      is_internal: boolean
      attachments: string[]
      created_at: Date
      updated_at: Date
      is_read: boolean
    }, ExtArgs["result"]["support_ticket_replies"]>
    composites: {}
  }

  type support_ticket_repliesGetPayload<S extends boolean | null | undefined | support_ticket_repliesDefaultArgs> = $Result.GetResult<Prisma.$support_ticket_repliesPayload, S>

  type support_ticket_repliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_ticket_repliesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_ticket_repliesCountAggregateInputType | true
    }

  export interface support_ticket_repliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_ticket_replies'], meta: { name: 'support_ticket_replies' } }
    /**
     * Find zero or one Support_ticket_replies that matches the filter.
     * @param {support_ticket_repliesFindUniqueArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_ticket_repliesFindUniqueArgs>(args: SelectSubset<T, support_ticket_repliesFindUniqueArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_ticket_replies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_ticket_repliesFindUniqueOrThrowArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_ticket_repliesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_ticket_repliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_ticket_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesFindFirstArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_ticket_repliesFindFirstArgs>(args?: SelectSubset<T, support_ticket_repliesFindFirstArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_ticket_replies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesFindFirstOrThrowArgs} args - Arguments to find a Support_ticket_replies
     * @example
     * // Get one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_ticket_repliesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_ticket_repliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_ticket_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findMany()
     * 
     * // Get first 10 Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_ticket_repliesWithIdOnly = await prisma.support_ticket_replies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_ticket_repliesFindManyArgs>(args?: SelectSubset<T, support_ticket_repliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_ticket_replies.
     * @param {support_ticket_repliesCreateArgs} args - Arguments to create a Support_ticket_replies.
     * @example
     * // Create one Support_ticket_replies
     * const Support_ticket_replies = await prisma.support_ticket_replies.create({
     *   data: {
     *     // ... data to create a Support_ticket_replies
     *   }
     * })
     * 
     */
    create<T extends support_ticket_repliesCreateArgs>(args: SelectSubset<T, support_ticket_repliesCreateArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_ticket_replies.
     * @param {support_ticket_repliesCreateManyArgs} args - Arguments to create many Support_ticket_replies.
     * @example
     * // Create many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_ticket_repliesCreateManyArgs>(args?: SelectSubset<T, support_ticket_repliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_ticket_replies and returns the data saved in the database.
     * @param {support_ticket_repliesCreateManyAndReturnArgs} args - Arguments to create many Support_ticket_replies.
     * @example
     * // Create many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_ticket_replies and only return the `id`
     * const support_ticket_repliesWithIdOnly = await prisma.support_ticket_replies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_ticket_repliesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_ticket_repliesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_ticket_replies.
     * @param {support_ticket_repliesDeleteArgs} args - Arguments to delete one Support_ticket_replies.
     * @example
     * // Delete one Support_ticket_replies
     * const Support_ticket_replies = await prisma.support_ticket_replies.delete({
     *   where: {
     *     // ... filter to delete one Support_ticket_replies
     *   }
     * })
     * 
     */
    delete<T extends support_ticket_repliesDeleteArgs>(args: SelectSubset<T, support_ticket_repliesDeleteArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_ticket_replies.
     * @param {support_ticket_repliesUpdateArgs} args - Arguments to update one Support_ticket_replies.
     * @example
     * // Update one Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_ticket_repliesUpdateArgs>(args: SelectSubset<T, support_ticket_repliesUpdateArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_ticket_replies.
     * @param {support_ticket_repliesDeleteManyArgs} args - Arguments to filter Support_ticket_replies to delete.
     * @example
     * // Delete a few Support_ticket_replies
     * const { count } = await prisma.support_ticket_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_ticket_repliesDeleteManyArgs>(args?: SelectSubset<T, support_ticket_repliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_ticket_repliesUpdateManyArgs>(args: SelectSubset<T, support_ticket_repliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_ticket_replies and returns the data updated in the database.
     * @param {support_ticket_repliesUpdateManyAndReturnArgs} args - Arguments to update many Support_ticket_replies.
     * @example
     * // Update many Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_ticket_replies and only return the `id`
     * const support_ticket_repliesWithIdOnly = await prisma.support_ticket_replies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_ticket_repliesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_ticket_repliesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_ticket_replies.
     * @param {support_ticket_repliesUpsertArgs} args - Arguments to update or create a Support_ticket_replies.
     * @example
     * // Update or create a Support_ticket_replies
     * const support_ticket_replies = await prisma.support_ticket_replies.upsert({
     *   create: {
     *     // ... data to create a Support_ticket_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_ticket_replies we want to update
     *   }
     * })
     */
    upsert<T extends support_ticket_repliesUpsertArgs>(args: SelectSubset<T, support_ticket_repliesUpsertArgs<ExtArgs>>): Prisma__support_ticket_repliesClient<$Result.GetResult<Prisma.$support_ticket_repliesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesCountArgs} args - Arguments to filter Support_ticket_replies to count.
     * @example
     * // Count the number of Support_ticket_replies
     * const count = await prisma.support_ticket_replies.count({
     *   where: {
     *     // ... the filter for the Support_ticket_replies we want to count
     *   }
     * })
    **/
    count<T extends support_ticket_repliesCountArgs>(
      args?: Subset<T, support_ticket_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_ticket_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_ticket_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_ticket_repliesAggregateArgs>(args: Subset<T, Support_ticket_repliesAggregateArgs>): Prisma.PrismaPromise<GetSupport_ticket_repliesAggregateType<T>>

    /**
     * Group by Support_ticket_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_ticket_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_ticket_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_ticket_repliesGroupByArgs['orderBy'] }
        : { orderBy?: support_ticket_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_ticket_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_ticket_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_ticket_replies model
   */
  readonly fields: support_ticket_repliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_ticket_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_ticket_repliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_ticket_replies model
   */
  interface support_ticket_repliesFieldRefs {
    readonly id: FieldRef<"support_ticket_replies", 'Int'>
    readonly ticket_id: FieldRef<"support_ticket_replies", 'Int'>
    readonly reply_id: FieldRef<"support_ticket_replies", 'Int'>
    readonly sender_id: FieldRef<"support_ticket_replies", 'String'>
    readonly sender_name: FieldRef<"support_ticket_replies", 'String'>
    readonly sender_type: FieldRef<"support_ticket_replies", 'String'>
    readonly content: FieldRef<"support_ticket_replies", 'String'>
    readonly is_internal: FieldRef<"support_ticket_replies", 'Boolean'>
    readonly attachments: FieldRef<"support_ticket_replies", 'String[]'>
    readonly created_at: FieldRef<"support_ticket_replies", 'DateTime'>
    readonly updated_at: FieldRef<"support_ticket_replies", 'DateTime'>
    readonly is_read: FieldRef<"support_ticket_replies", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * support_ticket_replies findUnique
   */
  export type support_ticket_repliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies findUniqueOrThrow
   */
  export type support_ticket_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies findFirst
   */
  export type support_ticket_repliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_ticket_replies.
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_ticket_replies.
     */
    distinct?: Support_ticket_repliesScalarFieldEnum | Support_ticket_repliesScalarFieldEnum[]
  }

  /**
   * support_ticket_replies findFirstOrThrow
   */
  export type support_ticket_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_ticket_replies.
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_ticket_replies.
     */
    distinct?: Support_ticket_repliesScalarFieldEnum | Support_ticket_repliesScalarFieldEnum[]
  }

  /**
   * support_ticket_replies findMany
   */
  export type support_ticket_repliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_ticket_replies to fetch.
     */
    where?: support_ticket_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_ticket_replies to fetch.
     */
    orderBy?: support_ticket_repliesOrderByWithRelationInput | support_ticket_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_ticket_replies.
     */
    cursor?: support_ticket_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_ticket_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_ticket_replies.
     */
    skip?: number
    distinct?: Support_ticket_repliesScalarFieldEnum | Support_ticket_repliesScalarFieldEnum[]
  }

  /**
   * support_ticket_replies create
   */
  export type support_ticket_repliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_ticket_replies.
     */
    data: XOR<support_ticket_repliesCreateInput, support_ticket_repliesUncheckedCreateInput>
  }

  /**
   * support_ticket_replies createMany
   */
  export type support_ticket_repliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_ticket_replies.
     */
    data: support_ticket_repliesCreateManyInput | support_ticket_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_ticket_replies createManyAndReturn
   */
  export type support_ticket_repliesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data used to create many support_ticket_replies.
     */
    data: support_ticket_repliesCreateManyInput | support_ticket_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_ticket_replies update
   */
  export type support_ticket_repliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_ticket_replies.
     */
    data: XOR<support_ticket_repliesUpdateInput, support_ticket_repliesUncheckedUpdateInput>
    /**
     * Choose, which support_ticket_replies to update.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies updateMany
   */
  export type support_ticket_repliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_ticket_replies.
     */
    data: XOR<support_ticket_repliesUpdateManyMutationInput, support_ticket_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_ticket_replies to update
     */
    where?: support_ticket_repliesWhereInput
    /**
     * Limit how many support_ticket_replies to update.
     */
    limit?: number
  }

  /**
   * support_ticket_replies updateManyAndReturn
   */
  export type support_ticket_repliesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The data used to update support_ticket_replies.
     */
    data: XOR<support_ticket_repliesUpdateManyMutationInput, support_ticket_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_ticket_replies to update
     */
    where?: support_ticket_repliesWhereInput
    /**
     * Limit how many support_ticket_replies to update.
     */
    limit?: number
  }

  /**
   * support_ticket_replies upsert
   */
  export type support_ticket_repliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_ticket_replies to update in case it exists.
     */
    where: support_ticket_repliesWhereUniqueInput
    /**
     * In case the support_ticket_replies found by the `where` argument doesn't exist, create a new support_ticket_replies with this data.
     */
    create: XOR<support_ticket_repliesCreateInput, support_ticket_repliesUncheckedCreateInput>
    /**
     * In case the support_ticket_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_ticket_repliesUpdateInput, support_ticket_repliesUncheckedUpdateInput>
  }

  /**
   * support_ticket_replies delete
   */
  export type support_ticket_repliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
    /**
     * Filter which support_ticket_replies to delete.
     */
    where: support_ticket_repliesWhereUniqueInput
  }

  /**
   * support_ticket_replies deleteMany
   */
  export type support_ticket_repliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_ticket_replies to delete
     */
    where?: support_ticket_repliesWhereInput
    /**
     * Limit how many support_ticket_replies to delete.
     */
    limit?: number
  }

  /**
   * support_ticket_replies without action
   */
  export type support_ticket_repliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_ticket_replies
     */
    select?: support_ticket_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_ticket_replies
     */
    omit?: support_ticket_repliesOmit<ExtArgs> | null
  }


  /**
   * Model support_articles
   */

  export type AggregateSupport_articles = {
    _count: Support_articlesCountAggregateOutputType | null
    _avg: Support_articlesAvgAggregateOutputType | null
    _sum: Support_articlesSumAggregateOutputType | null
    _min: Support_articlesMinAggregateOutputType | null
    _max: Support_articlesMaxAggregateOutputType | null
  }

  export type Support_articlesAvgAggregateOutputType = {
    id: number | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
  }

  export type Support_articlesSumAggregateOutputType = {
    id: number | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
  }

  export type Support_articlesMinAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    category: string | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    is_published: boolean | null
    author_id: string | null
    created_at: Date | null
    updated_at: Date | null
    published_at: Date | null
  }

  export type Support_articlesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    category: string | null
    views: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    is_published: boolean | null
    author_id: string | null
    created_at: Date | null
    updated_at: Date | null
    published_at: Date | null
  }

  export type Support_articlesCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    excerpt: number
    category: number
    tags: number
    views: number
    helpful_count: number
    not_helpful_count: number
    is_published: number
    author_id: number
    created_at: number
    updated_at: number
    published_at: number
    _all: number
  }


  export type Support_articlesAvgAggregateInputType = {
    id?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
  }

  export type Support_articlesSumAggregateInputType = {
    id?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
  }

  export type Support_articlesMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    category?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
    is_published?: true
    author_id?: true
    created_at?: true
    updated_at?: true
    published_at?: true
  }

  export type Support_articlesMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    category?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
    is_published?: true
    author_id?: true
    created_at?: true
    updated_at?: true
    published_at?: true
  }

  export type Support_articlesCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    category?: true
    tags?: true
    views?: true
    helpful_count?: true
    not_helpful_count?: true
    is_published?: true
    author_id?: true
    created_at?: true
    updated_at?: true
    published_at?: true
    _all?: true
  }

  export type Support_articlesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_articles to aggregate.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_articles
    **/
    _count?: true | Support_articlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_articlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_articlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_articlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_articlesMaxAggregateInputType
  }

  export type GetSupport_articlesAggregateType<T extends Support_articlesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_articles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_articles[P]>
      : GetScalarType<T[P], AggregateSupport_articles[P]>
  }




  export type support_articlesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_articlesWhereInput
    orderBy?: support_articlesOrderByWithAggregationInput | support_articlesOrderByWithAggregationInput[]
    by: Support_articlesScalarFieldEnum[] | Support_articlesScalarFieldEnum
    having?: support_articlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_articlesCountAggregateInputType | true
    _avg?: Support_articlesAvgAggregateInputType
    _sum?: Support_articlesSumAggregateInputType
    _min?: Support_articlesMinAggregateInputType
    _max?: Support_articlesMaxAggregateInputType
  }

  export type Support_articlesGroupByOutputType = {
    id: number
    title: string
    slug: string
    content: string
    excerpt: string | null
    category: string
    tags: string[]
    views: number
    helpful_count: number
    not_helpful_count: number
    is_published: boolean
    author_id: string
    created_at: Date
    updated_at: Date
    published_at: Date | null
    _count: Support_articlesCountAggregateOutputType | null
    _avg: Support_articlesAvgAggregateOutputType | null
    _sum: Support_articlesSumAggregateOutputType | null
    _min: Support_articlesMinAggregateOutputType | null
    _max: Support_articlesMaxAggregateOutputType | null
  }

  type GetSupport_articlesGroupByPayload<T extends support_articlesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_articlesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_articlesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_articlesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_articlesGroupByOutputType[P]>
        }
      >
    >


  export type support_articlesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }, ExtArgs["result"]["support_articles"]>

  export type support_articlesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }, ExtArgs["result"]["support_articles"]>

  export type support_articlesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }, ExtArgs["result"]["support_articles"]>

  export type support_articlesSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    category?: boolean
    tags?: boolean
    views?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    is_published?: boolean
    author_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    published_at?: boolean
  }

  export type support_articlesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "excerpt" | "category" | "tags" | "views" | "helpful_count" | "not_helpful_count" | "is_published" | "author_id" | "created_at" | "updated_at" | "published_at", ExtArgs["result"]["support_articles"]>

  export type $support_articlesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_articles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      slug: string
      content: string
      excerpt: string | null
      category: string
      tags: string[]
      views: number
      helpful_count: number
      not_helpful_count: number
      is_published: boolean
      author_id: string
      created_at: Date
      updated_at: Date
      published_at: Date | null
    }, ExtArgs["result"]["support_articles"]>
    composites: {}
  }

  type support_articlesGetPayload<S extends boolean | null | undefined | support_articlesDefaultArgs> = $Result.GetResult<Prisma.$support_articlesPayload, S>

  type support_articlesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_articlesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_articlesCountAggregateInputType | true
    }

  export interface support_articlesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_articles'], meta: { name: 'support_articles' } }
    /**
     * Find zero or one Support_articles that matches the filter.
     * @param {support_articlesFindUniqueArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_articlesFindUniqueArgs>(args: SelectSubset<T, support_articlesFindUniqueArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_articles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_articlesFindUniqueOrThrowArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_articlesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_articlesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesFindFirstArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_articlesFindFirstArgs>(args?: SelectSubset<T, support_articlesFindFirstArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_articles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesFindFirstOrThrowArgs} args - Arguments to find a Support_articles
     * @example
     * // Get one Support_articles
     * const support_articles = await prisma.support_articles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_articlesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_articlesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_articles
     * const support_articles = await prisma.support_articles.findMany()
     * 
     * // Get first 10 Support_articles
     * const support_articles = await prisma.support_articles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_articlesWithIdOnly = await prisma.support_articles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_articlesFindManyArgs>(args?: SelectSubset<T, support_articlesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_articles.
     * @param {support_articlesCreateArgs} args - Arguments to create a Support_articles.
     * @example
     * // Create one Support_articles
     * const Support_articles = await prisma.support_articles.create({
     *   data: {
     *     // ... data to create a Support_articles
     *   }
     * })
     * 
     */
    create<T extends support_articlesCreateArgs>(args: SelectSubset<T, support_articlesCreateArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_articles.
     * @param {support_articlesCreateManyArgs} args - Arguments to create many Support_articles.
     * @example
     * // Create many Support_articles
     * const support_articles = await prisma.support_articles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_articlesCreateManyArgs>(args?: SelectSubset<T, support_articlesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_articles and returns the data saved in the database.
     * @param {support_articlesCreateManyAndReturnArgs} args - Arguments to create many Support_articles.
     * @example
     * // Create many Support_articles
     * const support_articles = await prisma.support_articles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_articles and only return the `id`
     * const support_articlesWithIdOnly = await prisma.support_articles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_articlesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_articlesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_articles.
     * @param {support_articlesDeleteArgs} args - Arguments to delete one Support_articles.
     * @example
     * // Delete one Support_articles
     * const Support_articles = await prisma.support_articles.delete({
     *   where: {
     *     // ... filter to delete one Support_articles
     *   }
     * })
     * 
     */
    delete<T extends support_articlesDeleteArgs>(args: SelectSubset<T, support_articlesDeleteArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_articles.
     * @param {support_articlesUpdateArgs} args - Arguments to update one Support_articles.
     * @example
     * // Update one Support_articles
     * const support_articles = await prisma.support_articles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_articlesUpdateArgs>(args: SelectSubset<T, support_articlesUpdateArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_articles.
     * @param {support_articlesDeleteManyArgs} args - Arguments to filter Support_articles to delete.
     * @example
     * // Delete a few Support_articles
     * const { count } = await prisma.support_articles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_articlesDeleteManyArgs>(args?: SelectSubset<T, support_articlesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_articles
     * const support_articles = await prisma.support_articles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_articlesUpdateManyArgs>(args: SelectSubset<T, support_articlesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_articles and returns the data updated in the database.
     * @param {support_articlesUpdateManyAndReturnArgs} args - Arguments to update many Support_articles.
     * @example
     * // Update many Support_articles
     * const support_articles = await prisma.support_articles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_articles and only return the `id`
     * const support_articlesWithIdOnly = await prisma.support_articles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_articlesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_articlesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_articles.
     * @param {support_articlesUpsertArgs} args - Arguments to update or create a Support_articles.
     * @example
     * // Update or create a Support_articles
     * const support_articles = await prisma.support_articles.upsert({
     *   create: {
     *     // ... data to create a Support_articles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_articles we want to update
     *   }
     * })
     */
    upsert<T extends support_articlesUpsertArgs>(args: SelectSubset<T, support_articlesUpsertArgs<ExtArgs>>): Prisma__support_articlesClient<$Result.GetResult<Prisma.$support_articlesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesCountArgs} args - Arguments to filter Support_articles to count.
     * @example
     * // Count the number of Support_articles
     * const count = await prisma.support_articles.count({
     *   where: {
     *     // ... the filter for the Support_articles we want to count
     *   }
     * })
    **/
    count<T extends support_articlesCountArgs>(
      args?: Subset<T, support_articlesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_articlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_articlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_articlesAggregateArgs>(args: Subset<T, Support_articlesAggregateArgs>): Prisma.PrismaPromise<GetSupport_articlesAggregateType<T>>

    /**
     * Group by Support_articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_articlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_articlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_articlesGroupByArgs['orderBy'] }
        : { orderBy?: support_articlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_articlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_articlesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_articles model
   */
  readonly fields: support_articlesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_articles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_articlesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_articles model
   */
  interface support_articlesFieldRefs {
    readonly id: FieldRef<"support_articles", 'Int'>
    readonly title: FieldRef<"support_articles", 'String'>
    readonly slug: FieldRef<"support_articles", 'String'>
    readonly content: FieldRef<"support_articles", 'String'>
    readonly excerpt: FieldRef<"support_articles", 'String'>
    readonly category: FieldRef<"support_articles", 'String'>
    readonly tags: FieldRef<"support_articles", 'String[]'>
    readonly views: FieldRef<"support_articles", 'Int'>
    readonly helpful_count: FieldRef<"support_articles", 'Int'>
    readonly not_helpful_count: FieldRef<"support_articles", 'Int'>
    readonly is_published: FieldRef<"support_articles", 'Boolean'>
    readonly author_id: FieldRef<"support_articles", 'String'>
    readonly created_at: FieldRef<"support_articles", 'DateTime'>
    readonly updated_at: FieldRef<"support_articles", 'DateTime'>
    readonly published_at: FieldRef<"support_articles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_articles findUnique
   */
  export type support_articlesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles findUniqueOrThrow
   */
  export type support_articlesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles findFirst
   */
  export type support_articlesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_articles.
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_articles.
     */
    distinct?: Support_articlesScalarFieldEnum | Support_articlesScalarFieldEnum[]
  }

  /**
   * support_articles findFirstOrThrow
   */
  export type support_articlesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_articles.
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_articles.
     */
    distinct?: Support_articlesScalarFieldEnum | Support_articlesScalarFieldEnum[]
  }

  /**
   * support_articles findMany
   */
  export type support_articlesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter, which support_articles to fetch.
     */
    where?: support_articlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_articles to fetch.
     */
    orderBy?: support_articlesOrderByWithRelationInput | support_articlesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_articles.
     */
    cursor?: support_articlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_articles.
     */
    skip?: number
    distinct?: Support_articlesScalarFieldEnum | Support_articlesScalarFieldEnum[]
  }

  /**
   * support_articles create
   */
  export type support_articlesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_articles.
     */
    data: XOR<support_articlesCreateInput, support_articlesUncheckedCreateInput>
  }

  /**
   * support_articles createMany
   */
  export type support_articlesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_articles.
     */
    data: support_articlesCreateManyInput | support_articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_articles createManyAndReturn
   */
  export type support_articlesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data used to create many support_articles.
     */
    data: support_articlesCreateManyInput | support_articlesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_articles update
   */
  export type support_articlesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_articles.
     */
    data: XOR<support_articlesUpdateInput, support_articlesUncheckedUpdateInput>
    /**
     * Choose, which support_articles to update.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles updateMany
   */
  export type support_articlesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_articles.
     */
    data: XOR<support_articlesUpdateManyMutationInput, support_articlesUncheckedUpdateManyInput>
    /**
     * Filter which support_articles to update
     */
    where?: support_articlesWhereInput
    /**
     * Limit how many support_articles to update.
     */
    limit?: number
  }

  /**
   * support_articles updateManyAndReturn
   */
  export type support_articlesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The data used to update support_articles.
     */
    data: XOR<support_articlesUpdateManyMutationInput, support_articlesUncheckedUpdateManyInput>
    /**
     * Filter which support_articles to update
     */
    where?: support_articlesWhereInput
    /**
     * Limit how many support_articles to update.
     */
    limit?: number
  }

  /**
   * support_articles upsert
   */
  export type support_articlesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_articles to update in case it exists.
     */
    where: support_articlesWhereUniqueInput
    /**
     * In case the support_articles found by the `where` argument doesn't exist, create a new support_articles with this data.
     */
    create: XOR<support_articlesCreateInput, support_articlesUncheckedCreateInput>
    /**
     * In case the support_articles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_articlesUpdateInput, support_articlesUncheckedUpdateInput>
  }

  /**
   * support_articles delete
   */
  export type support_articlesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
    /**
     * Filter which support_articles to delete.
     */
    where: support_articlesWhereUniqueInput
  }

  /**
   * support_articles deleteMany
   */
  export type support_articlesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_articles to delete
     */
    where?: support_articlesWhereInput
    /**
     * Limit how many support_articles to delete.
     */
    limit?: number
  }

  /**
   * support_articles without action
   */
  export type support_articlesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_articles
     */
    select?: support_articlesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_articles
     */
    omit?: support_articlesOmit<ExtArgs> | null
  }


  /**
   * Model support_faq
   */

  export type AggregateSupport_faq = {
    _count: Support_faqCountAggregateOutputType | null
    _avg: Support_faqAvgAggregateOutputType | null
    _sum: Support_faqSumAggregateOutputType | null
    _min: Support_faqMinAggregateOutputType | null
    _max: Support_faqMaxAggregateOutputType | null
  }

  export type Support_faqAvgAggregateOutputType = {
    id: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
  }

  export type Support_faqSumAggregateOutputType = {
    id: number | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
  }

  export type Support_faqMinAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    category: string | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_faqMaxAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    category: string | null
    helpful_count: number | null
    not_helpful_count: number | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_faqCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    tags: number
    helpful_count: number
    not_helpful_count: number
    display_order: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Support_faqAvgAggregateInputType = {
    id?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
  }

  export type Support_faqSumAggregateInputType = {
    id?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
  }

  export type Support_faqMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_faqMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_faqCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    tags?: true
    helpful_count?: true
    not_helpful_count?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Support_faqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_faq to aggregate.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_faqs
    **/
    _count?: true | Support_faqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_faqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_faqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_faqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_faqMaxAggregateInputType
  }

  export type GetSupport_faqAggregateType<T extends Support_faqAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_faq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_faq[P]>
      : GetScalarType<T[P], AggregateSupport_faq[P]>
  }




  export type support_faqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_faqWhereInput
    orderBy?: support_faqOrderByWithAggregationInput | support_faqOrderByWithAggregationInput[]
    by: Support_faqScalarFieldEnum[] | Support_faqScalarFieldEnum
    having?: support_faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_faqCountAggregateInputType | true
    _avg?: Support_faqAvgAggregateInputType
    _sum?: Support_faqSumAggregateInputType
    _min?: Support_faqMinAggregateInputType
    _max?: Support_faqMaxAggregateInputType
  }

  export type Support_faqGroupByOutputType = {
    id: number
    question: string
    answer: string
    category: string
    tags: string[]
    helpful_count: number
    not_helpful_count: number
    display_order: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Support_faqCountAggregateOutputType | null
    _avg: Support_faqAvgAggregateOutputType | null
    _sum: Support_faqSumAggregateOutputType | null
    _min: Support_faqMinAggregateOutputType | null
    _max: Support_faqMaxAggregateOutputType | null
  }

  type GetSupport_faqGroupByPayload<T extends support_faqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_faqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_faqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_faqGroupByOutputType[P]>
            : GetScalarType<T[P], Support_faqGroupByOutputType[P]>
        }
      >
    >


  export type support_faqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_faq"]>

  export type support_faqSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_faq"]>

  export type support_faqSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_faq"]>

  export type support_faqSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    tags?: boolean
    helpful_count?: boolean
    not_helpful_count?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type support_faqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "category" | "tags" | "helpful_count" | "not_helpful_count" | "display_order" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["support_faq"]>

  export type $support_faqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_faq"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      answer: string
      category: string
      tags: string[]
      helpful_count: number
      not_helpful_count: number
      display_order: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["support_faq"]>
    composites: {}
  }

  type support_faqGetPayload<S extends boolean | null | undefined | support_faqDefaultArgs> = $Result.GetResult<Prisma.$support_faqPayload, S>

  type support_faqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_faqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_faqCountAggregateInputType | true
    }

  export interface support_faqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_faq'], meta: { name: 'support_faq' } }
    /**
     * Find zero or one Support_faq that matches the filter.
     * @param {support_faqFindUniqueArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_faqFindUniqueArgs>(args: SelectSubset<T, support_faqFindUniqueArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_faqFindUniqueOrThrowArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_faqFindUniqueOrThrowArgs>(args: SelectSubset<T, support_faqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqFindFirstArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_faqFindFirstArgs>(args?: SelectSubset<T, support_faqFindFirstArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqFindFirstOrThrowArgs} args - Arguments to find a Support_faq
     * @example
     * // Get one Support_faq
     * const support_faq = await prisma.support_faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_faqFindFirstOrThrowArgs>(args?: SelectSubset<T, support_faqFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_faqs
     * const support_faqs = await prisma.support_faq.findMany()
     * 
     * // Get first 10 Support_faqs
     * const support_faqs = await prisma.support_faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_faqWithIdOnly = await prisma.support_faq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_faqFindManyArgs>(args?: SelectSubset<T, support_faqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_faq.
     * @param {support_faqCreateArgs} args - Arguments to create a Support_faq.
     * @example
     * // Create one Support_faq
     * const Support_faq = await prisma.support_faq.create({
     *   data: {
     *     // ... data to create a Support_faq
     *   }
     * })
     * 
     */
    create<T extends support_faqCreateArgs>(args: SelectSubset<T, support_faqCreateArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_faqs.
     * @param {support_faqCreateManyArgs} args - Arguments to create many Support_faqs.
     * @example
     * // Create many Support_faqs
     * const support_faq = await prisma.support_faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_faqCreateManyArgs>(args?: SelectSubset<T, support_faqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_faqs and returns the data saved in the database.
     * @param {support_faqCreateManyAndReturnArgs} args - Arguments to create many Support_faqs.
     * @example
     * // Create many Support_faqs
     * const support_faq = await prisma.support_faq.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_faqs and only return the `id`
     * const support_faqWithIdOnly = await prisma.support_faq.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_faqCreateManyAndReturnArgs>(args?: SelectSubset<T, support_faqCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_faq.
     * @param {support_faqDeleteArgs} args - Arguments to delete one Support_faq.
     * @example
     * // Delete one Support_faq
     * const Support_faq = await prisma.support_faq.delete({
     *   where: {
     *     // ... filter to delete one Support_faq
     *   }
     * })
     * 
     */
    delete<T extends support_faqDeleteArgs>(args: SelectSubset<T, support_faqDeleteArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_faq.
     * @param {support_faqUpdateArgs} args - Arguments to update one Support_faq.
     * @example
     * // Update one Support_faq
     * const support_faq = await prisma.support_faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_faqUpdateArgs>(args: SelectSubset<T, support_faqUpdateArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_faqs.
     * @param {support_faqDeleteManyArgs} args - Arguments to filter Support_faqs to delete.
     * @example
     * // Delete a few Support_faqs
     * const { count } = await prisma.support_faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_faqDeleteManyArgs>(args?: SelectSubset<T, support_faqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_faqs
     * const support_faq = await prisma.support_faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_faqUpdateManyArgs>(args: SelectSubset<T, support_faqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_faqs and returns the data updated in the database.
     * @param {support_faqUpdateManyAndReturnArgs} args - Arguments to update many Support_faqs.
     * @example
     * // Update many Support_faqs
     * const support_faq = await prisma.support_faq.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_faqs and only return the `id`
     * const support_faqWithIdOnly = await prisma.support_faq.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_faqUpdateManyAndReturnArgs>(args: SelectSubset<T, support_faqUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_faq.
     * @param {support_faqUpsertArgs} args - Arguments to update or create a Support_faq.
     * @example
     * // Update or create a Support_faq
     * const support_faq = await prisma.support_faq.upsert({
     *   create: {
     *     // ... data to create a Support_faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_faq we want to update
     *   }
     * })
     */
    upsert<T extends support_faqUpsertArgs>(args: SelectSubset<T, support_faqUpsertArgs<ExtArgs>>): Prisma__support_faqClient<$Result.GetResult<Prisma.$support_faqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqCountArgs} args - Arguments to filter Support_faqs to count.
     * @example
     * // Count the number of Support_faqs
     * const count = await prisma.support_faq.count({
     *   where: {
     *     // ... the filter for the Support_faqs we want to count
     *   }
     * })
    **/
    count<T extends support_faqCountArgs>(
      args?: Subset<T, support_faqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_faqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_faqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_faqAggregateArgs>(args: Subset<T, Support_faqAggregateArgs>): Prisma.PrismaPromise<GetSupport_faqAggregateType<T>>

    /**
     * Group by Support_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_faqGroupByArgs['orderBy'] }
        : { orderBy?: support_faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_faqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_faq model
   */
  readonly fields: support_faqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_faqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_faq model
   */
  interface support_faqFieldRefs {
    readonly id: FieldRef<"support_faq", 'Int'>
    readonly question: FieldRef<"support_faq", 'String'>
    readonly answer: FieldRef<"support_faq", 'String'>
    readonly category: FieldRef<"support_faq", 'String'>
    readonly tags: FieldRef<"support_faq", 'String[]'>
    readonly helpful_count: FieldRef<"support_faq", 'Int'>
    readonly not_helpful_count: FieldRef<"support_faq", 'Int'>
    readonly display_order: FieldRef<"support_faq", 'Int'>
    readonly is_active: FieldRef<"support_faq", 'Boolean'>
    readonly created_at: FieldRef<"support_faq", 'DateTime'>
    readonly updated_at: FieldRef<"support_faq", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_faq findUnique
   */
  export type support_faqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq findUniqueOrThrow
   */
  export type support_faqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq findFirst
   */
  export type support_faqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_faqs.
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_faqs.
     */
    distinct?: Support_faqScalarFieldEnum | Support_faqScalarFieldEnum[]
  }

  /**
   * support_faq findFirstOrThrow
   */
  export type support_faqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faq to fetch.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_faqs.
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_faqs.
     */
    distinct?: Support_faqScalarFieldEnum | Support_faqScalarFieldEnum[]
  }

  /**
   * support_faq findMany
   */
  export type support_faqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter, which support_faqs to fetch.
     */
    where?: support_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_faqs to fetch.
     */
    orderBy?: support_faqOrderByWithRelationInput | support_faqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_faqs.
     */
    cursor?: support_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_faqs.
     */
    skip?: number
    distinct?: Support_faqScalarFieldEnum | Support_faqScalarFieldEnum[]
  }

  /**
   * support_faq create
   */
  export type support_faqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data needed to create a support_faq.
     */
    data: XOR<support_faqCreateInput, support_faqUncheckedCreateInput>
  }

  /**
   * support_faq createMany
   */
  export type support_faqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_faqs.
     */
    data: support_faqCreateManyInput | support_faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_faq createManyAndReturn
   */
  export type support_faqCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data used to create many support_faqs.
     */
    data: support_faqCreateManyInput | support_faqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_faq update
   */
  export type support_faqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data needed to update a support_faq.
     */
    data: XOR<support_faqUpdateInput, support_faqUncheckedUpdateInput>
    /**
     * Choose, which support_faq to update.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq updateMany
   */
  export type support_faqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_faqs.
     */
    data: XOR<support_faqUpdateManyMutationInput, support_faqUncheckedUpdateManyInput>
    /**
     * Filter which support_faqs to update
     */
    where?: support_faqWhereInput
    /**
     * Limit how many support_faqs to update.
     */
    limit?: number
  }

  /**
   * support_faq updateManyAndReturn
   */
  export type support_faqUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The data used to update support_faqs.
     */
    data: XOR<support_faqUpdateManyMutationInput, support_faqUncheckedUpdateManyInput>
    /**
     * Filter which support_faqs to update
     */
    where?: support_faqWhereInput
    /**
     * Limit how many support_faqs to update.
     */
    limit?: number
  }

  /**
   * support_faq upsert
   */
  export type support_faqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * The filter to search for the support_faq to update in case it exists.
     */
    where: support_faqWhereUniqueInput
    /**
     * In case the support_faq found by the `where` argument doesn't exist, create a new support_faq with this data.
     */
    create: XOR<support_faqCreateInput, support_faqUncheckedCreateInput>
    /**
     * In case the support_faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_faqUpdateInput, support_faqUncheckedUpdateInput>
  }

  /**
   * support_faq delete
   */
  export type support_faqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
    /**
     * Filter which support_faq to delete.
     */
    where: support_faqWhereUniqueInput
  }

  /**
   * support_faq deleteMany
   */
  export type support_faqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_faqs to delete
     */
    where?: support_faqWhereInput
    /**
     * Limit how many support_faqs to delete.
     */
    limit?: number
  }

  /**
   * support_faq without action
   */
  export type support_faqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_faq
     */
    select?: support_faqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_faq
     */
    omit?: support_faqOmit<ExtArgs> | null
  }


  /**
   * Model support_categories
   */

  export type AggregateSupport_categories = {
    _count: Support_categoriesCountAggregateOutputType | null
    _avg: Support_categoriesAvgAggregateOutputType | null
    _sum: Support_categoriesSumAggregateOutputType | null
    _min: Support_categoriesMinAggregateOutputType | null
    _max: Support_categoriesMaxAggregateOutputType | null
  }

  export type Support_categoriesAvgAggregateOutputType = {
    id: number | null
    display_order: number | null
  }

  export type Support_categoriesSumAggregateOutputType = {
    id: number | null
    display_order: number | null
  }

  export type Support_categoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_categoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    display_order: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Support_categoriesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    display_order: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Support_categoriesAvgAggregateInputType = {
    id?: true
    display_order?: true
  }

  export type Support_categoriesSumAggregateInputType = {
    id?: true
    display_order?: true
  }

  export type Support_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Support_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    display_order?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Support_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_categories to aggregate.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_categories
    **/
    _count?: true | Support_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_categoriesMaxAggregateInputType
  }

  export type GetSupport_categoriesAggregateType<T extends Support_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_categories[P]>
      : GetScalarType<T[P], AggregateSupport_categories[P]>
  }




  export type support_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_categoriesWhereInput
    orderBy?: support_categoriesOrderByWithAggregationInput | support_categoriesOrderByWithAggregationInput[]
    by: Support_categoriesScalarFieldEnum[] | Support_categoriesScalarFieldEnum
    having?: support_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_categoriesCountAggregateInputType | true
    _avg?: Support_categoriesAvgAggregateInputType
    _sum?: Support_categoriesSumAggregateInputType
    _min?: Support_categoriesMinAggregateInputType
    _max?: Support_categoriesMaxAggregateInputType
  }

  export type Support_categoriesGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    icon: string | null
    display_order: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Support_categoriesCountAggregateOutputType | null
    _avg: Support_categoriesAvgAggregateOutputType | null
    _sum: Support_categoriesSumAggregateOutputType | null
    _min: Support_categoriesMinAggregateOutputType | null
    _max: Support_categoriesMaxAggregateOutputType | null
  }

  type GetSupport_categoriesGroupByPayload<T extends support_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type support_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_categories"]>

  export type support_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_categories"]>

  export type support_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["support_categories"]>

  export type support_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    display_order?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type support_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "icon" | "display_order" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["support_categories"]>

  export type $support_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      icon: string | null
      display_order: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["support_categories"]>
    composites: {}
  }

  type support_categoriesGetPayload<S extends boolean | null | undefined | support_categoriesDefaultArgs> = $Result.GetResult<Prisma.$support_categoriesPayload, S>

  type support_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_categoriesCountAggregateInputType | true
    }

  export interface support_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_categories'], meta: { name: 'support_categories' } }
    /**
     * Find zero or one Support_categories that matches the filter.
     * @param {support_categoriesFindUniqueArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_categoriesFindUniqueArgs>(args: SelectSubset<T, support_categoriesFindUniqueArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesFindFirstArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_categoriesFindFirstArgs>(args?: SelectSubset<T, support_categoriesFindFirstArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesFindFirstOrThrowArgs} args - Arguments to find a Support_categories
     * @example
     * // Get one Support_categories
     * const support_categories = await prisma.support_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_categories
     * const support_categories = await prisma.support_categories.findMany()
     * 
     * // Get first 10 Support_categories
     * const support_categories = await prisma.support_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_categoriesWithIdOnly = await prisma.support_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_categoriesFindManyArgs>(args?: SelectSubset<T, support_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_categories.
     * @param {support_categoriesCreateArgs} args - Arguments to create a Support_categories.
     * @example
     * // Create one Support_categories
     * const Support_categories = await prisma.support_categories.create({
     *   data: {
     *     // ... data to create a Support_categories
     *   }
     * })
     * 
     */
    create<T extends support_categoriesCreateArgs>(args: SelectSubset<T, support_categoriesCreateArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_categories.
     * @param {support_categoriesCreateManyArgs} args - Arguments to create many Support_categories.
     * @example
     * // Create many Support_categories
     * const support_categories = await prisma.support_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_categoriesCreateManyArgs>(args?: SelectSubset<T, support_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_categories and returns the data saved in the database.
     * @param {support_categoriesCreateManyAndReturnArgs} args - Arguments to create many Support_categories.
     * @example
     * // Create many Support_categories
     * const support_categories = await prisma.support_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_categories and only return the `id`
     * const support_categoriesWithIdOnly = await prisma.support_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_categories.
     * @param {support_categoriesDeleteArgs} args - Arguments to delete one Support_categories.
     * @example
     * // Delete one Support_categories
     * const Support_categories = await prisma.support_categories.delete({
     *   where: {
     *     // ... filter to delete one Support_categories
     *   }
     * })
     * 
     */
    delete<T extends support_categoriesDeleteArgs>(args: SelectSubset<T, support_categoriesDeleteArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_categories.
     * @param {support_categoriesUpdateArgs} args - Arguments to update one Support_categories.
     * @example
     * // Update one Support_categories
     * const support_categories = await prisma.support_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_categoriesUpdateArgs>(args: SelectSubset<T, support_categoriesUpdateArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_categories.
     * @param {support_categoriesDeleteManyArgs} args - Arguments to filter Support_categories to delete.
     * @example
     * // Delete a few Support_categories
     * const { count } = await prisma.support_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_categoriesDeleteManyArgs>(args?: SelectSubset<T, support_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_categories
     * const support_categories = await prisma.support_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_categoriesUpdateManyArgs>(args: SelectSubset<T, support_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_categories and returns the data updated in the database.
     * @param {support_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Support_categories.
     * @example
     * // Update many Support_categories
     * const support_categories = await prisma.support_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_categories and only return the `id`
     * const support_categoriesWithIdOnly = await prisma.support_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_categories.
     * @param {support_categoriesUpsertArgs} args - Arguments to update or create a Support_categories.
     * @example
     * // Update or create a Support_categories
     * const support_categories = await prisma.support_categories.upsert({
     *   create: {
     *     // ... data to create a Support_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_categories we want to update
     *   }
     * })
     */
    upsert<T extends support_categoriesUpsertArgs>(args: SelectSubset<T, support_categoriesUpsertArgs<ExtArgs>>): Prisma__support_categoriesClient<$Result.GetResult<Prisma.$support_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesCountArgs} args - Arguments to filter Support_categories to count.
     * @example
     * // Count the number of Support_categories
     * const count = await prisma.support_categories.count({
     *   where: {
     *     // ... the filter for the Support_categories we want to count
     *   }
     * })
    **/
    count<T extends support_categoriesCountArgs>(
      args?: Subset<T, support_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_categoriesAggregateArgs>(args: Subset<T, Support_categoriesAggregateArgs>): Prisma.PrismaPromise<GetSupport_categoriesAggregateType<T>>

    /**
     * Group by Support_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: support_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_categories model
   */
  readonly fields: support_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_categories model
   */
  interface support_categoriesFieldRefs {
    readonly id: FieldRef<"support_categories", 'Int'>
    readonly name: FieldRef<"support_categories", 'String'>
    readonly slug: FieldRef<"support_categories", 'String'>
    readonly description: FieldRef<"support_categories", 'String'>
    readonly icon: FieldRef<"support_categories", 'String'>
    readonly display_order: FieldRef<"support_categories", 'Int'>
    readonly is_active: FieldRef<"support_categories", 'Boolean'>
    readonly created_at: FieldRef<"support_categories", 'DateTime'>
    readonly updated_at: FieldRef<"support_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_categories findUnique
   */
  export type support_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories findUniqueOrThrow
   */
  export type support_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories findFirst
   */
  export type support_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_categories.
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_categories.
     */
    distinct?: Support_categoriesScalarFieldEnum | Support_categoriesScalarFieldEnum[]
  }

  /**
   * support_categories findFirstOrThrow
   */
  export type support_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_categories.
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_categories.
     */
    distinct?: Support_categoriesScalarFieldEnum | Support_categoriesScalarFieldEnum[]
  }

  /**
   * support_categories findMany
   */
  export type support_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which support_categories to fetch.
     */
    where?: support_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_categories to fetch.
     */
    orderBy?: support_categoriesOrderByWithRelationInput | support_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_categories.
     */
    cursor?: support_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_categories.
     */
    skip?: number
    distinct?: Support_categoriesScalarFieldEnum | Support_categoriesScalarFieldEnum[]
  }

  /**
   * support_categories create
   */
  export type support_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_categories.
     */
    data: XOR<support_categoriesCreateInput, support_categoriesUncheckedCreateInput>
  }

  /**
   * support_categories createMany
   */
  export type support_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_categories.
     */
    data: support_categoriesCreateManyInput | support_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_categories createManyAndReturn
   */
  export type support_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many support_categories.
     */
    data: support_categoriesCreateManyInput | support_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_categories update
   */
  export type support_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_categories.
     */
    data: XOR<support_categoriesUpdateInput, support_categoriesUncheckedUpdateInput>
    /**
     * Choose, which support_categories to update.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories updateMany
   */
  export type support_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_categories.
     */
    data: XOR<support_categoriesUpdateManyMutationInput, support_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which support_categories to update
     */
    where?: support_categoriesWhereInput
    /**
     * Limit how many support_categories to update.
     */
    limit?: number
  }

  /**
   * support_categories updateManyAndReturn
   */
  export type support_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update support_categories.
     */
    data: XOR<support_categoriesUpdateManyMutationInput, support_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which support_categories to update
     */
    where?: support_categoriesWhereInput
    /**
     * Limit how many support_categories to update.
     */
    limit?: number
  }

  /**
   * support_categories upsert
   */
  export type support_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_categories to update in case it exists.
     */
    where: support_categoriesWhereUniqueInput
    /**
     * In case the support_categories found by the `where` argument doesn't exist, create a new support_categories with this data.
     */
    create: XOR<support_categoriesCreateInput, support_categoriesUncheckedCreateInput>
    /**
     * In case the support_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_categoriesUpdateInput, support_categoriesUncheckedUpdateInput>
  }

  /**
   * support_categories delete
   */
  export type support_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
    /**
     * Filter which support_categories to delete.
     */
    where: support_categoriesWhereUniqueInput
  }

  /**
   * support_categories deleteMany
   */
  export type support_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_categories to delete
     */
    where?: support_categoriesWhereInput
    /**
     * Limit how many support_categories to delete.
     */
    limit?: number
  }

  /**
   * support_categories without action
   */
  export type support_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_categories
     */
    select?: support_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_categories
     */
    omit?: support_categoriesOmit<ExtArgs> | null
  }


  /**
   * Model support_replies
   */

  export type AggregateSupport_replies = {
    _count: Support_repliesCountAggregateOutputType | null
    _avg: Support_repliesAvgAggregateOutputType | null
    _sum: Support_repliesSumAggregateOutputType | null
    _min: Support_repliesMinAggregateOutputType | null
    _max: Support_repliesMaxAggregateOutputType | null
  }

  export type Support_repliesAvgAggregateOutputType = {
    id: number | null
    ticket_id: number | null
  }

  export type Support_repliesSumAggregateOutputType = {
    id: number | null
    ticket_id: number | null
  }

  export type Support_repliesMinAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
  }

  export type Support_repliesMaxAggregateOutputType = {
    id: number | null
    ticket_id: number | null
    sender_id: string | null
    sender_name: string | null
    sender_type: string | null
    content: string | null
    is_internal: boolean | null
    created_at: Date | null
  }

  export type Support_repliesCountAggregateOutputType = {
    id: number
    ticket_id: number
    sender_id: number
    sender_name: number
    sender_type: number
    content: number
    is_internal: number
    created_at: number
    _all: number
  }


  export type Support_repliesAvgAggregateInputType = {
    id?: true
    ticket_id?: true
  }

  export type Support_repliesSumAggregateInputType = {
    id?: true
    ticket_id?: true
  }

  export type Support_repliesMinAggregateInputType = {
    id?: true
    ticket_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
  }

  export type Support_repliesMaxAggregateInputType = {
    id?: true
    ticket_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
  }

  export type Support_repliesCountAggregateInputType = {
    id?: true
    ticket_id?: true
    sender_id?: true
    sender_name?: true
    sender_type?: true
    content?: true
    is_internal?: true
    created_at?: true
    _all?: true
  }

  export type Support_repliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_replies to aggregate.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned support_replies
    **/
    _count?: true | Support_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Support_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Support_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Support_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Support_repliesMaxAggregateInputType
  }

  export type GetSupport_repliesAggregateType<T extends Support_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupport_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupport_replies[P]>
      : GetScalarType<T[P], AggregateSupport_replies[P]>
  }




  export type support_repliesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: support_repliesWhereInput
    orderBy?: support_repliesOrderByWithAggregationInput | support_repliesOrderByWithAggregationInput[]
    by: Support_repliesScalarFieldEnum[] | Support_repliesScalarFieldEnum
    having?: support_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Support_repliesCountAggregateInputType | true
    _avg?: Support_repliesAvgAggregateInputType
    _sum?: Support_repliesSumAggregateInputType
    _min?: Support_repliesMinAggregateInputType
    _max?: Support_repliesMaxAggregateInputType
  }

  export type Support_repliesGroupByOutputType = {
    id: number
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal: boolean
    created_at: Date
    _count: Support_repliesCountAggregateOutputType | null
    _avg: Support_repliesAvgAggregateOutputType | null
    _sum: Support_repliesSumAggregateOutputType | null
    _min: Support_repliesMinAggregateOutputType | null
    _max: Support_repliesMaxAggregateOutputType | null
  }

  type GetSupport_repliesGroupByPayload<T extends support_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Support_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Support_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Support_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Support_repliesGroupByOutputType[P]>
        }
      >
    >


  export type support_repliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["support_replies"]>

  export type support_repliesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["support_replies"]>

  export type support_repliesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["support_replies"]>

  export type support_repliesSelectScalar = {
    id?: boolean
    ticket_id?: boolean
    sender_id?: boolean
    sender_name?: boolean
    sender_type?: boolean
    content?: boolean
    is_internal?: boolean
    created_at?: boolean
  }

  export type support_repliesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticket_id" | "sender_id" | "sender_name" | "sender_type" | "content" | "is_internal" | "created_at", ExtArgs["result"]["support_replies"]>

  export type $support_repliesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "support_replies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticket_id: number
      sender_id: string
      sender_name: string
      sender_type: string
      content: string
      is_internal: boolean
      created_at: Date
    }, ExtArgs["result"]["support_replies"]>
    composites: {}
  }

  type support_repliesGetPayload<S extends boolean | null | undefined | support_repliesDefaultArgs> = $Result.GetResult<Prisma.$support_repliesPayload, S>

  type support_repliesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<support_repliesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Support_repliesCountAggregateInputType | true
    }

  export interface support_repliesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['support_replies'], meta: { name: 'support_replies' } }
    /**
     * Find zero or one Support_replies that matches the filter.
     * @param {support_repliesFindUniqueArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends support_repliesFindUniqueArgs>(args: SelectSubset<T, support_repliesFindUniqueArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Support_replies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {support_repliesFindUniqueOrThrowArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends support_repliesFindUniqueOrThrowArgs>(args: SelectSubset<T, support_repliesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesFindFirstArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends support_repliesFindFirstArgs>(args?: SelectSubset<T, support_repliesFindFirstArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Support_replies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesFindFirstOrThrowArgs} args - Arguments to find a Support_replies
     * @example
     * // Get one Support_replies
     * const support_replies = await prisma.support_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends support_repliesFindFirstOrThrowArgs>(args?: SelectSubset<T, support_repliesFindFirstOrThrowArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Support_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Support_replies
     * const support_replies = await prisma.support_replies.findMany()
     * 
     * // Get first 10 Support_replies
     * const support_replies = await prisma.support_replies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const support_repliesWithIdOnly = await prisma.support_replies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends support_repliesFindManyArgs>(args?: SelectSubset<T, support_repliesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Support_replies.
     * @param {support_repliesCreateArgs} args - Arguments to create a Support_replies.
     * @example
     * // Create one Support_replies
     * const Support_replies = await prisma.support_replies.create({
     *   data: {
     *     // ... data to create a Support_replies
     *   }
     * })
     * 
     */
    create<T extends support_repliesCreateArgs>(args: SelectSubset<T, support_repliesCreateArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Support_replies.
     * @param {support_repliesCreateManyArgs} args - Arguments to create many Support_replies.
     * @example
     * // Create many Support_replies
     * const support_replies = await prisma.support_replies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends support_repliesCreateManyArgs>(args?: SelectSubset<T, support_repliesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Support_replies and returns the data saved in the database.
     * @param {support_repliesCreateManyAndReturnArgs} args - Arguments to create many Support_replies.
     * @example
     * // Create many Support_replies
     * const support_replies = await prisma.support_replies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Support_replies and only return the `id`
     * const support_repliesWithIdOnly = await prisma.support_replies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends support_repliesCreateManyAndReturnArgs>(args?: SelectSubset<T, support_repliesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Support_replies.
     * @param {support_repliesDeleteArgs} args - Arguments to delete one Support_replies.
     * @example
     * // Delete one Support_replies
     * const Support_replies = await prisma.support_replies.delete({
     *   where: {
     *     // ... filter to delete one Support_replies
     *   }
     * })
     * 
     */
    delete<T extends support_repliesDeleteArgs>(args: SelectSubset<T, support_repliesDeleteArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Support_replies.
     * @param {support_repliesUpdateArgs} args - Arguments to update one Support_replies.
     * @example
     * // Update one Support_replies
     * const support_replies = await prisma.support_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends support_repliesUpdateArgs>(args: SelectSubset<T, support_repliesUpdateArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Support_replies.
     * @param {support_repliesDeleteManyArgs} args - Arguments to filter Support_replies to delete.
     * @example
     * // Delete a few Support_replies
     * const { count } = await prisma.support_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends support_repliesDeleteManyArgs>(args?: SelectSubset<T, support_repliesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Support_replies
     * const support_replies = await prisma.support_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends support_repliesUpdateManyArgs>(args: SelectSubset<T, support_repliesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Support_replies and returns the data updated in the database.
     * @param {support_repliesUpdateManyAndReturnArgs} args - Arguments to update many Support_replies.
     * @example
     * // Update many Support_replies
     * const support_replies = await prisma.support_replies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Support_replies and only return the `id`
     * const support_repliesWithIdOnly = await prisma.support_replies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends support_repliesUpdateManyAndReturnArgs>(args: SelectSubset<T, support_repliesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Support_replies.
     * @param {support_repliesUpsertArgs} args - Arguments to update or create a Support_replies.
     * @example
     * // Update or create a Support_replies
     * const support_replies = await prisma.support_replies.upsert({
     *   create: {
     *     // ... data to create a Support_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Support_replies we want to update
     *   }
     * })
     */
    upsert<T extends support_repliesUpsertArgs>(args: SelectSubset<T, support_repliesUpsertArgs<ExtArgs>>): Prisma__support_repliesClient<$Result.GetResult<Prisma.$support_repliesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesCountArgs} args - Arguments to filter Support_replies to count.
     * @example
     * // Count the number of Support_replies
     * const count = await prisma.support_replies.count({
     *   where: {
     *     // ... the filter for the Support_replies we want to count
     *   }
     * })
    **/
    count<T extends support_repliesCountArgs>(
      args?: Subset<T, support_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Support_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Support_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Support_repliesAggregateArgs>(args: Subset<T, Support_repliesAggregateArgs>): Prisma.PrismaPromise<GetSupport_repliesAggregateType<T>>

    /**
     * Group by Support_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {support_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends support_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: support_repliesGroupByArgs['orderBy'] }
        : { orderBy?: support_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, support_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupport_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the support_replies model
   */
  readonly fields: support_repliesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for support_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__support_repliesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the support_replies model
   */
  interface support_repliesFieldRefs {
    readonly id: FieldRef<"support_replies", 'Int'>
    readonly ticket_id: FieldRef<"support_replies", 'Int'>
    readonly sender_id: FieldRef<"support_replies", 'String'>
    readonly sender_name: FieldRef<"support_replies", 'String'>
    readonly sender_type: FieldRef<"support_replies", 'String'>
    readonly content: FieldRef<"support_replies", 'String'>
    readonly is_internal: FieldRef<"support_replies", 'Boolean'>
    readonly created_at: FieldRef<"support_replies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * support_replies findUnique
   */
  export type support_repliesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies findUniqueOrThrow
   */
  export type support_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies findFirst
   */
  export type support_repliesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_replies.
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_replies.
     */
    distinct?: Support_repliesScalarFieldEnum | Support_repliesScalarFieldEnum[]
  }

  /**
   * support_replies findFirstOrThrow
   */
  export type support_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for support_replies.
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of support_replies.
     */
    distinct?: Support_repliesScalarFieldEnum | Support_repliesScalarFieldEnum[]
  }

  /**
   * support_replies findMany
   */
  export type support_repliesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter, which support_replies to fetch.
     */
    where?: support_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of support_replies to fetch.
     */
    orderBy?: support_repliesOrderByWithRelationInput | support_repliesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing support_replies.
     */
    cursor?: support_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` support_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` support_replies.
     */
    skip?: number
    distinct?: Support_repliesScalarFieldEnum | Support_repliesScalarFieldEnum[]
  }

  /**
   * support_replies create
   */
  export type support_repliesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data needed to create a support_replies.
     */
    data: XOR<support_repliesCreateInput, support_repliesUncheckedCreateInput>
  }

  /**
   * support_replies createMany
   */
  export type support_repliesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many support_replies.
     */
    data: support_repliesCreateManyInput | support_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_replies createManyAndReturn
   */
  export type support_repliesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data used to create many support_replies.
     */
    data: support_repliesCreateManyInput | support_repliesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * support_replies update
   */
  export type support_repliesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data needed to update a support_replies.
     */
    data: XOR<support_repliesUpdateInput, support_repliesUncheckedUpdateInput>
    /**
     * Choose, which support_replies to update.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies updateMany
   */
  export type support_repliesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update support_replies.
     */
    data: XOR<support_repliesUpdateManyMutationInput, support_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_replies to update
     */
    where?: support_repliesWhereInput
    /**
     * Limit how many support_replies to update.
     */
    limit?: number
  }

  /**
   * support_replies updateManyAndReturn
   */
  export type support_repliesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The data used to update support_replies.
     */
    data: XOR<support_repliesUpdateManyMutationInput, support_repliesUncheckedUpdateManyInput>
    /**
     * Filter which support_replies to update
     */
    where?: support_repliesWhereInput
    /**
     * Limit how many support_replies to update.
     */
    limit?: number
  }

  /**
   * support_replies upsert
   */
  export type support_repliesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * The filter to search for the support_replies to update in case it exists.
     */
    where: support_repliesWhereUniqueInput
    /**
     * In case the support_replies found by the `where` argument doesn't exist, create a new support_replies with this data.
     */
    create: XOR<support_repliesCreateInput, support_repliesUncheckedCreateInput>
    /**
     * In case the support_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<support_repliesUpdateInput, support_repliesUncheckedUpdateInput>
  }

  /**
   * support_replies delete
   */
  export type support_repliesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
    /**
     * Filter which support_replies to delete.
     */
    where: support_repliesWhereUniqueInput
  }

  /**
   * support_replies deleteMany
   */
  export type support_repliesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which support_replies to delete
     */
    where?: support_repliesWhereInput
    /**
     * Limit how many support_replies to delete.
     */
    limit?: number
  }

  /**
   * support_replies without action
   */
  export type support_repliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the support_replies
     */
    select?: support_repliesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the support_replies
     */
    omit?: support_repliesOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    metadata: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    isRead: boolean
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "metadata" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      isRead: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model group_management
   */

  export type AggregateGroup_management = {
    _count: Group_managementCountAggregateOutputType | null
    _avg: Group_managementAvgAggregateOutputType | null
    _sum: Group_managementSumAggregateOutputType | null
    _min: Group_managementMinAggregateOutputType | null
    _max: Group_managementMaxAggregateOutputType | null
  }

  export type Group_managementAvgAggregateOutputType = {
    id: number | null
    server: number | null
    auth_mode: number | null
    auth_password_min: number | null
    leverage: number | null
    min_deposit: Decimal | null
    spread: Decimal | null
    commission: Decimal | null
  }

  export type Group_managementSumAggregateOutputType = {
    id: number | null
    server: number | null
    auth_mode: number | null
    auth_password_min: number | null
    leverage: number | null
    min_deposit: Decimal | null
    spread: Decimal | null
    commission: Decimal | null
  }

  export type Group_managementMinAggregateOutputType = {
    id: number | null
    group: string | null
    server: number | null
    auth_mode: number | null
    auth_password_min: number | null
    currency: string | null
    is_active: boolean | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    dedicated_name: string | null
    account_type: string | null
    leverage: number | null
    min_deposit: Decimal | null
    spread: Decimal | null
    commission: Decimal | null
  }

  export type Group_managementMaxAggregateOutputType = {
    id: number | null
    group: string | null
    server: number | null
    auth_mode: number | null
    auth_password_min: number | null
    currency: string | null
    is_active: boolean | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    dedicated_name: string | null
    account_type: string | null
    leverage: number | null
    min_deposit: Decimal | null
    spread: Decimal | null
    commission: Decimal | null
  }

  export type Group_managementCountAggregateOutputType = {
    id: number
    group: number
    server: number
    auth_mode: number
    auth_password_min: number
    currency: number
    is_active: number
    synced_at: number
    created_at: number
    updated_at: number
    dedicated_name: number
    account_type: number
    leverage: number
    min_deposit: number
    spread: number
    commission: number
    _all: number
  }


  export type Group_managementAvgAggregateInputType = {
    id?: true
    server?: true
    auth_mode?: true
    auth_password_min?: true
    leverage?: true
    min_deposit?: true
    spread?: true
    commission?: true
  }

  export type Group_managementSumAggregateInputType = {
    id?: true
    server?: true
    auth_mode?: true
    auth_password_min?: true
    leverage?: true
    min_deposit?: true
    spread?: true
    commission?: true
  }

  export type Group_managementMinAggregateInputType = {
    id?: true
    group?: true
    server?: true
    auth_mode?: true
    auth_password_min?: true
    currency?: true
    is_active?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
    dedicated_name?: true
    account_type?: true
    leverage?: true
    min_deposit?: true
    spread?: true
    commission?: true
  }

  export type Group_managementMaxAggregateInputType = {
    id?: true
    group?: true
    server?: true
    auth_mode?: true
    auth_password_min?: true
    currency?: true
    is_active?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
    dedicated_name?: true
    account_type?: true
    leverage?: true
    min_deposit?: true
    spread?: true
    commission?: true
  }

  export type Group_managementCountAggregateInputType = {
    id?: true
    group?: true
    server?: true
    auth_mode?: true
    auth_password_min?: true
    currency?: true
    is_active?: true
    synced_at?: true
    created_at?: true
    updated_at?: true
    dedicated_name?: true
    account_type?: true
    leverage?: true
    min_deposit?: true
    spread?: true
    commission?: true
    _all?: true
  }

  export type Group_managementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_management to aggregate.
     */
    where?: group_managementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_managements to fetch.
     */
    orderBy?: group_managementOrderByWithRelationInput | group_managementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: group_managementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_managements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned group_managements
    **/
    _count?: true | Group_managementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Group_managementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Group_managementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Group_managementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Group_managementMaxAggregateInputType
  }

  export type GetGroup_managementAggregateType<T extends Group_managementAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup_management]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup_management[P]>
      : GetScalarType<T[P], AggregateGroup_management[P]>
  }




  export type group_managementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: group_managementWhereInput
    orderBy?: group_managementOrderByWithAggregationInput | group_managementOrderByWithAggregationInput[]
    by: Group_managementScalarFieldEnum[] | Group_managementScalarFieldEnum
    having?: group_managementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Group_managementCountAggregateInputType | true
    _avg?: Group_managementAvgAggregateInputType
    _sum?: Group_managementSumAggregateInputType
    _min?: Group_managementMinAggregateInputType
    _max?: Group_managementMaxAggregateInputType
  }

  export type Group_managementGroupByOutputType = {
    id: number
    group: string
    server: number | null
    auth_mode: number | null
    auth_password_min: number | null
    currency: string | null
    is_active: boolean | null
    synced_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    dedicated_name: string | null
    account_type: string | null
    leverage: number | null
    min_deposit: Decimal | null
    spread: Decimal | null
    commission: Decimal | null
    _count: Group_managementCountAggregateOutputType | null
    _avg: Group_managementAvgAggregateOutputType | null
    _sum: Group_managementSumAggregateOutputType | null
    _min: Group_managementMinAggregateOutputType | null
    _max: Group_managementMaxAggregateOutputType | null
  }

  type GetGroup_managementGroupByPayload<T extends group_managementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Group_managementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Group_managementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Group_managementGroupByOutputType[P]>
            : GetScalarType<T[P], Group_managementGroupByOutputType[P]>
        }
      >
    >


  export type group_managementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group?: boolean
    server?: boolean
    auth_mode?: boolean
    auth_password_min?: boolean
    currency?: boolean
    is_active?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    dedicated_name?: boolean
    account_type?: boolean
    leverage?: boolean
    min_deposit?: boolean
    spread?: boolean
    commission?: boolean
  }, ExtArgs["result"]["group_management"]>

  export type group_managementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group?: boolean
    server?: boolean
    auth_mode?: boolean
    auth_password_min?: boolean
    currency?: boolean
    is_active?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    dedicated_name?: boolean
    account_type?: boolean
    leverage?: boolean
    min_deposit?: boolean
    spread?: boolean
    commission?: boolean
  }, ExtArgs["result"]["group_management"]>

  export type group_managementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group?: boolean
    server?: boolean
    auth_mode?: boolean
    auth_password_min?: boolean
    currency?: boolean
    is_active?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    dedicated_name?: boolean
    account_type?: boolean
    leverage?: boolean
    min_deposit?: boolean
    spread?: boolean
    commission?: boolean
  }, ExtArgs["result"]["group_management"]>

  export type group_managementSelectScalar = {
    id?: boolean
    group?: boolean
    server?: boolean
    auth_mode?: boolean
    auth_password_min?: boolean
    currency?: boolean
    is_active?: boolean
    synced_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    dedicated_name?: boolean
    account_type?: boolean
    leverage?: boolean
    min_deposit?: boolean
    spread?: boolean
    commission?: boolean
  }

  export type group_managementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "group" | "server" | "auth_mode" | "auth_password_min" | "currency" | "is_active" | "synced_at" | "created_at" | "updated_at" | "dedicated_name" | "account_type" | "leverage" | "min_deposit" | "spread" | "commission", ExtArgs["result"]["group_management"]>

  export type $group_managementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group_management"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      group: string
      server: number | null
      auth_mode: number | null
      auth_password_min: number | null
      currency: string | null
      is_active: boolean | null
      synced_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      dedicated_name: string | null
      account_type: string | null
      leverage: number | null
      min_deposit: Prisma.Decimal | null
      spread: Prisma.Decimal | null
      commission: Prisma.Decimal | null
    }, ExtArgs["result"]["group_management"]>
    composites: {}
  }

  type group_managementGetPayload<S extends boolean | null | undefined | group_managementDefaultArgs> = $Result.GetResult<Prisma.$group_managementPayload, S>

  type group_managementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<group_managementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Group_managementCountAggregateInputType | true
    }

  export interface group_managementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group_management'], meta: { name: 'group_management' } }
    /**
     * Find zero or one Group_management that matches the filter.
     * @param {group_managementFindUniqueArgs} args - Arguments to find a Group_management
     * @example
     * // Get one Group_management
     * const group_management = await prisma.group_management.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends group_managementFindUniqueArgs>(args: SelectSubset<T, group_managementFindUniqueArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group_management that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {group_managementFindUniqueOrThrowArgs} args - Arguments to find a Group_management
     * @example
     * // Get one Group_management
     * const group_management = await prisma.group_management.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends group_managementFindUniqueOrThrowArgs>(args: SelectSubset<T, group_managementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_management that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_managementFindFirstArgs} args - Arguments to find a Group_management
     * @example
     * // Get one Group_management
     * const group_management = await prisma.group_management.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends group_managementFindFirstArgs>(args?: SelectSubset<T, group_managementFindFirstArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group_management that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_managementFindFirstOrThrowArgs} args - Arguments to find a Group_management
     * @example
     * // Get one Group_management
     * const group_management = await prisma.group_management.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends group_managementFindFirstOrThrowArgs>(args?: SelectSubset<T, group_managementFindFirstOrThrowArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Group_managements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_managementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Group_managements
     * const group_managements = await prisma.group_management.findMany()
     * 
     * // Get first 10 Group_managements
     * const group_managements = await prisma.group_management.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const group_managementWithIdOnly = await prisma.group_management.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends group_managementFindManyArgs>(args?: SelectSubset<T, group_managementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group_management.
     * @param {group_managementCreateArgs} args - Arguments to create a Group_management.
     * @example
     * // Create one Group_management
     * const Group_management = await prisma.group_management.create({
     *   data: {
     *     // ... data to create a Group_management
     *   }
     * })
     * 
     */
    create<T extends group_managementCreateArgs>(args: SelectSubset<T, group_managementCreateArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Group_managements.
     * @param {group_managementCreateManyArgs} args - Arguments to create many Group_managements.
     * @example
     * // Create many Group_managements
     * const group_management = await prisma.group_management.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends group_managementCreateManyArgs>(args?: SelectSubset<T, group_managementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Group_managements and returns the data saved in the database.
     * @param {group_managementCreateManyAndReturnArgs} args - Arguments to create many Group_managements.
     * @example
     * // Create many Group_managements
     * const group_management = await prisma.group_management.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Group_managements and only return the `id`
     * const group_managementWithIdOnly = await prisma.group_management.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends group_managementCreateManyAndReturnArgs>(args?: SelectSubset<T, group_managementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group_management.
     * @param {group_managementDeleteArgs} args - Arguments to delete one Group_management.
     * @example
     * // Delete one Group_management
     * const Group_management = await prisma.group_management.delete({
     *   where: {
     *     // ... filter to delete one Group_management
     *   }
     * })
     * 
     */
    delete<T extends group_managementDeleteArgs>(args: SelectSubset<T, group_managementDeleteArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group_management.
     * @param {group_managementUpdateArgs} args - Arguments to update one Group_management.
     * @example
     * // Update one Group_management
     * const group_management = await prisma.group_management.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends group_managementUpdateArgs>(args: SelectSubset<T, group_managementUpdateArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Group_managements.
     * @param {group_managementDeleteManyArgs} args - Arguments to filter Group_managements to delete.
     * @example
     * // Delete a few Group_managements
     * const { count } = await prisma.group_management.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends group_managementDeleteManyArgs>(args?: SelectSubset<T, group_managementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_managements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_managementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Group_managements
     * const group_management = await prisma.group_management.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends group_managementUpdateManyArgs>(args: SelectSubset<T, group_managementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Group_managements and returns the data updated in the database.
     * @param {group_managementUpdateManyAndReturnArgs} args - Arguments to update many Group_managements.
     * @example
     * // Update many Group_managements
     * const group_management = await prisma.group_management.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Group_managements and only return the `id`
     * const group_managementWithIdOnly = await prisma.group_management.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends group_managementUpdateManyAndReturnArgs>(args: SelectSubset<T, group_managementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group_management.
     * @param {group_managementUpsertArgs} args - Arguments to update or create a Group_management.
     * @example
     * // Update or create a Group_management
     * const group_management = await prisma.group_management.upsert({
     *   create: {
     *     // ... data to create a Group_management
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group_management we want to update
     *   }
     * })
     */
    upsert<T extends group_managementUpsertArgs>(args: SelectSubset<T, group_managementUpsertArgs<ExtArgs>>): Prisma__group_managementClient<$Result.GetResult<Prisma.$group_managementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Group_managements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_managementCountArgs} args - Arguments to filter Group_managements to count.
     * @example
     * // Count the number of Group_managements
     * const count = await prisma.group_management.count({
     *   where: {
     *     // ... the filter for the Group_managements we want to count
     *   }
     * })
    **/
    count<T extends group_managementCountArgs>(
      args?: Subset<T, group_managementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Group_managementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group_management.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Group_managementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Group_managementAggregateArgs>(args: Subset<T, Group_managementAggregateArgs>): Prisma.PrismaPromise<GetGroup_managementAggregateType<T>>

    /**
     * Group by Group_management.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {group_managementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends group_managementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: group_managementGroupByArgs['orderBy'] }
        : { orderBy?: group_managementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, group_managementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroup_managementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group_management model
   */
  readonly fields: group_managementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group_management.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__group_managementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group_management model
   */
  interface group_managementFieldRefs {
    readonly id: FieldRef<"group_management", 'Int'>
    readonly group: FieldRef<"group_management", 'String'>
    readonly server: FieldRef<"group_management", 'Int'>
    readonly auth_mode: FieldRef<"group_management", 'Int'>
    readonly auth_password_min: FieldRef<"group_management", 'Int'>
    readonly currency: FieldRef<"group_management", 'String'>
    readonly is_active: FieldRef<"group_management", 'Boolean'>
    readonly synced_at: FieldRef<"group_management", 'DateTime'>
    readonly created_at: FieldRef<"group_management", 'DateTime'>
    readonly updated_at: FieldRef<"group_management", 'DateTime'>
    readonly dedicated_name: FieldRef<"group_management", 'String'>
    readonly account_type: FieldRef<"group_management", 'String'>
    readonly leverage: FieldRef<"group_management", 'Int'>
    readonly min_deposit: FieldRef<"group_management", 'Decimal'>
    readonly spread: FieldRef<"group_management", 'Decimal'>
    readonly commission: FieldRef<"group_management", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * group_management findUnique
   */
  export type group_managementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * Filter, which group_management to fetch.
     */
    where: group_managementWhereUniqueInput
  }

  /**
   * group_management findUniqueOrThrow
   */
  export type group_managementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * Filter, which group_management to fetch.
     */
    where: group_managementWhereUniqueInput
  }

  /**
   * group_management findFirst
   */
  export type group_managementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * Filter, which group_management to fetch.
     */
    where?: group_managementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_managements to fetch.
     */
    orderBy?: group_managementOrderByWithRelationInput | group_managementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_managements.
     */
    cursor?: group_managementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_managements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_managements.
     */
    distinct?: Group_managementScalarFieldEnum | Group_managementScalarFieldEnum[]
  }

  /**
   * group_management findFirstOrThrow
   */
  export type group_managementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * Filter, which group_management to fetch.
     */
    where?: group_managementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_managements to fetch.
     */
    orderBy?: group_managementOrderByWithRelationInput | group_managementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for group_managements.
     */
    cursor?: group_managementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_managements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of group_managements.
     */
    distinct?: Group_managementScalarFieldEnum | Group_managementScalarFieldEnum[]
  }

  /**
   * group_management findMany
   */
  export type group_managementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * Filter, which group_managements to fetch.
     */
    where?: group_managementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of group_managements to fetch.
     */
    orderBy?: group_managementOrderByWithRelationInput | group_managementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing group_managements.
     */
    cursor?: group_managementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` group_managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` group_managements.
     */
    skip?: number
    distinct?: Group_managementScalarFieldEnum | Group_managementScalarFieldEnum[]
  }

  /**
   * group_management create
   */
  export type group_managementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * The data needed to create a group_management.
     */
    data: XOR<group_managementCreateInput, group_managementUncheckedCreateInput>
  }

  /**
   * group_management createMany
   */
  export type group_managementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many group_managements.
     */
    data: group_managementCreateManyInput | group_managementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_management createManyAndReturn
   */
  export type group_managementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * The data used to create many group_managements.
     */
    data: group_managementCreateManyInput | group_managementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group_management update
   */
  export type group_managementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * The data needed to update a group_management.
     */
    data: XOR<group_managementUpdateInput, group_managementUncheckedUpdateInput>
    /**
     * Choose, which group_management to update.
     */
    where: group_managementWhereUniqueInput
  }

  /**
   * group_management updateMany
   */
  export type group_managementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update group_managements.
     */
    data: XOR<group_managementUpdateManyMutationInput, group_managementUncheckedUpdateManyInput>
    /**
     * Filter which group_managements to update
     */
    where?: group_managementWhereInput
    /**
     * Limit how many group_managements to update.
     */
    limit?: number
  }

  /**
   * group_management updateManyAndReturn
   */
  export type group_managementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * The data used to update group_managements.
     */
    data: XOR<group_managementUpdateManyMutationInput, group_managementUncheckedUpdateManyInput>
    /**
     * Filter which group_managements to update
     */
    where?: group_managementWhereInput
    /**
     * Limit how many group_managements to update.
     */
    limit?: number
  }

  /**
   * group_management upsert
   */
  export type group_managementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * The filter to search for the group_management to update in case it exists.
     */
    where: group_managementWhereUniqueInput
    /**
     * In case the group_management found by the `where` argument doesn't exist, create a new group_management with this data.
     */
    create: XOR<group_managementCreateInput, group_managementUncheckedCreateInput>
    /**
     * In case the group_management was found with the provided `where` argument, update it with this data.
     */
    update: XOR<group_managementUpdateInput, group_managementUncheckedUpdateInput>
  }

  /**
   * group_management delete
   */
  export type group_managementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
    /**
     * Filter which group_management to delete.
     */
    where: group_managementWhereUniqueInput
  }

  /**
   * group_management deleteMany
   */
  export type group_managementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group_managements to delete
     */
    where?: group_managementWhereInput
    /**
     * Limit how many group_managements to delete.
     */
    limit?: number
  }

  /**
   * group_management without action
   */
  export type group_managementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group_management
     */
    select?: group_managementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group_management
     */
    omit?: group_managementOmit<ExtArgs> | null
  }


  /**
   * Model SymbolGroupAccess
   */

  export type AggregateSymbolGroupAccess = {
    _count: SymbolGroupAccessCountAggregateOutputType | null
    _avg: SymbolGroupAccessAvgAggregateOutputType | null
    _sum: SymbolGroupAccessSumAggregateOutputType | null
    _min: SymbolGroupAccessMinAggregateOutputType | null
    _max: SymbolGroupAccessMaxAggregateOutputType | null
  }

  export type SymbolGroupAccessAvgAggregateOutputType = {
    id: number | null
  }

  export type SymbolGroupAccessSumAggregateOutputType = {
    id: number | null
  }

  export type SymbolGroupAccessMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    group_name: string | null
    is_allowed: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SymbolGroupAccessMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    group_name: string | null
    is_allowed: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SymbolGroupAccessCountAggregateOutputType = {
    id: number
    symbol: number
    group_name: number
    is_allowed: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SymbolGroupAccessAvgAggregateInputType = {
    id?: true
  }

  export type SymbolGroupAccessSumAggregateInputType = {
    id?: true
  }

  export type SymbolGroupAccessMinAggregateInputType = {
    id?: true
    symbol?: true
    group_name?: true
    is_allowed?: true
    created_at?: true
    updated_at?: true
  }

  export type SymbolGroupAccessMaxAggregateInputType = {
    id?: true
    symbol?: true
    group_name?: true
    is_allowed?: true
    created_at?: true
    updated_at?: true
  }

  export type SymbolGroupAccessCountAggregateInputType = {
    id?: true
    symbol?: true
    group_name?: true
    is_allowed?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SymbolGroupAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SymbolGroupAccess to aggregate.
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymbolGroupAccesses to fetch.
     */
    orderBy?: SymbolGroupAccessOrderByWithRelationInput | SymbolGroupAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SymbolGroupAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymbolGroupAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymbolGroupAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SymbolGroupAccesses
    **/
    _count?: true | SymbolGroupAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymbolGroupAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymbolGroupAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymbolGroupAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymbolGroupAccessMaxAggregateInputType
  }

  export type GetSymbolGroupAccessAggregateType<T extends SymbolGroupAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateSymbolGroupAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbolGroupAccess[P]>
      : GetScalarType<T[P], AggregateSymbolGroupAccess[P]>
  }




  export type SymbolGroupAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymbolGroupAccessWhereInput
    orderBy?: SymbolGroupAccessOrderByWithAggregationInput | SymbolGroupAccessOrderByWithAggregationInput[]
    by: SymbolGroupAccessScalarFieldEnum[] | SymbolGroupAccessScalarFieldEnum
    having?: SymbolGroupAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymbolGroupAccessCountAggregateInputType | true
    _avg?: SymbolGroupAccessAvgAggregateInputType
    _sum?: SymbolGroupAccessSumAggregateInputType
    _min?: SymbolGroupAccessMinAggregateInputType
    _max?: SymbolGroupAccessMaxAggregateInputType
  }

  export type SymbolGroupAccessGroupByOutputType = {
    id: number
    symbol: string
    group_name: string
    is_allowed: boolean
    created_at: Date
    updated_at: Date
    _count: SymbolGroupAccessCountAggregateOutputType | null
    _avg: SymbolGroupAccessAvgAggregateOutputType | null
    _sum: SymbolGroupAccessSumAggregateOutputType | null
    _min: SymbolGroupAccessMinAggregateOutputType | null
    _max: SymbolGroupAccessMaxAggregateOutputType | null
  }

  type GetSymbolGroupAccessGroupByPayload<T extends SymbolGroupAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymbolGroupAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymbolGroupAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymbolGroupAccessGroupByOutputType[P]>
            : GetScalarType<T[P], SymbolGroupAccessGroupByOutputType[P]>
        }
      >
    >


  export type SymbolGroupAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    group_name?: boolean
    is_allowed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbolGroupAccess"]>

  export type SymbolGroupAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    group_name?: boolean
    is_allowed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbolGroupAccess"]>

  export type SymbolGroupAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    group_name?: boolean
    is_allowed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbolGroupAccess"]>

  export type SymbolGroupAccessSelectScalar = {
    id?: boolean
    symbol?: boolean
    group_name?: boolean
    is_allowed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SymbolGroupAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "group_name" | "is_allowed" | "created_at" | "updated_at", ExtArgs["result"]["symbolGroupAccess"]>

  export type $SymbolGroupAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SymbolGroupAccess"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      group_name: string
      is_allowed: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["symbolGroupAccess"]>
    composites: {}
  }

  type SymbolGroupAccessGetPayload<S extends boolean | null | undefined | SymbolGroupAccessDefaultArgs> = $Result.GetResult<Prisma.$SymbolGroupAccessPayload, S>

  type SymbolGroupAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SymbolGroupAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SymbolGroupAccessCountAggregateInputType | true
    }

  export interface SymbolGroupAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SymbolGroupAccess'], meta: { name: 'SymbolGroupAccess' } }
    /**
     * Find zero or one SymbolGroupAccess that matches the filter.
     * @param {SymbolGroupAccessFindUniqueArgs} args - Arguments to find a SymbolGroupAccess
     * @example
     * // Get one SymbolGroupAccess
     * const symbolGroupAccess = await prisma.symbolGroupAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymbolGroupAccessFindUniqueArgs>(args: SelectSubset<T, SymbolGroupAccessFindUniqueArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SymbolGroupAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SymbolGroupAccessFindUniqueOrThrowArgs} args - Arguments to find a SymbolGroupAccess
     * @example
     * // Get one SymbolGroupAccess
     * const symbolGroupAccess = await prisma.symbolGroupAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymbolGroupAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, SymbolGroupAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SymbolGroupAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessFindFirstArgs} args - Arguments to find a SymbolGroupAccess
     * @example
     * // Get one SymbolGroupAccess
     * const symbolGroupAccess = await prisma.symbolGroupAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymbolGroupAccessFindFirstArgs>(args?: SelectSubset<T, SymbolGroupAccessFindFirstArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SymbolGroupAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessFindFirstOrThrowArgs} args - Arguments to find a SymbolGroupAccess
     * @example
     * // Get one SymbolGroupAccess
     * const symbolGroupAccess = await prisma.symbolGroupAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymbolGroupAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, SymbolGroupAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SymbolGroupAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SymbolGroupAccesses
     * const symbolGroupAccesses = await prisma.symbolGroupAccess.findMany()
     * 
     * // Get first 10 SymbolGroupAccesses
     * const symbolGroupAccesses = await prisma.symbolGroupAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symbolGroupAccessWithIdOnly = await prisma.symbolGroupAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SymbolGroupAccessFindManyArgs>(args?: SelectSubset<T, SymbolGroupAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SymbolGroupAccess.
     * @param {SymbolGroupAccessCreateArgs} args - Arguments to create a SymbolGroupAccess.
     * @example
     * // Create one SymbolGroupAccess
     * const SymbolGroupAccess = await prisma.symbolGroupAccess.create({
     *   data: {
     *     // ... data to create a SymbolGroupAccess
     *   }
     * })
     * 
     */
    create<T extends SymbolGroupAccessCreateArgs>(args: SelectSubset<T, SymbolGroupAccessCreateArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SymbolGroupAccesses.
     * @param {SymbolGroupAccessCreateManyArgs} args - Arguments to create many SymbolGroupAccesses.
     * @example
     * // Create many SymbolGroupAccesses
     * const symbolGroupAccess = await prisma.symbolGroupAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SymbolGroupAccessCreateManyArgs>(args?: SelectSubset<T, SymbolGroupAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SymbolGroupAccesses and returns the data saved in the database.
     * @param {SymbolGroupAccessCreateManyAndReturnArgs} args - Arguments to create many SymbolGroupAccesses.
     * @example
     * // Create many SymbolGroupAccesses
     * const symbolGroupAccess = await prisma.symbolGroupAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SymbolGroupAccesses and only return the `id`
     * const symbolGroupAccessWithIdOnly = await prisma.symbolGroupAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SymbolGroupAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, SymbolGroupAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SymbolGroupAccess.
     * @param {SymbolGroupAccessDeleteArgs} args - Arguments to delete one SymbolGroupAccess.
     * @example
     * // Delete one SymbolGroupAccess
     * const SymbolGroupAccess = await prisma.symbolGroupAccess.delete({
     *   where: {
     *     // ... filter to delete one SymbolGroupAccess
     *   }
     * })
     * 
     */
    delete<T extends SymbolGroupAccessDeleteArgs>(args: SelectSubset<T, SymbolGroupAccessDeleteArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SymbolGroupAccess.
     * @param {SymbolGroupAccessUpdateArgs} args - Arguments to update one SymbolGroupAccess.
     * @example
     * // Update one SymbolGroupAccess
     * const symbolGroupAccess = await prisma.symbolGroupAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SymbolGroupAccessUpdateArgs>(args: SelectSubset<T, SymbolGroupAccessUpdateArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SymbolGroupAccesses.
     * @param {SymbolGroupAccessDeleteManyArgs} args - Arguments to filter SymbolGroupAccesses to delete.
     * @example
     * // Delete a few SymbolGroupAccesses
     * const { count } = await prisma.symbolGroupAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SymbolGroupAccessDeleteManyArgs>(args?: SelectSubset<T, SymbolGroupAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SymbolGroupAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SymbolGroupAccesses
     * const symbolGroupAccess = await prisma.symbolGroupAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SymbolGroupAccessUpdateManyArgs>(args: SelectSubset<T, SymbolGroupAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SymbolGroupAccesses and returns the data updated in the database.
     * @param {SymbolGroupAccessUpdateManyAndReturnArgs} args - Arguments to update many SymbolGroupAccesses.
     * @example
     * // Update many SymbolGroupAccesses
     * const symbolGroupAccess = await prisma.symbolGroupAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SymbolGroupAccesses and only return the `id`
     * const symbolGroupAccessWithIdOnly = await prisma.symbolGroupAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SymbolGroupAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, SymbolGroupAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SymbolGroupAccess.
     * @param {SymbolGroupAccessUpsertArgs} args - Arguments to update or create a SymbolGroupAccess.
     * @example
     * // Update or create a SymbolGroupAccess
     * const symbolGroupAccess = await prisma.symbolGroupAccess.upsert({
     *   create: {
     *     // ... data to create a SymbolGroupAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SymbolGroupAccess we want to update
     *   }
     * })
     */
    upsert<T extends SymbolGroupAccessUpsertArgs>(args: SelectSubset<T, SymbolGroupAccessUpsertArgs<ExtArgs>>): Prisma__SymbolGroupAccessClient<$Result.GetResult<Prisma.$SymbolGroupAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SymbolGroupAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessCountArgs} args - Arguments to filter SymbolGroupAccesses to count.
     * @example
     * // Count the number of SymbolGroupAccesses
     * const count = await prisma.symbolGroupAccess.count({
     *   where: {
     *     // ... the filter for the SymbolGroupAccesses we want to count
     *   }
     * })
    **/
    count<T extends SymbolGroupAccessCountArgs>(
      args?: Subset<T, SymbolGroupAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymbolGroupAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SymbolGroupAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymbolGroupAccessAggregateArgs>(args: Subset<T, SymbolGroupAccessAggregateArgs>): Prisma.PrismaPromise<GetSymbolGroupAccessAggregateType<T>>

    /**
     * Group by SymbolGroupAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymbolGroupAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SymbolGroupAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymbolGroupAccessGroupByArgs['orderBy'] }
        : { orderBy?: SymbolGroupAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SymbolGroupAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymbolGroupAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SymbolGroupAccess model
   */
  readonly fields: SymbolGroupAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SymbolGroupAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymbolGroupAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SymbolGroupAccess model
   */
  interface SymbolGroupAccessFieldRefs {
    readonly id: FieldRef<"SymbolGroupAccess", 'Int'>
    readonly symbol: FieldRef<"SymbolGroupAccess", 'String'>
    readonly group_name: FieldRef<"SymbolGroupAccess", 'String'>
    readonly is_allowed: FieldRef<"SymbolGroupAccess", 'Boolean'>
    readonly created_at: FieldRef<"SymbolGroupAccess", 'DateTime'>
    readonly updated_at: FieldRef<"SymbolGroupAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SymbolGroupAccess findUnique
   */
  export type SymbolGroupAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * Filter, which SymbolGroupAccess to fetch.
     */
    where: SymbolGroupAccessWhereUniqueInput
  }

  /**
   * SymbolGroupAccess findUniqueOrThrow
   */
  export type SymbolGroupAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * Filter, which SymbolGroupAccess to fetch.
     */
    where: SymbolGroupAccessWhereUniqueInput
  }

  /**
   * SymbolGroupAccess findFirst
   */
  export type SymbolGroupAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * Filter, which SymbolGroupAccess to fetch.
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymbolGroupAccesses to fetch.
     */
    orderBy?: SymbolGroupAccessOrderByWithRelationInput | SymbolGroupAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SymbolGroupAccesses.
     */
    cursor?: SymbolGroupAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymbolGroupAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymbolGroupAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SymbolGroupAccesses.
     */
    distinct?: SymbolGroupAccessScalarFieldEnum | SymbolGroupAccessScalarFieldEnum[]
  }

  /**
   * SymbolGroupAccess findFirstOrThrow
   */
  export type SymbolGroupAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * Filter, which SymbolGroupAccess to fetch.
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymbolGroupAccesses to fetch.
     */
    orderBy?: SymbolGroupAccessOrderByWithRelationInput | SymbolGroupAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SymbolGroupAccesses.
     */
    cursor?: SymbolGroupAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymbolGroupAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymbolGroupAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SymbolGroupAccesses.
     */
    distinct?: SymbolGroupAccessScalarFieldEnum | SymbolGroupAccessScalarFieldEnum[]
  }

  /**
   * SymbolGroupAccess findMany
   */
  export type SymbolGroupAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * Filter, which SymbolGroupAccesses to fetch.
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymbolGroupAccesses to fetch.
     */
    orderBy?: SymbolGroupAccessOrderByWithRelationInput | SymbolGroupAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SymbolGroupAccesses.
     */
    cursor?: SymbolGroupAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymbolGroupAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymbolGroupAccesses.
     */
    skip?: number
    distinct?: SymbolGroupAccessScalarFieldEnum | SymbolGroupAccessScalarFieldEnum[]
  }

  /**
   * SymbolGroupAccess create
   */
  export type SymbolGroupAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * The data needed to create a SymbolGroupAccess.
     */
    data: XOR<SymbolGroupAccessCreateInput, SymbolGroupAccessUncheckedCreateInput>
  }

  /**
   * SymbolGroupAccess createMany
   */
  export type SymbolGroupAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SymbolGroupAccesses.
     */
    data: SymbolGroupAccessCreateManyInput | SymbolGroupAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SymbolGroupAccess createManyAndReturn
   */
  export type SymbolGroupAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * The data used to create many SymbolGroupAccesses.
     */
    data: SymbolGroupAccessCreateManyInput | SymbolGroupAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SymbolGroupAccess update
   */
  export type SymbolGroupAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * The data needed to update a SymbolGroupAccess.
     */
    data: XOR<SymbolGroupAccessUpdateInput, SymbolGroupAccessUncheckedUpdateInput>
    /**
     * Choose, which SymbolGroupAccess to update.
     */
    where: SymbolGroupAccessWhereUniqueInput
  }

  /**
   * SymbolGroupAccess updateMany
   */
  export type SymbolGroupAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SymbolGroupAccesses.
     */
    data: XOR<SymbolGroupAccessUpdateManyMutationInput, SymbolGroupAccessUncheckedUpdateManyInput>
    /**
     * Filter which SymbolGroupAccesses to update
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * Limit how many SymbolGroupAccesses to update.
     */
    limit?: number
  }

  /**
   * SymbolGroupAccess updateManyAndReturn
   */
  export type SymbolGroupAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * The data used to update SymbolGroupAccesses.
     */
    data: XOR<SymbolGroupAccessUpdateManyMutationInput, SymbolGroupAccessUncheckedUpdateManyInput>
    /**
     * Filter which SymbolGroupAccesses to update
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * Limit how many SymbolGroupAccesses to update.
     */
    limit?: number
  }

  /**
   * SymbolGroupAccess upsert
   */
  export type SymbolGroupAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * The filter to search for the SymbolGroupAccess to update in case it exists.
     */
    where: SymbolGroupAccessWhereUniqueInput
    /**
     * In case the SymbolGroupAccess found by the `where` argument doesn't exist, create a new SymbolGroupAccess with this data.
     */
    create: XOR<SymbolGroupAccessCreateInput, SymbolGroupAccessUncheckedCreateInput>
    /**
     * In case the SymbolGroupAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymbolGroupAccessUpdateInput, SymbolGroupAccessUncheckedUpdateInput>
  }

  /**
   * SymbolGroupAccess delete
   */
  export type SymbolGroupAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
    /**
     * Filter which SymbolGroupAccess to delete.
     */
    where: SymbolGroupAccessWhereUniqueInput
  }

  /**
   * SymbolGroupAccess deleteMany
   */
  export type SymbolGroupAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SymbolGroupAccesses to delete
     */
    where?: SymbolGroupAccessWhereInput
    /**
     * Limit how many SymbolGroupAccesses to delete.
     */
    limit?: number
  }

  /**
   * SymbolGroupAccess without action
   */
  export type SymbolGroupAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymbolGroupAccess
     */
    select?: SymbolGroupAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymbolGroupAccess
     */
    omit?: SymbolGroupAccessOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    amount: number | null
    status: string | null
    currency: string | null
    paymentMethod: string | null
    transactionId: string | null
    description: string | null
    metadata: string | null
    depositId: string | null
    withdrawalId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    amount: number | null
    status: string | null
    currency: string | null
    paymentMethod: string | null
    transactionId: string | null
    description: string | null
    metadata: string | null
    depositId: string | null
    withdrawalId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    status: number
    currency: number
    paymentMethod: number
    transactionId: number
    description: number
    metadata: number
    depositId: number
    withdrawalId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    description?: true
    metadata?: true
    depositId?: true
    withdrawalId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    description?: true
    metadata?: true
    depositId?: true
    withdrawalId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    status?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    description?: true
    metadata?: true
    depositId?: true
    withdrawalId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    type: string
    amount: number
    status: string
    currency: string
    paymentMethod: string | null
    transactionId: string | null
    description: string | null
    metadata: string | null
    depositId: string | null
    withdrawalId: string | null
    updatedAt: Date
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    status?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    description?: boolean
    metadata?: boolean
    depositId?: boolean
    withdrawalId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amount" | "status" | "currency" | "paymentMethod" | "transactionId" | "description" | "metadata" | "depositId" | "withdrawalId" | "updatedAt" | "createdAt", ExtArgs["result"]["transaction"]>

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      amount: number
      status: string
      currency: string
      paymentMethod: string | null
      transactionId: string | null
      description: string | null
      metadata: string | null
      depositId: string | null
      withdrawalId: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'String'>
    readonly transactionId: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'String'>
    readonly depositId: FieldRef<"Transaction", 'String'>
    readonly withdrawalId: FieldRef<"Transaction", 'String'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
  }


  /**
   * Model admin_transactions
   */

  export type AggregateAdmin_transactions = {
    _count: Admin_transactionsCountAggregateOutputType | null
    _avg: Admin_transactionsAvgAggregateOutputType | null
    _sum: Admin_transactionsSumAggregateOutputType | null
    _min: Admin_transactionsMinAggregateOutputType | null
    _max: Admin_transactionsMaxAggregateOutputType | null
  }

  export type Admin_transactionsAvgAggregateOutputType = {
    id: number | null
    admin_id: number | null
    amount: Decimal | null
  }

  export type Admin_transactionsSumAggregateOutputType = {
    id: bigint | null
    admin_id: number | null
    amount: Decimal | null
  }

  export type Admin_transactionsMinAggregateOutputType = {
    id: bigint | null
    admin_id: number | null
    user_id: string | null
    mt5_account_id: string | null
    mt5_login: string | null
    operation_type: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    comment: string | null
    external_transaction_id: string | null
    ip_address: string | null
    user_agent: string | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Admin_transactionsMaxAggregateOutputType = {
    id: bigint | null
    admin_id: number | null
    user_id: string | null
    mt5_account_id: string | null
    mt5_login: string | null
    operation_type: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    comment: string | null
    external_transaction_id: string | null
    ip_address: string | null
    user_agent: string | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Admin_transactionsCountAggregateOutputType = {
    id: number
    admin_id: number
    user_id: number
    mt5_account_id: number
    mt5_login: number
    operation_type: number
    amount: number
    currency: number
    status: number
    comment: number
    external_transaction_id: number
    ip_address: number
    user_agent: number
    error_message: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Admin_transactionsAvgAggregateInputType = {
    id?: true
    admin_id?: true
    amount?: true
  }

  export type Admin_transactionsSumAggregateInputType = {
    id?: true
    admin_id?: true
    amount?: true
  }

  export type Admin_transactionsMinAggregateInputType = {
    id?: true
    admin_id?: true
    user_id?: true
    mt5_account_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    status?: true
    comment?: true
    external_transaction_id?: true
    ip_address?: true
    user_agent?: true
    error_message?: true
    created_at?: true
    updated_at?: true
  }

  export type Admin_transactionsMaxAggregateInputType = {
    id?: true
    admin_id?: true
    user_id?: true
    mt5_account_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    status?: true
    comment?: true
    external_transaction_id?: true
    ip_address?: true
    user_agent?: true
    error_message?: true
    created_at?: true
    updated_at?: true
  }

  export type Admin_transactionsCountAggregateInputType = {
    id?: true
    admin_id?: true
    user_id?: true
    mt5_account_id?: true
    mt5_login?: true
    operation_type?: true
    amount?: true
    currency?: true
    status?: true
    comment?: true
    external_transaction_id?: true
    ip_address?: true
    user_agent?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Admin_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_transactions to aggregate.
     */
    where?: admin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_transactions to fetch.
     */
    orderBy?: admin_transactionsOrderByWithRelationInput | admin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_transactions
    **/
    _count?: true | Admin_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_transactionsMaxAggregateInputType
  }

  export type GetAdmin_transactionsAggregateType<T extends Admin_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_transactions[P]>
      : GetScalarType<T[P], AggregateAdmin_transactions[P]>
  }




  export type admin_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_transactionsWhereInput
    orderBy?: admin_transactionsOrderByWithAggregationInput | admin_transactionsOrderByWithAggregationInput[]
    by: Admin_transactionsScalarFieldEnum[] | Admin_transactionsScalarFieldEnum
    having?: admin_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_transactionsCountAggregateInputType | true
    _avg?: Admin_transactionsAvgAggregateInputType
    _sum?: Admin_transactionsSumAggregateInputType
    _min?: Admin_transactionsMinAggregateInputType
    _max?: Admin_transactionsMaxAggregateInputType
  }

  export type Admin_transactionsGroupByOutputType = {
    id: bigint
    admin_id: number
    user_id: string | null
    mt5_account_id: string | null
    mt5_login: string
    operation_type: string
    amount: Decimal
    currency: string
    status: string
    comment: string | null
    external_transaction_id: string | null
    ip_address: string | null
    user_agent: string | null
    error_message: string | null
    created_at: Date
    updated_at: Date
    _count: Admin_transactionsCountAggregateOutputType | null
    _avg: Admin_transactionsAvgAggregateOutputType | null
    _sum: Admin_transactionsSumAggregateOutputType | null
    _min: Admin_transactionsMinAggregateOutputType | null
    _max: Admin_transactionsMaxAggregateOutputType | null
  }

  type GetAdmin_transactionsGroupByPayload<T extends admin_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    user_id?: boolean
    mt5_account_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    comment?: boolean
    external_transaction_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin_transactions"]>

  export type admin_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    user_id?: boolean
    mt5_account_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    comment?: boolean
    external_transaction_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin_transactions"]>

  export type admin_transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    user_id?: boolean
    mt5_account_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    comment?: boolean
    external_transaction_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["admin_transactions"]>

  export type admin_transactionsSelectScalar = {
    id?: boolean
    admin_id?: boolean
    user_id?: boolean
    mt5_account_id?: boolean
    mt5_login?: boolean
    operation_type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    comment?: boolean
    external_transaction_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type admin_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admin_id" | "user_id" | "mt5_account_id" | "mt5_login" | "operation_type" | "amount" | "currency" | "status" | "comment" | "external_transaction_id" | "ip_address" | "user_agent" | "error_message" | "created_at" | "updated_at", ExtArgs["result"]["admin_transactions"]>

  export type $admin_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_transactions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      admin_id: number
      user_id: string | null
      mt5_account_id: string | null
      mt5_login: string
      operation_type: string
      amount: Prisma.Decimal
      currency: string
      status: string
      comment: string | null
      external_transaction_id: string | null
      ip_address: string | null
      user_agent: string | null
      error_message: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["admin_transactions"]>
    composites: {}
  }

  type admin_transactionsGetPayload<S extends boolean | null | undefined | admin_transactionsDefaultArgs> = $Result.GetResult<Prisma.$admin_transactionsPayload, S>

  type admin_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_transactionsCountAggregateInputType | true
    }

  export interface admin_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_transactions'], meta: { name: 'admin_transactions' } }
    /**
     * Find zero or one Admin_transactions that matches the filter.
     * @param {admin_transactionsFindUniqueArgs} args - Arguments to find a Admin_transactions
     * @example
     * // Get one Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_transactionsFindUniqueArgs>(args: SelectSubset<T, admin_transactionsFindUniqueArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_transactions
     * @example
     * // Get one Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_transactionsFindFirstArgs} args - Arguments to find a Admin_transactions
     * @example
     * // Get one Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_transactionsFindFirstArgs>(args?: SelectSubset<T, admin_transactionsFindFirstArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_transactionsFindFirstOrThrowArgs} args - Arguments to find a Admin_transactions
     * @example
     * // Get one Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.findMany()
     * 
     * // Get first 10 Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_transactionsWithIdOnly = await prisma.admin_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_transactionsFindManyArgs>(args?: SelectSubset<T, admin_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_transactions.
     * @param {admin_transactionsCreateArgs} args - Arguments to create a Admin_transactions.
     * @example
     * // Create one Admin_transactions
     * const Admin_transactions = await prisma.admin_transactions.create({
     *   data: {
     *     // ... data to create a Admin_transactions
     *   }
     * })
     * 
     */
    create<T extends admin_transactionsCreateArgs>(args: SelectSubset<T, admin_transactionsCreateArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_transactions.
     * @param {admin_transactionsCreateManyArgs} args - Arguments to create many Admin_transactions.
     * @example
     * // Create many Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_transactionsCreateManyArgs>(args?: SelectSubset<T, admin_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_transactions and returns the data saved in the database.
     * @param {admin_transactionsCreateManyAndReturnArgs} args - Arguments to create many Admin_transactions.
     * @example
     * // Create many Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_transactions and only return the `id`
     * const admin_transactionsWithIdOnly = await prisma.admin_transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin_transactions.
     * @param {admin_transactionsDeleteArgs} args - Arguments to delete one Admin_transactions.
     * @example
     * // Delete one Admin_transactions
     * const Admin_transactions = await prisma.admin_transactions.delete({
     *   where: {
     *     // ... filter to delete one Admin_transactions
     *   }
     * })
     * 
     */
    delete<T extends admin_transactionsDeleteArgs>(args: SelectSubset<T, admin_transactionsDeleteArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_transactions.
     * @param {admin_transactionsUpdateArgs} args - Arguments to update one Admin_transactions.
     * @example
     * // Update one Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_transactionsUpdateArgs>(args: SelectSubset<T, admin_transactionsUpdateArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_transactions.
     * @param {admin_transactionsDeleteManyArgs} args - Arguments to filter Admin_transactions to delete.
     * @example
     * // Delete a few Admin_transactions
     * const { count } = await prisma.admin_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_transactionsDeleteManyArgs>(args?: SelectSubset<T, admin_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_transactionsUpdateManyArgs>(args: SelectSubset<T, admin_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_transactions and returns the data updated in the database.
     * @param {admin_transactionsUpdateManyAndReturnArgs} args - Arguments to update many Admin_transactions.
     * @example
     * // Update many Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admin_transactions and only return the `id`
     * const admin_transactionsWithIdOnly = await prisma.admin_transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admin_transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, admin_transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin_transactions.
     * @param {admin_transactionsUpsertArgs} args - Arguments to update or create a Admin_transactions.
     * @example
     * // Update or create a Admin_transactions
     * const admin_transactions = await prisma.admin_transactions.upsert({
     *   create: {
     *     // ... data to create a Admin_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_transactions we want to update
     *   }
     * })
     */
    upsert<T extends admin_transactionsUpsertArgs>(args: SelectSubset<T, admin_transactionsUpsertArgs<ExtArgs>>): Prisma__admin_transactionsClient<$Result.GetResult<Prisma.$admin_transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_transactionsCountArgs} args - Arguments to filter Admin_transactions to count.
     * @example
     * // Count the number of Admin_transactions
     * const count = await prisma.admin_transactions.count({
     *   where: {
     *     // ... the filter for the Admin_transactions we want to count
     *   }
     * })
    **/
    count<T extends admin_transactionsCountArgs>(
      args?: Subset<T, admin_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_transactionsAggregateArgs>(args: Subset<T, Admin_transactionsAggregateArgs>): Prisma.PrismaPromise<GetAdmin_transactionsAggregateType<T>>

    /**
     * Group by Admin_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: admin_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_transactions model
   */
  readonly fields: admin_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_transactions model
   */
  interface admin_transactionsFieldRefs {
    readonly id: FieldRef<"admin_transactions", 'BigInt'>
    readonly admin_id: FieldRef<"admin_transactions", 'Int'>
    readonly user_id: FieldRef<"admin_transactions", 'String'>
    readonly mt5_account_id: FieldRef<"admin_transactions", 'String'>
    readonly mt5_login: FieldRef<"admin_transactions", 'String'>
    readonly operation_type: FieldRef<"admin_transactions", 'String'>
    readonly amount: FieldRef<"admin_transactions", 'Decimal'>
    readonly currency: FieldRef<"admin_transactions", 'String'>
    readonly status: FieldRef<"admin_transactions", 'String'>
    readonly comment: FieldRef<"admin_transactions", 'String'>
    readonly external_transaction_id: FieldRef<"admin_transactions", 'String'>
    readonly ip_address: FieldRef<"admin_transactions", 'String'>
    readonly user_agent: FieldRef<"admin_transactions", 'String'>
    readonly error_message: FieldRef<"admin_transactions", 'String'>
    readonly created_at: FieldRef<"admin_transactions", 'DateTime'>
    readonly updated_at: FieldRef<"admin_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin_transactions findUnique
   */
  export type admin_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_transactions to fetch.
     */
    where: admin_transactionsWhereUniqueInput
  }

  /**
   * admin_transactions findUniqueOrThrow
   */
  export type admin_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_transactions to fetch.
     */
    where: admin_transactionsWhereUniqueInput
  }

  /**
   * admin_transactions findFirst
   */
  export type admin_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_transactions to fetch.
     */
    where?: admin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_transactions to fetch.
     */
    orderBy?: admin_transactionsOrderByWithRelationInput | admin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_transactions.
     */
    cursor?: admin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_transactions.
     */
    distinct?: Admin_transactionsScalarFieldEnum | Admin_transactionsScalarFieldEnum[]
  }

  /**
   * admin_transactions findFirstOrThrow
   */
  export type admin_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_transactions to fetch.
     */
    where?: admin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_transactions to fetch.
     */
    orderBy?: admin_transactionsOrderByWithRelationInput | admin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_transactions.
     */
    cursor?: admin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_transactions.
     */
    distinct?: Admin_transactionsScalarFieldEnum | Admin_transactionsScalarFieldEnum[]
  }

  /**
   * admin_transactions findMany
   */
  export type admin_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * Filter, which admin_transactions to fetch.
     */
    where?: admin_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_transactions to fetch.
     */
    orderBy?: admin_transactionsOrderByWithRelationInput | admin_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_transactions.
     */
    cursor?: admin_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_transactions.
     */
    skip?: number
    distinct?: Admin_transactionsScalarFieldEnum | Admin_transactionsScalarFieldEnum[]
  }

  /**
   * admin_transactions create
   */
  export type admin_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * The data needed to create a admin_transactions.
     */
    data: XOR<admin_transactionsCreateInput, admin_transactionsUncheckedCreateInput>
  }

  /**
   * admin_transactions createMany
   */
  export type admin_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_transactions.
     */
    data: admin_transactionsCreateManyInput | admin_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_transactions createManyAndReturn
   */
  export type admin_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * The data used to create many admin_transactions.
     */
    data: admin_transactionsCreateManyInput | admin_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_transactions update
   */
  export type admin_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * The data needed to update a admin_transactions.
     */
    data: XOR<admin_transactionsUpdateInput, admin_transactionsUncheckedUpdateInput>
    /**
     * Choose, which admin_transactions to update.
     */
    where: admin_transactionsWhereUniqueInput
  }

  /**
   * admin_transactions updateMany
   */
  export type admin_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_transactions.
     */
    data: XOR<admin_transactionsUpdateManyMutationInput, admin_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_transactions to update
     */
    where?: admin_transactionsWhereInput
    /**
     * Limit how many admin_transactions to update.
     */
    limit?: number
  }

  /**
   * admin_transactions updateManyAndReturn
   */
  export type admin_transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * The data used to update admin_transactions.
     */
    data: XOR<admin_transactionsUpdateManyMutationInput, admin_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_transactions to update
     */
    where?: admin_transactionsWhereInput
    /**
     * Limit how many admin_transactions to update.
     */
    limit?: number
  }

  /**
   * admin_transactions upsert
   */
  export type admin_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * The filter to search for the admin_transactions to update in case it exists.
     */
    where: admin_transactionsWhereUniqueInput
    /**
     * In case the admin_transactions found by the `where` argument doesn't exist, create a new admin_transactions with this data.
     */
    create: XOR<admin_transactionsCreateInput, admin_transactionsUncheckedCreateInput>
    /**
     * In case the admin_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_transactionsUpdateInput, admin_transactionsUncheckedUpdateInput>
  }

  /**
   * admin_transactions delete
   */
  export type admin_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
    /**
     * Filter which admin_transactions to delete.
     */
    where: admin_transactionsWhereUniqueInput
  }

  /**
   * admin_transactions deleteMany
   */
  export type admin_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_transactions to delete
     */
    where?: admin_transactionsWhereInput
    /**
     * Limit how many admin_transactions to delete.
     */
    limit?: number
  }

  /**
   * admin_transactions without action
   */
  export type admin_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_transactions
     */
    select?: admin_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_transactions
     */
    omit?: admin_transactionsOmit<ExtArgs> | null
  }


  /**
   * Model countries
   */

  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesMinAggregateOutputType = {
    code: string | null
    country: string | null
    country_code: string | null
  }

  export type CountriesMaxAggregateOutputType = {
    code: string | null
    country: string | null
    country_code: string | null
  }

  export type CountriesCountAggregateOutputType = {
    code: number
    country: number
    country_code: number
    _all: number
  }


  export type CountriesMinAggregateInputType = {
    code?: true
    country?: true
    country_code?: true
  }

  export type CountriesMaxAggregateInputType = {
    code?: true
    country?: true
    country_code?: true
  }

  export type CountriesCountAggregateInputType = {
    code?: true
    country?: true
    country_code?: true
    _all?: true
  }

  export type CountriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to aggregate.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type countriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: countriesWhereInput
    orderBy?: countriesOrderByWithAggregationInput | countriesOrderByWithAggregationInput[]
    by: CountriesScalarFieldEnum[] | CountriesScalarFieldEnum
    having?: countriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }

  export type CountriesGroupByOutputType = {
    code: string
    country: string | null
    country_code: string | null
    _count: CountriesCountAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends countriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type countriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    country?: boolean
    country_code?: boolean
  }, ExtArgs["result"]["countries"]>

  export type countriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    country?: boolean
    country_code?: boolean
  }, ExtArgs["result"]["countries"]>

  export type countriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    country?: boolean
    country_code?: boolean
  }, ExtArgs["result"]["countries"]>

  export type countriesSelectScalar = {
    code?: boolean
    country?: boolean
    country_code?: boolean
  }

  export type countriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "country" | "country_code", ExtArgs["result"]["countries"]>

  export type $countriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "countries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      code: string
      country: string | null
      country_code: string | null
    }, ExtArgs["result"]["countries"]>
    composites: {}
  }

  type countriesGetPayload<S extends boolean | null | undefined | countriesDefaultArgs> = $Result.GetResult<Prisma.$countriesPayload, S>

  type countriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<countriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountriesCountAggregateInputType | true
    }

  export interface countriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['countries'], meta: { name: 'countries' } }
    /**
     * Find zero or one Countries that matches the filter.
     * @param {countriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends countriesFindUniqueArgs>(args: SelectSubset<T, countriesFindUniqueArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Countries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {countriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends countriesFindUniqueOrThrowArgs>(args: SelectSubset<T, countriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends countriesFindFirstArgs>(args?: SelectSubset<T, countriesFindFirstArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Countries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends countriesFindFirstOrThrowArgs>(args?: SelectSubset<T, countriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const countriesWithCodeOnly = await prisma.countries.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends countriesFindManyArgs>(args?: SelectSubset<T, countriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Countries.
     * @param {countriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
     */
    create<T extends countriesCreateArgs>(args: SelectSubset<T, countriesCreateArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {countriesCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const countries = await prisma.countries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends countriesCreateManyArgs>(args?: SelectSubset<T, countriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {countriesCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const countries = await prisma.countries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `code`
     * const countriesWithCodeOnly = await prisma.countries.createManyAndReturn({
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends countriesCreateManyAndReturnArgs>(args?: SelectSubset<T, countriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Countries.
     * @param {countriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
     */
    delete<T extends countriesDeleteArgs>(args: SelectSubset<T, countriesDeleteArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Countries.
     * @param {countriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends countriesUpdateArgs>(args: SelectSubset<T, countriesUpdateArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {countriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends countriesDeleteManyArgs>(args?: SelectSubset<T, countriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends countriesUpdateManyArgs>(args: SelectSubset<T, countriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {countriesUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `code`
     * const countriesWithCodeOnly = await prisma.countries.updateManyAndReturn({
     *   select: { code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends countriesUpdateManyAndReturnArgs>(args: SelectSubset<T, countriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Countries.
     * @param {countriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
     */
    upsert<T extends countriesUpsertArgs>(args: SelectSubset<T, countriesUpsertArgs<ExtArgs>>): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countriesCountArgs>(
      args?: Subset<T, countriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): Prisma.PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends countriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: countriesGroupByArgs['orderBy'] }
        : { orderBy?: countriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, countriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the countries model
   */
  readonly fields: countriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__countriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the countries model
   */
  interface countriesFieldRefs {
    readonly code: FieldRef<"countries", 'String'>
    readonly country: FieldRef<"countries", 'String'>
    readonly country_code: FieldRef<"countries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * countries findUnique
   */
  export type countriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries findUniqueOrThrow
   */
  export type countriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries findFirst
   */
  export type countriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * countries findFirstOrThrow
   */
  export type countriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * countries findMany
   */
  export type countriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * countries create
   */
  export type countriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The data needed to create a countries.
     */
    data: XOR<countriesCreateInput, countriesUncheckedCreateInput>
  }

  /**
   * countries createMany
   */
  export type countriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many countries.
     */
    data: countriesCreateManyInput | countriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * countries createManyAndReturn
   */
  export type countriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The data used to create many countries.
     */
    data: countriesCreateManyInput | countriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * countries update
   */
  export type countriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The data needed to update a countries.
     */
    data: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
    /**
     * Choose, which countries to update.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries updateMany
   */
  export type countriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update countries.
     */
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countriesWhereInput
    /**
     * Limit how many countries to update.
     */
    limit?: number
  }

  /**
   * countries updateManyAndReturn
   */
  export type countriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The data used to update countries.
     */
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countriesWhereInput
    /**
     * Limit how many countries to update.
     */
    limit?: number
  }

  /**
   * countries upsert
   */
  export type countriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * The filter to search for the countries to update in case it exists.
     */
    where: countriesWhereUniqueInput
    /**
     * In case the countries found by the `where` argument doesn't exist, create a new countries with this data.
     */
    create: XOR<countriesCreateInput, countriesUncheckedCreateInput>
    /**
     * In case the countries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
  }

  /**
   * countries delete
   */
  export type countriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
    /**
     * Filter which countries to delete.
     */
    where: countriesWhereUniqueInput
  }

  /**
   * countries deleteMany
   */
  export type countriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to delete
     */
    where?: countriesWhereInput
    /**
     * Limit how many countries to delete.
     */
    limit?: number
  }

  /**
   * countries without action
   */
  export type countriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the countries
     */
    omit?: countriesOmit<ExtArgs> | null
  }


  /**
   * Model country_admins
   */

  export type AggregateCountry_admins = {
    _count: Country_adminsCountAggregateOutputType | null
    _avg: Country_adminsAvgAggregateOutputType | null
    _sum: Country_adminsSumAggregateOutputType | null
    _min: Country_adminsMinAggregateOutputType | null
    _max: Country_adminsMaxAggregateOutputType | null
  }

  export type Country_adminsAvgAggregateOutputType = {
    id: number | null
  }

  export type Country_adminsSumAggregateOutputType = {
    id: number | null
  }

  export type Country_adminsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    status: string | null
    country_code: string | null
    features: string | null
    created_at: Date | null
  }

  export type Country_adminsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    status: string | null
    country_code: string | null
    features: string | null
    created_at: Date | null
  }

  export type Country_adminsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    status: number
    country_code: number
    features: number
    created_at: number
    _all: number
  }


  export type Country_adminsAvgAggregateInputType = {
    id?: true
  }

  export type Country_adminsSumAggregateInputType = {
    id?: true
  }

  export type Country_adminsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    status?: true
    country_code?: true
    features?: true
    created_at?: true
  }

  export type Country_adminsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    status?: true
    country_code?: true
    features?: true
    created_at?: true
  }

  export type Country_adminsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    status?: true
    country_code?: true
    features?: true
    created_at?: true
    _all?: true
  }

  export type Country_adminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which country_admins to aggregate.
     */
    where?: country_adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of country_admins to fetch.
     */
    orderBy?: country_adminsOrderByWithRelationInput | country_adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: country_adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` country_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` country_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned country_admins
    **/
    _count?: true | Country_adminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Country_adminsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Country_adminsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Country_adminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Country_adminsMaxAggregateInputType
  }

  export type GetCountry_adminsAggregateType<T extends Country_adminsAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry_admins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry_admins[P]>
      : GetScalarType<T[P], AggregateCountry_admins[P]>
  }




  export type country_adminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: country_adminsWhereInput
    orderBy?: country_adminsOrderByWithAggregationInput | country_adminsOrderByWithAggregationInput[]
    by: Country_adminsScalarFieldEnum[] | Country_adminsScalarFieldEnum
    having?: country_adminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Country_adminsCountAggregateInputType | true
    _avg?: Country_adminsAvgAggregateInputType
    _sum?: Country_adminsSumAggregateInputType
    _min?: Country_adminsMinAggregateInputType
    _max?: Country_adminsMaxAggregateInputType
  }

  export type Country_adminsGroupByOutputType = {
    id: number
    name: string
    email: string
    status: string | null
    country_code: string | null
    features: string | null
    created_at: Date | null
    _count: Country_adminsCountAggregateOutputType | null
    _avg: Country_adminsAvgAggregateOutputType | null
    _sum: Country_adminsSumAggregateOutputType | null
    _min: Country_adminsMinAggregateOutputType | null
    _max: Country_adminsMaxAggregateOutputType | null
  }

  type GetCountry_adminsGroupByPayload<T extends country_adminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Country_adminsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Country_adminsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Country_adminsGroupByOutputType[P]>
            : GetScalarType<T[P], Country_adminsGroupByOutputType[P]>
        }
      >
    >


  export type country_adminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
    country_code?: boolean
    features?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["country_admins"]>

  export type country_adminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
    country_code?: boolean
    features?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["country_admins"]>

  export type country_adminsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
    country_code?: boolean
    features?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["country_admins"]>

  export type country_adminsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
    country_code?: boolean
    features?: boolean
    created_at?: boolean
  }

  export type country_adminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "status" | "country_code" | "features" | "created_at", ExtArgs["result"]["country_admins"]>

  export type $country_adminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "country_admins"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      status: string | null
      country_code: string | null
      features: string | null
      created_at: Date | null
    }, ExtArgs["result"]["country_admins"]>
    composites: {}
  }

  type country_adminsGetPayload<S extends boolean | null | undefined | country_adminsDefaultArgs> = $Result.GetResult<Prisma.$country_adminsPayload, S>

  type country_adminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<country_adminsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Country_adminsCountAggregateInputType | true
    }

  export interface country_adminsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['country_admins'], meta: { name: 'country_admins' } }
    /**
     * Find zero or one Country_admins that matches the filter.
     * @param {country_adminsFindUniqueArgs} args - Arguments to find a Country_admins
     * @example
     * // Get one Country_admins
     * const country_admins = await prisma.country_admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends country_adminsFindUniqueArgs>(args: SelectSubset<T, country_adminsFindUniqueArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country_admins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {country_adminsFindUniqueOrThrowArgs} args - Arguments to find a Country_admins
     * @example
     * // Get one Country_admins
     * const country_admins = await prisma.country_admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends country_adminsFindUniqueOrThrowArgs>(args: SelectSubset<T, country_adminsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country_admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {country_adminsFindFirstArgs} args - Arguments to find a Country_admins
     * @example
     * // Get one Country_admins
     * const country_admins = await prisma.country_admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends country_adminsFindFirstArgs>(args?: SelectSubset<T, country_adminsFindFirstArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country_admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {country_adminsFindFirstOrThrowArgs} args - Arguments to find a Country_admins
     * @example
     * // Get one Country_admins
     * const country_admins = await prisma.country_admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends country_adminsFindFirstOrThrowArgs>(args?: SelectSubset<T, country_adminsFindFirstOrThrowArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Country_admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {country_adminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Country_admins
     * const country_admins = await prisma.country_admins.findMany()
     * 
     * // Get first 10 Country_admins
     * const country_admins = await prisma.country_admins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const country_adminsWithIdOnly = await prisma.country_admins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends country_adminsFindManyArgs>(args?: SelectSubset<T, country_adminsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country_admins.
     * @param {country_adminsCreateArgs} args - Arguments to create a Country_admins.
     * @example
     * // Create one Country_admins
     * const Country_admins = await prisma.country_admins.create({
     *   data: {
     *     // ... data to create a Country_admins
     *   }
     * })
     * 
     */
    create<T extends country_adminsCreateArgs>(args: SelectSubset<T, country_adminsCreateArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Country_admins.
     * @param {country_adminsCreateManyArgs} args - Arguments to create many Country_admins.
     * @example
     * // Create many Country_admins
     * const country_admins = await prisma.country_admins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends country_adminsCreateManyArgs>(args?: SelectSubset<T, country_adminsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Country_admins and returns the data saved in the database.
     * @param {country_adminsCreateManyAndReturnArgs} args - Arguments to create many Country_admins.
     * @example
     * // Create many Country_admins
     * const country_admins = await prisma.country_admins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Country_admins and only return the `id`
     * const country_adminsWithIdOnly = await prisma.country_admins.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends country_adminsCreateManyAndReturnArgs>(args?: SelectSubset<T, country_adminsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country_admins.
     * @param {country_adminsDeleteArgs} args - Arguments to delete one Country_admins.
     * @example
     * // Delete one Country_admins
     * const Country_admins = await prisma.country_admins.delete({
     *   where: {
     *     // ... filter to delete one Country_admins
     *   }
     * })
     * 
     */
    delete<T extends country_adminsDeleteArgs>(args: SelectSubset<T, country_adminsDeleteArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country_admins.
     * @param {country_adminsUpdateArgs} args - Arguments to update one Country_admins.
     * @example
     * // Update one Country_admins
     * const country_admins = await prisma.country_admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends country_adminsUpdateArgs>(args: SelectSubset<T, country_adminsUpdateArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Country_admins.
     * @param {country_adminsDeleteManyArgs} args - Arguments to filter Country_admins to delete.
     * @example
     * // Delete a few Country_admins
     * const { count } = await prisma.country_admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends country_adminsDeleteManyArgs>(args?: SelectSubset<T, country_adminsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Country_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {country_adminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Country_admins
     * const country_admins = await prisma.country_admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends country_adminsUpdateManyArgs>(args: SelectSubset<T, country_adminsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Country_admins and returns the data updated in the database.
     * @param {country_adminsUpdateManyAndReturnArgs} args - Arguments to update many Country_admins.
     * @example
     * // Update many Country_admins
     * const country_admins = await prisma.country_admins.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Country_admins and only return the `id`
     * const country_adminsWithIdOnly = await prisma.country_admins.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends country_adminsUpdateManyAndReturnArgs>(args: SelectSubset<T, country_adminsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country_admins.
     * @param {country_adminsUpsertArgs} args - Arguments to update or create a Country_admins.
     * @example
     * // Update or create a Country_admins
     * const country_admins = await prisma.country_admins.upsert({
     *   create: {
     *     // ... data to create a Country_admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country_admins we want to update
     *   }
     * })
     */
    upsert<T extends country_adminsUpsertArgs>(args: SelectSubset<T, country_adminsUpsertArgs<ExtArgs>>): Prisma__country_adminsClient<$Result.GetResult<Prisma.$country_adminsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Country_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {country_adminsCountArgs} args - Arguments to filter Country_admins to count.
     * @example
     * // Count the number of Country_admins
     * const count = await prisma.country_admins.count({
     *   where: {
     *     // ... the filter for the Country_admins we want to count
     *   }
     * })
    **/
    count<T extends country_adminsCountArgs>(
      args?: Subset<T, country_adminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Country_adminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Country_adminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Country_adminsAggregateArgs>(args: Subset<T, Country_adminsAggregateArgs>): Prisma.PrismaPromise<GetCountry_adminsAggregateType<T>>

    /**
     * Group by Country_admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {country_adminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends country_adminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: country_adminsGroupByArgs['orderBy'] }
        : { orderBy?: country_adminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, country_adminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountry_adminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the country_admins model
   */
  readonly fields: country_adminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for country_admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__country_adminsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the country_admins model
   */
  interface country_adminsFieldRefs {
    readonly id: FieldRef<"country_admins", 'Int'>
    readonly name: FieldRef<"country_admins", 'String'>
    readonly email: FieldRef<"country_admins", 'String'>
    readonly status: FieldRef<"country_admins", 'String'>
    readonly country_code: FieldRef<"country_admins", 'String'>
    readonly features: FieldRef<"country_admins", 'String'>
    readonly created_at: FieldRef<"country_admins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * country_admins findUnique
   */
  export type country_adminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * Filter, which country_admins to fetch.
     */
    where: country_adminsWhereUniqueInput
  }

  /**
   * country_admins findUniqueOrThrow
   */
  export type country_adminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * Filter, which country_admins to fetch.
     */
    where: country_adminsWhereUniqueInput
  }

  /**
   * country_admins findFirst
   */
  export type country_adminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * Filter, which country_admins to fetch.
     */
    where?: country_adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of country_admins to fetch.
     */
    orderBy?: country_adminsOrderByWithRelationInput | country_adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for country_admins.
     */
    cursor?: country_adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` country_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` country_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of country_admins.
     */
    distinct?: Country_adminsScalarFieldEnum | Country_adminsScalarFieldEnum[]
  }

  /**
   * country_admins findFirstOrThrow
   */
  export type country_adminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * Filter, which country_admins to fetch.
     */
    where?: country_adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of country_admins to fetch.
     */
    orderBy?: country_adminsOrderByWithRelationInput | country_adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for country_admins.
     */
    cursor?: country_adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` country_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` country_admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of country_admins.
     */
    distinct?: Country_adminsScalarFieldEnum | Country_adminsScalarFieldEnum[]
  }

  /**
   * country_admins findMany
   */
  export type country_adminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * Filter, which country_admins to fetch.
     */
    where?: country_adminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of country_admins to fetch.
     */
    orderBy?: country_adminsOrderByWithRelationInput | country_adminsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing country_admins.
     */
    cursor?: country_adminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` country_admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` country_admins.
     */
    skip?: number
    distinct?: Country_adminsScalarFieldEnum | Country_adminsScalarFieldEnum[]
  }

  /**
   * country_admins create
   */
  export type country_adminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * The data needed to create a country_admins.
     */
    data: XOR<country_adminsCreateInput, country_adminsUncheckedCreateInput>
  }

  /**
   * country_admins createMany
   */
  export type country_adminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many country_admins.
     */
    data: country_adminsCreateManyInput | country_adminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * country_admins createManyAndReturn
   */
  export type country_adminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * The data used to create many country_admins.
     */
    data: country_adminsCreateManyInput | country_adminsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * country_admins update
   */
  export type country_adminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * The data needed to update a country_admins.
     */
    data: XOR<country_adminsUpdateInput, country_adminsUncheckedUpdateInput>
    /**
     * Choose, which country_admins to update.
     */
    where: country_adminsWhereUniqueInput
  }

  /**
   * country_admins updateMany
   */
  export type country_adminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update country_admins.
     */
    data: XOR<country_adminsUpdateManyMutationInput, country_adminsUncheckedUpdateManyInput>
    /**
     * Filter which country_admins to update
     */
    where?: country_adminsWhereInput
    /**
     * Limit how many country_admins to update.
     */
    limit?: number
  }

  /**
   * country_admins updateManyAndReturn
   */
  export type country_adminsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * The data used to update country_admins.
     */
    data: XOR<country_adminsUpdateManyMutationInput, country_adminsUncheckedUpdateManyInput>
    /**
     * Filter which country_admins to update
     */
    where?: country_adminsWhereInput
    /**
     * Limit how many country_admins to update.
     */
    limit?: number
  }

  /**
   * country_admins upsert
   */
  export type country_adminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * The filter to search for the country_admins to update in case it exists.
     */
    where: country_adminsWhereUniqueInput
    /**
     * In case the country_admins found by the `where` argument doesn't exist, create a new country_admins with this data.
     */
    create: XOR<country_adminsCreateInput, country_adminsUncheckedCreateInput>
    /**
     * In case the country_admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<country_adminsUpdateInput, country_adminsUncheckedUpdateInput>
  }

  /**
   * country_admins delete
   */
  export type country_adminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
    /**
     * Filter which country_admins to delete.
     */
    where: country_adminsWhereUniqueInput
  }

  /**
   * country_admins deleteMany
   */
  export type country_adminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which country_admins to delete
     */
    where?: country_adminsWhereInput
    /**
     * Limit how many country_admins to delete.
     */
    limit?: number
  }

  /**
   * country_admins without action
   */
  export type country_adminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country_admins
     */
    select?: country_adminsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the country_admins
     */
    omit?: country_adminsOmit<ExtArgs> | null
  }


  /**
   * Model email_templates
   */

  export type AggregateEmail_templates = {
    _count: Email_templatesCountAggregateOutputType | null
    _avg: Email_templatesAvgAggregateOutputType | null
    _sum: Email_templatesSumAggregateOutputType | null
    _min: Email_templatesMinAggregateOutputType | null
    _max: Email_templatesMaxAggregateOutputType | null
  }

  export type Email_templatesAvgAggregateOutputType = {
    id: number | null
  }

  export type Email_templatesSumAggregateOutputType = {
    id: number | null
  }

  export type Email_templatesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    html_code: string | null
    is_default: boolean | null
    preview_image_url: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
  }

  export type Email_templatesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    html_code: string | null
    is_default: boolean | null
    preview_image_url: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
  }

  export type Email_templatesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    html_code: number
    variables: number
    is_default: number
    preview_image_url: number
    created_at: number
    updated_at: number
    created_by: number
    _all: number
  }


  export type Email_templatesAvgAggregateInputType = {
    id?: true
  }

  export type Email_templatesSumAggregateInputType = {
    id?: true
  }

  export type Email_templatesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    html_code?: true
    is_default?: true
    preview_image_url?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type Email_templatesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    html_code?: true
    is_default?: true
    preview_image_url?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type Email_templatesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    html_code?: true
    variables?: true
    is_default?: true
    preview_image_url?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    _all?: true
  }

  export type Email_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_templates to aggregate.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_templates
    **/
    _count?: true | Email_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Email_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Email_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_templatesMaxAggregateInputType
  }

  export type GetEmail_templatesAggregateType<T extends Email_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_templates[P]>
      : GetScalarType<T[P], AggregateEmail_templates[P]>
  }




  export type email_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_templatesWhereInput
    orderBy?: email_templatesOrderByWithAggregationInput | email_templatesOrderByWithAggregationInput[]
    by: Email_templatesScalarFieldEnum[] | Email_templatesScalarFieldEnum
    having?: email_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_templatesCountAggregateInputType | true
    _avg?: Email_templatesAvgAggregateInputType
    _sum?: Email_templatesSumAggregateInputType
    _min?: Email_templatesMinAggregateInputType
    _max?: Email_templatesMaxAggregateInputType
  }

  export type Email_templatesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    html_code: string
    variables: string[]
    is_default: boolean | null
    preview_image_url: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    _count: Email_templatesCountAggregateOutputType | null
    _avg: Email_templatesAvgAggregateOutputType | null
    _sum: Email_templatesSumAggregateOutputType | null
    _min: Email_templatesMinAggregateOutputType | null
    _max: Email_templatesMaxAggregateOutputType | null
  }

  type GetEmail_templatesGroupByPayload<T extends email_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Email_templatesGroupByOutputType[P]>
        }
      >
    >


  export type email_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    html_code?: boolean
    variables?: boolean
    is_default?: boolean
    preview_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    html_code?: boolean
    variables?: boolean
    is_default?: boolean
    preview_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    html_code?: boolean
    variables?: boolean
    is_default?: boolean
    preview_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    html_code?: boolean
    variables?: boolean
    is_default?: boolean
    preview_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }

  export type email_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "html_code" | "variables" | "is_default" | "preview_image_url" | "created_at" | "updated_at" | "created_by", ExtArgs["result"]["email_templates"]>

  export type $email_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_templates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      html_code: string
      variables: string[]
      is_default: boolean | null
      preview_image_url: string | null
      created_at: Date | null
      updated_at: Date | null
      created_by: string | null
    }, ExtArgs["result"]["email_templates"]>
    composites: {}
  }

  type email_templatesGetPayload<S extends boolean | null | undefined | email_templatesDefaultArgs> = $Result.GetResult<Prisma.$email_templatesPayload, S>

  type email_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_templatesCountAggregateInputType | true
    }

  export interface email_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_templates'], meta: { name: 'email_templates' } }
    /**
     * Find zero or one Email_templates that matches the filter.
     * @param {email_templatesFindUniqueArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_templatesFindUniqueArgs>(args: SelectSubset<T, email_templatesFindUniqueArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_templatesFindUniqueOrThrowArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, email_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindFirstArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_templatesFindFirstArgs>(args?: SelectSubset<T, email_templatesFindFirstArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindFirstOrThrowArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, email_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_templates
     * const email_templates = await prisma.email_templates.findMany()
     * 
     * // Get first 10 Email_templates
     * const email_templates = await prisma.email_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_templatesFindManyArgs>(args?: SelectSubset<T, email_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_templates.
     * @param {email_templatesCreateArgs} args - Arguments to create a Email_templates.
     * @example
     * // Create one Email_templates
     * const Email_templates = await prisma.email_templates.create({
     *   data: {
     *     // ... data to create a Email_templates
     *   }
     * })
     * 
     */
    create<T extends email_templatesCreateArgs>(args: SelectSubset<T, email_templatesCreateArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_templates.
     * @param {email_templatesCreateManyArgs} args - Arguments to create many Email_templates.
     * @example
     * // Create many Email_templates
     * const email_templates = await prisma.email_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_templatesCreateManyArgs>(args?: SelectSubset<T, email_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_templates and returns the data saved in the database.
     * @param {email_templatesCreateManyAndReturnArgs} args - Arguments to create many Email_templates.
     * @example
     * // Create many Email_templates
     * const email_templates = await prisma.email_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_templates and only return the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, email_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_templates.
     * @param {email_templatesDeleteArgs} args - Arguments to delete one Email_templates.
     * @example
     * // Delete one Email_templates
     * const Email_templates = await prisma.email_templates.delete({
     *   where: {
     *     // ... filter to delete one Email_templates
     *   }
     * })
     * 
     */
    delete<T extends email_templatesDeleteArgs>(args: SelectSubset<T, email_templatesDeleteArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_templates.
     * @param {email_templatesUpdateArgs} args - Arguments to update one Email_templates.
     * @example
     * // Update one Email_templates
     * const email_templates = await prisma.email_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_templatesUpdateArgs>(args: SelectSubset<T, email_templatesUpdateArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_templates.
     * @param {email_templatesDeleteManyArgs} args - Arguments to filter Email_templates to delete.
     * @example
     * // Delete a few Email_templates
     * const { count } = await prisma.email_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_templatesDeleteManyArgs>(args?: SelectSubset<T, email_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_templates
     * const email_templates = await prisma.email_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_templatesUpdateManyArgs>(args: SelectSubset<T, email_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_templates and returns the data updated in the database.
     * @param {email_templatesUpdateManyAndReturnArgs} args - Arguments to update many Email_templates.
     * @example
     * // Update many Email_templates
     * const email_templates = await prisma.email_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_templates and only return the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, email_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_templates.
     * @param {email_templatesUpsertArgs} args - Arguments to update or create a Email_templates.
     * @example
     * // Update or create a Email_templates
     * const email_templates = await prisma.email_templates.upsert({
     *   create: {
     *     // ... data to create a Email_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_templates we want to update
     *   }
     * })
     */
    upsert<T extends email_templatesUpsertArgs>(args: SelectSubset<T, email_templatesUpsertArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesCountArgs} args - Arguments to filter Email_templates to count.
     * @example
     * // Count the number of Email_templates
     * const count = await prisma.email_templates.count({
     *   where: {
     *     // ... the filter for the Email_templates we want to count
     *   }
     * })
    **/
    count<T extends email_templatesCountArgs>(
      args?: Subset<T, email_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_templatesAggregateArgs>(args: Subset<T, Email_templatesAggregateArgs>): Prisma.PrismaPromise<GetEmail_templatesAggregateType<T>>

    /**
     * Group by Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_templatesGroupByArgs['orderBy'] }
        : { orderBy?: email_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_templates model
   */
  readonly fields: email_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_templates model
   */
  interface email_templatesFieldRefs {
    readonly id: FieldRef<"email_templates", 'Int'>
    readonly name: FieldRef<"email_templates", 'String'>
    readonly description: FieldRef<"email_templates", 'String'>
    readonly html_code: FieldRef<"email_templates", 'String'>
    readonly variables: FieldRef<"email_templates", 'String[]'>
    readonly is_default: FieldRef<"email_templates", 'Boolean'>
    readonly preview_image_url: FieldRef<"email_templates", 'String'>
    readonly created_at: FieldRef<"email_templates", 'DateTime'>
    readonly updated_at: FieldRef<"email_templates", 'DateTime'>
    readonly created_by: FieldRef<"email_templates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * email_templates findUnique
   */
  export type email_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates findUniqueOrThrow
   */
  export type email_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates findFirst
   */
  export type email_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_templates.
     */
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates findFirstOrThrow
   */
  export type email_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_templates.
     */
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates findMany
   */
  export type email_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates create
   */
  export type email_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data needed to create a email_templates.
     */
    data: XOR<email_templatesCreateInput, email_templatesUncheckedCreateInput>
  }

  /**
   * email_templates createMany
   */
  export type email_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_templates.
     */
    data: email_templatesCreateManyInput | email_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_templates createManyAndReturn
   */
  export type email_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many email_templates.
     */
    data: email_templatesCreateManyInput | email_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_templates update
   */
  export type email_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data needed to update a email_templates.
     */
    data: XOR<email_templatesUpdateInput, email_templatesUncheckedUpdateInput>
    /**
     * Choose, which email_templates to update.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates updateMany
   */
  export type email_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_templates.
     */
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyInput>
    /**
     * Filter which email_templates to update
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to update.
     */
    limit?: number
  }

  /**
   * email_templates updateManyAndReturn
   */
  export type email_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data used to update email_templates.
     */
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyInput>
    /**
     * Filter which email_templates to update
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to update.
     */
    limit?: number
  }

  /**
   * email_templates upsert
   */
  export type email_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The filter to search for the email_templates to update in case it exists.
     */
    where: email_templatesWhereUniqueInput
    /**
     * In case the email_templates found by the `where` argument doesn't exist, create a new email_templates with this data.
     */
    create: XOR<email_templatesCreateInput, email_templatesUncheckedCreateInput>
    /**
     * In case the email_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_templatesUpdateInput, email_templatesUncheckedUpdateInput>
  }

  /**
   * email_templates delete
   */
  export type email_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter which email_templates to delete.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates deleteMany
   */
  export type email_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_templates to delete
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to delete.
     */
    limit?: number
  }

  /**
   * email_templates without action
   */
  export type email_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
  }


  /**
   * Model ib_client_linking
   */

  export type AggregateIb_client_linking = {
    _count: Ib_client_linkingCountAggregateOutputType | null
    _avg: Ib_client_linkingAvgAggregateOutputType | null
    _sum: Ib_client_linkingSumAggregateOutputType | null
    _min: Ib_client_linkingMinAggregateOutputType | null
    _max: Ib_client_linkingMaxAggregateOutputType | null
  }

  export type Ib_client_linkingAvgAggregateOutputType = {
    id: number | null
    current_ib_id: number | null
    assigned_ib_id: number | null
    direct_volume_lots: Decimal | null
    direct_commission: Decimal | null
    created_by: number | null
  }

  export type Ib_client_linkingSumAggregateOutputType = {
    id: number | null
    current_ib_id: number | null
    assigned_ib_id: number | null
    direct_volume_lots: Decimal | null
    direct_commission: Decimal | null
    created_by: number | null
  }

  export type Ib_client_linkingMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    user_account_id: string | null
    current_ib_id: number | null
    current_ib_name: string | null
    current_ib_code: string | null
    assigned_ib_id: number | null
    assigned_ib_name: string | null
    assigned_ib_code: string | null
    assigned_ib_email: string | null
    status: string | null
    direct_volume_lots: Decimal | null
    direct_commission: Decimal | null
    linked_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
  }

  export type Ib_client_linkingMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    user_account_id: string | null
    current_ib_id: number | null
    current_ib_name: string | null
    current_ib_code: string | null
    assigned_ib_id: number | null
    assigned_ib_name: string | null
    assigned_ib_code: string | null
    assigned_ib_email: string | null
    status: string | null
    direct_volume_lots: Decimal | null
    direct_commission: Decimal | null
    linked_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
  }

  export type Ib_client_linkingCountAggregateOutputType = {
    id: number
    user_id: number
    user_name: number
    user_email: number
    user_account_id: number
    current_ib_id: number
    current_ib_name: number
    current_ib_code: number
    assigned_ib_id: number
    assigned_ib_name: number
    assigned_ib_code: number
    assigned_ib_email: number
    status: number
    direct_volume_lots: number
    direct_commission: number
    linked_at: number
    created_at: number
    updated_at: number
    created_by: number
    _all: number
  }


  export type Ib_client_linkingAvgAggregateInputType = {
    id?: true
    current_ib_id?: true
    assigned_ib_id?: true
    direct_volume_lots?: true
    direct_commission?: true
    created_by?: true
  }

  export type Ib_client_linkingSumAggregateInputType = {
    id?: true
    current_ib_id?: true
    assigned_ib_id?: true
    direct_volume_lots?: true
    direct_commission?: true
    created_by?: true
  }

  export type Ib_client_linkingMinAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    user_account_id?: true
    current_ib_id?: true
    current_ib_name?: true
    current_ib_code?: true
    assigned_ib_id?: true
    assigned_ib_name?: true
    assigned_ib_code?: true
    assigned_ib_email?: true
    status?: true
    direct_volume_lots?: true
    direct_commission?: true
    linked_at?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type Ib_client_linkingMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    user_account_id?: true
    current_ib_id?: true
    current_ib_name?: true
    current_ib_code?: true
    assigned_ib_id?: true
    assigned_ib_name?: true
    assigned_ib_code?: true
    assigned_ib_email?: true
    status?: true
    direct_volume_lots?: true
    direct_commission?: true
    linked_at?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type Ib_client_linkingCountAggregateInputType = {
    id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    user_account_id?: true
    current_ib_id?: true
    current_ib_name?: true
    current_ib_code?: true
    assigned_ib_id?: true
    assigned_ib_name?: true
    assigned_ib_code?: true
    assigned_ib_email?: true
    status?: true
    direct_volume_lots?: true
    direct_commission?: true
    linked_at?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    _all?: true
  }

  export type Ib_client_linkingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_client_linking to aggregate.
     */
    where?: ib_client_linkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linkings to fetch.
     */
    orderBy?: ib_client_linkingOrderByWithRelationInput | ib_client_linkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_client_linkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_client_linkings
    **/
    _count?: true | Ib_client_linkingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_client_linkingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_client_linkingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_client_linkingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_client_linkingMaxAggregateInputType
  }

  export type GetIb_client_linkingAggregateType<T extends Ib_client_linkingAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_client_linking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_client_linking[P]>
      : GetScalarType<T[P], AggregateIb_client_linking[P]>
  }




  export type ib_client_linkingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_client_linkingWhereInput
    orderBy?: ib_client_linkingOrderByWithAggregationInput | ib_client_linkingOrderByWithAggregationInput[]
    by: Ib_client_linkingScalarFieldEnum[] | Ib_client_linkingScalarFieldEnum
    having?: ib_client_linkingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_client_linkingCountAggregateInputType | true
    _avg?: Ib_client_linkingAvgAggregateInputType
    _sum?: Ib_client_linkingSumAggregateInputType
    _min?: Ib_client_linkingMinAggregateInputType
    _max?: Ib_client_linkingMaxAggregateInputType
  }

  export type Ib_client_linkingGroupByOutputType = {
    id: number
    user_id: string
    user_name: string
    user_email: string
    user_account_id: string | null
    current_ib_id: number | null
    current_ib_name: string | null
    current_ib_code: string | null
    assigned_ib_id: number
    assigned_ib_name: string
    assigned_ib_code: string | null
    assigned_ib_email: string | null
    status: string | null
    direct_volume_lots: Decimal | null
    direct_commission: Decimal | null
    linked_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
    _count: Ib_client_linkingCountAggregateOutputType | null
    _avg: Ib_client_linkingAvgAggregateOutputType | null
    _sum: Ib_client_linkingSumAggregateOutputType | null
    _min: Ib_client_linkingMinAggregateOutputType | null
    _max: Ib_client_linkingMaxAggregateOutputType | null
  }

  type GetIb_client_linkingGroupByPayload<T extends ib_client_linkingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_client_linkingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_client_linkingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_client_linkingGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_client_linkingGroupByOutputType[P]>
        }
      >
    >


  export type ib_client_linkingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    user_account_id?: boolean
    current_ib_id?: boolean
    current_ib_name?: boolean
    current_ib_code?: boolean
    assigned_ib_id?: boolean
    assigned_ib_name?: boolean
    assigned_ib_code?: boolean
    assigned_ib_email?: boolean
    status?: boolean
    direct_volume_lots?: boolean
    direct_commission?: boolean
    linked_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["ib_client_linking"]>

  export type ib_client_linkingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    user_account_id?: boolean
    current_ib_id?: boolean
    current_ib_name?: boolean
    current_ib_code?: boolean
    assigned_ib_id?: boolean
    assigned_ib_name?: boolean
    assigned_ib_code?: boolean
    assigned_ib_email?: boolean
    status?: boolean
    direct_volume_lots?: boolean
    direct_commission?: boolean
    linked_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["ib_client_linking"]>

  export type ib_client_linkingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    user_account_id?: boolean
    current_ib_id?: boolean
    current_ib_name?: boolean
    current_ib_code?: boolean
    assigned_ib_id?: boolean
    assigned_ib_name?: boolean
    assigned_ib_code?: boolean
    assigned_ib_email?: boolean
    status?: boolean
    direct_volume_lots?: boolean
    direct_commission?: boolean
    linked_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["ib_client_linking"]>

  export type ib_client_linkingSelectScalar = {
    id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    user_account_id?: boolean
    current_ib_id?: boolean
    current_ib_name?: boolean
    current_ib_code?: boolean
    assigned_ib_id?: boolean
    assigned_ib_name?: boolean
    assigned_ib_code?: boolean
    assigned_ib_email?: boolean
    status?: boolean
    direct_volume_lots?: boolean
    direct_commission?: boolean
    linked_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }

  export type ib_client_linkingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "user_name" | "user_email" | "user_account_id" | "current_ib_id" | "current_ib_name" | "current_ib_code" | "assigned_ib_id" | "assigned_ib_name" | "assigned_ib_code" | "assigned_ib_email" | "status" | "direct_volume_lots" | "direct_commission" | "linked_at" | "created_at" | "updated_at" | "created_by", ExtArgs["result"]["ib_client_linking"]>

  export type $ib_client_linkingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_client_linking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      user_name: string
      user_email: string
      user_account_id: string | null
      current_ib_id: number | null
      current_ib_name: string | null
      current_ib_code: string | null
      assigned_ib_id: number
      assigned_ib_name: string
      assigned_ib_code: string | null
      assigned_ib_email: string | null
      status: string | null
      direct_volume_lots: Prisma.Decimal | null
      direct_commission: Prisma.Decimal | null
      linked_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      created_by: number | null
    }, ExtArgs["result"]["ib_client_linking"]>
    composites: {}
  }

  type ib_client_linkingGetPayload<S extends boolean | null | undefined | ib_client_linkingDefaultArgs> = $Result.GetResult<Prisma.$ib_client_linkingPayload, S>

  type ib_client_linkingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_client_linkingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_client_linkingCountAggregateInputType | true
    }

  export interface ib_client_linkingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_client_linking'], meta: { name: 'ib_client_linking' } }
    /**
     * Find zero or one Ib_client_linking that matches the filter.
     * @param {ib_client_linkingFindUniqueArgs} args - Arguments to find a Ib_client_linking
     * @example
     * // Get one Ib_client_linking
     * const ib_client_linking = await prisma.ib_client_linking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_client_linkingFindUniqueArgs>(args: SelectSubset<T, ib_client_linkingFindUniqueArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_client_linking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_client_linkingFindUniqueOrThrowArgs} args - Arguments to find a Ib_client_linking
     * @example
     * // Get one Ib_client_linking
     * const ib_client_linking = await prisma.ib_client_linking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_client_linkingFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_client_linkingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_client_linking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linkingFindFirstArgs} args - Arguments to find a Ib_client_linking
     * @example
     * // Get one Ib_client_linking
     * const ib_client_linking = await prisma.ib_client_linking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_client_linkingFindFirstArgs>(args?: SelectSubset<T, ib_client_linkingFindFirstArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_client_linking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linkingFindFirstOrThrowArgs} args - Arguments to find a Ib_client_linking
     * @example
     * // Get one Ib_client_linking
     * const ib_client_linking = await prisma.ib_client_linking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_client_linkingFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_client_linkingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_client_linkings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linkingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_client_linkings
     * const ib_client_linkings = await prisma.ib_client_linking.findMany()
     * 
     * // Get first 10 Ib_client_linkings
     * const ib_client_linkings = await prisma.ib_client_linking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_client_linkingWithIdOnly = await prisma.ib_client_linking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_client_linkingFindManyArgs>(args?: SelectSubset<T, ib_client_linkingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_client_linking.
     * @param {ib_client_linkingCreateArgs} args - Arguments to create a Ib_client_linking.
     * @example
     * // Create one Ib_client_linking
     * const Ib_client_linking = await prisma.ib_client_linking.create({
     *   data: {
     *     // ... data to create a Ib_client_linking
     *   }
     * })
     * 
     */
    create<T extends ib_client_linkingCreateArgs>(args: SelectSubset<T, ib_client_linkingCreateArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_client_linkings.
     * @param {ib_client_linkingCreateManyArgs} args - Arguments to create many Ib_client_linkings.
     * @example
     * // Create many Ib_client_linkings
     * const ib_client_linking = await prisma.ib_client_linking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_client_linkingCreateManyArgs>(args?: SelectSubset<T, ib_client_linkingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_client_linkings and returns the data saved in the database.
     * @param {ib_client_linkingCreateManyAndReturnArgs} args - Arguments to create many Ib_client_linkings.
     * @example
     * // Create many Ib_client_linkings
     * const ib_client_linking = await prisma.ib_client_linking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_client_linkings and only return the `id`
     * const ib_client_linkingWithIdOnly = await prisma.ib_client_linking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_client_linkingCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_client_linkingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_client_linking.
     * @param {ib_client_linkingDeleteArgs} args - Arguments to delete one Ib_client_linking.
     * @example
     * // Delete one Ib_client_linking
     * const Ib_client_linking = await prisma.ib_client_linking.delete({
     *   where: {
     *     // ... filter to delete one Ib_client_linking
     *   }
     * })
     * 
     */
    delete<T extends ib_client_linkingDeleteArgs>(args: SelectSubset<T, ib_client_linkingDeleteArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_client_linking.
     * @param {ib_client_linkingUpdateArgs} args - Arguments to update one Ib_client_linking.
     * @example
     * // Update one Ib_client_linking
     * const ib_client_linking = await prisma.ib_client_linking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_client_linkingUpdateArgs>(args: SelectSubset<T, ib_client_linkingUpdateArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_client_linkings.
     * @param {ib_client_linkingDeleteManyArgs} args - Arguments to filter Ib_client_linkings to delete.
     * @example
     * // Delete a few Ib_client_linkings
     * const { count } = await prisma.ib_client_linking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_client_linkingDeleteManyArgs>(args?: SelectSubset<T, ib_client_linkingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_client_linkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linkingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_client_linkings
     * const ib_client_linking = await prisma.ib_client_linking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_client_linkingUpdateManyArgs>(args: SelectSubset<T, ib_client_linkingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_client_linkings and returns the data updated in the database.
     * @param {ib_client_linkingUpdateManyAndReturnArgs} args - Arguments to update many Ib_client_linkings.
     * @example
     * // Update many Ib_client_linkings
     * const ib_client_linking = await prisma.ib_client_linking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_client_linkings and only return the `id`
     * const ib_client_linkingWithIdOnly = await prisma.ib_client_linking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_client_linkingUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_client_linkingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_client_linking.
     * @param {ib_client_linkingUpsertArgs} args - Arguments to update or create a Ib_client_linking.
     * @example
     * // Update or create a Ib_client_linking
     * const ib_client_linking = await prisma.ib_client_linking.upsert({
     *   create: {
     *     // ... data to create a Ib_client_linking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_client_linking we want to update
     *   }
     * })
     */
    upsert<T extends ib_client_linkingUpsertArgs>(args: SelectSubset<T, ib_client_linkingUpsertArgs<ExtArgs>>): Prisma__ib_client_linkingClient<$Result.GetResult<Prisma.$ib_client_linkingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_client_linkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linkingCountArgs} args - Arguments to filter Ib_client_linkings to count.
     * @example
     * // Count the number of Ib_client_linkings
     * const count = await prisma.ib_client_linking.count({
     *   where: {
     *     // ... the filter for the Ib_client_linkings we want to count
     *   }
     * })
    **/
    count<T extends ib_client_linkingCountArgs>(
      args?: Subset<T, ib_client_linkingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_client_linkingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_client_linking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_client_linkingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_client_linkingAggregateArgs>(args: Subset<T, Ib_client_linkingAggregateArgs>): Prisma.PrismaPromise<GetIb_client_linkingAggregateType<T>>

    /**
     * Group by Ib_client_linking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linkingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_client_linkingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_client_linkingGroupByArgs['orderBy'] }
        : { orderBy?: ib_client_linkingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_client_linkingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_client_linkingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_client_linking model
   */
  readonly fields: ib_client_linkingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_client_linking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_client_linkingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_client_linking model
   */
  interface ib_client_linkingFieldRefs {
    readonly id: FieldRef<"ib_client_linking", 'Int'>
    readonly user_id: FieldRef<"ib_client_linking", 'String'>
    readonly user_name: FieldRef<"ib_client_linking", 'String'>
    readonly user_email: FieldRef<"ib_client_linking", 'String'>
    readonly user_account_id: FieldRef<"ib_client_linking", 'String'>
    readonly current_ib_id: FieldRef<"ib_client_linking", 'Int'>
    readonly current_ib_name: FieldRef<"ib_client_linking", 'String'>
    readonly current_ib_code: FieldRef<"ib_client_linking", 'String'>
    readonly assigned_ib_id: FieldRef<"ib_client_linking", 'Int'>
    readonly assigned_ib_name: FieldRef<"ib_client_linking", 'String'>
    readonly assigned_ib_code: FieldRef<"ib_client_linking", 'String'>
    readonly assigned_ib_email: FieldRef<"ib_client_linking", 'String'>
    readonly status: FieldRef<"ib_client_linking", 'String'>
    readonly direct_volume_lots: FieldRef<"ib_client_linking", 'Decimal'>
    readonly direct_commission: FieldRef<"ib_client_linking", 'Decimal'>
    readonly linked_at: FieldRef<"ib_client_linking", 'DateTime'>
    readonly created_at: FieldRef<"ib_client_linking", 'DateTime'>
    readonly updated_at: FieldRef<"ib_client_linking", 'DateTime'>
    readonly created_by: FieldRef<"ib_client_linking", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ib_client_linking findUnique
   */
  export type ib_client_linkingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking to fetch.
     */
    where: ib_client_linkingWhereUniqueInput
  }

  /**
   * ib_client_linking findUniqueOrThrow
   */
  export type ib_client_linkingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking to fetch.
     */
    where: ib_client_linkingWhereUniqueInput
  }

  /**
   * ib_client_linking findFirst
   */
  export type ib_client_linkingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking to fetch.
     */
    where?: ib_client_linkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linkings to fetch.
     */
    orderBy?: ib_client_linkingOrderByWithRelationInput | ib_client_linkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_client_linkings.
     */
    cursor?: ib_client_linkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_client_linkings.
     */
    distinct?: Ib_client_linkingScalarFieldEnum | Ib_client_linkingScalarFieldEnum[]
  }

  /**
   * ib_client_linking findFirstOrThrow
   */
  export type ib_client_linkingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking to fetch.
     */
    where?: ib_client_linkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linkings to fetch.
     */
    orderBy?: ib_client_linkingOrderByWithRelationInput | ib_client_linkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_client_linkings.
     */
    cursor?: ib_client_linkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_client_linkings.
     */
    distinct?: Ib_client_linkingScalarFieldEnum | Ib_client_linkingScalarFieldEnum[]
  }

  /**
   * ib_client_linking findMany
   */
  export type ib_client_linkingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linkings to fetch.
     */
    where?: ib_client_linkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linkings to fetch.
     */
    orderBy?: ib_client_linkingOrderByWithRelationInput | ib_client_linkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_client_linkings.
     */
    cursor?: ib_client_linkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linkings.
     */
    skip?: number
    distinct?: Ib_client_linkingScalarFieldEnum | Ib_client_linkingScalarFieldEnum[]
  }

  /**
   * ib_client_linking create
   */
  export type ib_client_linkingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_client_linking.
     */
    data: XOR<ib_client_linkingCreateInput, ib_client_linkingUncheckedCreateInput>
  }

  /**
   * ib_client_linking createMany
   */
  export type ib_client_linkingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_client_linkings.
     */
    data: ib_client_linkingCreateManyInput | ib_client_linkingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_client_linking createManyAndReturn
   */
  export type ib_client_linkingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * The data used to create many ib_client_linkings.
     */
    data: ib_client_linkingCreateManyInput | ib_client_linkingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_client_linking update
   */
  export type ib_client_linkingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_client_linking.
     */
    data: XOR<ib_client_linkingUpdateInput, ib_client_linkingUncheckedUpdateInput>
    /**
     * Choose, which ib_client_linking to update.
     */
    where: ib_client_linkingWhereUniqueInput
  }

  /**
   * ib_client_linking updateMany
   */
  export type ib_client_linkingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_client_linkings.
     */
    data: XOR<ib_client_linkingUpdateManyMutationInput, ib_client_linkingUncheckedUpdateManyInput>
    /**
     * Filter which ib_client_linkings to update
     */
    where?: ib_client_linkingWhereInput
    /**
     * Limit how many ib_client_linkings to update.
     */
    limit?: number
  }

  /**
   * ib_client_linking updateManyAndReturn
   */
  export type ib_client_linkingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * The data used to update ib_client_linkings.
     */
    data: XOR<ib_client_linkingUpdateManyMutationInput, ib_client_linkingUncheckedUpdateManyInput>
    /**
     * Filter which ib_client_linkings to update
     */
    where?: ib_client_linkingWhereInput
    /**
     * Limit how many ib_client_linkings to update.
     */
    limit?: number
  }

  /**
   * ib_client_linking upsert
   */
  export type ib_client_linkingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_client_linking to update in case it exists.
     */
    where: ib_client_linkingWhereUniqueInput
    /**
     * In case the ib_client_linking found by the `where` argument doesn't exist, create a new ib_client_linking with this data.
     */
    create: XOR<ib_client_linkingCreateInput, ib_client_linkingUncheckedCreateInput>
    /**
     * In case the ib_client_linking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_client_linkingUpdateInput, ib_client_linkingUncheckedUpdateInput>
  }

  /**
   * ib_client_linking delete
   */
  export type ib_client_linkingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
    /**
     * Filter which ib_client_linking to delete.
     */
    where: ib_client_linkingWhereUniqueInput
  }

  /**
   * ib_client_linking deleteMany
   */
  export type ib_client_linkingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_client_linkings to delete
     */
    where?: ib_client_linkingWhereInput
    /**
     * Limit how many ib_client_linkings to delete.
     */
    limit?: number
  }

  /**
   * ib_client_linking without action
   */
  export type ib_client_linkingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking
     */
    select?: ib_client_linkingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking
     */
    omit?: ib_client_linkingOmit<ExtArgs> | null
  }


  /**
   * Model ib_client_linking_history
   */

  export type AggregateIb_client_linking_history = {
    _count: Ib_client_linking_historyCountAggregateOutputType | null
    _avg: Ib_client_linking_historyAvgAggregateOutputType | null
    _sum: Ib_client_linking_historySumAggregateOutputType | null
    _min: Ib_client_linking_historyMinAggregateOutputType | null
    _max: Ib_client_linking_historyMaxAggregateOutputType | null
  }

  export type Ib_client_linking_historyAvgAggregateOutputType = {
    id: number | null
    linking_id: number | null
    from_ib_id: number | null
    to_ib_id: number | null
    moved_by: number | null
  }

  export type Ib_client_linking_historySumAggregateOutputType = {
    id: number | null
    linking_id: number | null
    from_ib_id: number | null
    to_ib_id: number | null
    moved_by: number | null
  }

  export type Ib_client_linking_historyMinAggregateOutputType = {
    id: number | null
    linking_id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    from_ib_id: number | null
    from_ib_name: string | null
    from_ib_code: string | null
    to_ib_id: number | null
    to_ib_name: string | null
    to_ib_code: string | null
    action: string | null
    moved_by: number | null
    moved_by_name: string | null
    notes: string | null
    created_at: Date | null
  }

  export type Ib_client_linking_historyMaxAggregateOutputType = {
    id: number | null
    linking_id: number | null
    user_id: string | null
    user_name: string | null
    user_email: string | null
    from_ib_id: number | null
    from_ib_name: string | null
    from_ib_code: string | null
    to_ib_id: number | null
    to_ib_name: string | null
    to_ib_code: string | null
    action: string | null
    moved_by: number | null
    moved_by_name: string | null
    notes: string | null
    created_at: Date | null
  }

  export type Ib_client_linking_historyCountAggregateOutputType = {
    id: number
    linking_id: number
    user_id: number
    user_name: number
    user_email: number
    from_ib_id: number
    from_ib_name: number
    from_ib_code: number
    to_ib_id: number
    to_ib_name: number
    to_ib_code: number
    action: number
    moved_by: number
    moved_by_name: number
    notes: number
    created_at: number
    _all: number
  }


  export type Ib_client_linking_historyAvgAggregateInputType = {
    id?: true
    linking_id?: true
    from_ib_id?: true
    to_ib_id?: true
    moved_by?: true
  }

  export type Ib_client_linking_historySumAggregateInputType = {
    id?: true
    linking_id?: true
    from_ib_id?: true
    to_ib_id?: true
    moved_by?: true
  }

  export type Ib_client_linking_historyMinAggregateInputType = {
    id?: true
    linking_id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    from_ib_id?: true
    from_ib_name?: true
    from_ib_code?: true
    to_ib_id?: true
    to_ib_name?: true
    to_ib_code?: true
    action?: true
    moved_by?: true
    moved_by_name?: true
    notes?: true
    created_at?: true
  }

  export type Ib_client_linking_historyMaxAggregateInputType = {
    id?: true
    linking_id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    from_ib_id?: true
    from_ib_name?: true
    from_ib_code?: true
    to_ib_id?: true
    to_ib_name?: true
    to_ib_code?: true
    action?: true
    moved_by?: true
    moved_by_name?: true
    notes?: true
    created_at?: true
  }

  export type Ib_client_linking_historyCountAggregateInputType = {
    id?: true
    linking_id?: true
    user_id?: true
    user_name?: true
    user_email?: true
    from_ib_id?: true
    from_ib_name?: true
    from_ib_code?: true
    to_ib_id?: true
    to_ib_name?: true
    to_ib_code?: true
    action?: true
    moved_by?: true
    moved_by_name?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type Ib_client_linking_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_client_linking_history to aggregate.
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linking_histories to fetch.
     */
    orderBy?: ib_client_linking_historyOrderByWithRelationInput | ib_client_linking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_client_linking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linking_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_client_linking_histories
    **/
    _count?: true | Ib_client_linking_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_client_linking_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_client_linking_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_client_linking_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_client_linking_historyMaxAggregateInputType
  }

  export type GetIb_client_linking_historyAggregateType<T extends Ib_client_linking_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_client_linking_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_client_linking_history[P]>
      : GetScalarType<T[P], AggregateIb_client_linking_history[P]>
  }




  export type ib_client_linking_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_client_linking_historyWhereInput
    orderBy?: ib_client_linking_historyOrderByWithAggregationInput | ib_client_linking_historyOrderByWithAggregationInput[]
    by: Ib_client_linking_historyScalarFieldEnum[] | Ib_client_linking_historyScalarFieldEnum
    having?: ib_client_linking_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_client_linking_historyCountAggregateInputType | true
    _avg?: Ib_client_linking_historyAvgAggregateInputType
    _sum?: Ib_client_linking_historySumAggregateInputType
    _min?: Ib_client_linking_historyMinAggregateInputType
    _max?: Ib_client_linking_historyMaxAggregateInputType
  }

  export type Ib_client_linking_historyGroupByOutputType = {
    id: number
    linking_id: number | null
    user_id: string
    user_name: string
    user_email: string
    from_ib_id: number | null
    from_ib_name: string | null
    from_ib_code: string | null
    to_ib_id: number
    to_ib_name: string
    to_ib_code: string | null
    action: string
    moved_by: number | null
    moved_by_name: string | null
    notes: string | null
    created_at: Date | null
    _count: Ib_client_linking_historyCountAggregateOutputType | null
    _avg: Ib_client_linking_historyAvgAggregateOutputType | null
    _sum: Ib_client_linking_historySumAggregateOutputType | null
    _min: Ib_client_linking_historyMinAggregateOutputType | null
    _max: Ib_client_linking_historyMaxAggregateOutputType | null
  }

  type GetIb_client_linking_historyGroupByPayload<T extends ib_client_linking_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_client_linking_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_client_linking_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_client_linking_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_client_linking_historyGroupByOutputType[P]>
        }
      >
    >


  export type ib_client_linking_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linking_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    from_ib_id?: boolean
    from_ib_name?: boolean
    from_ib_code?: boolean
    to_ib_id?: boolean
    to_ib_name?: boolean
    to_ib_code?: boolean
    action?: boolean
    moved_by?: boolean
    moved_by_name?: boolean
    notes?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_client_linking_history"]>

  export type ib_client_linking_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linking_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    from_ib_id?: boolean
    from_ib_name?: boolean
    from_ib_code?: boolean
    to_ib_id?: boolean
    to_ib_name?: boolean
    to_ib_code?: boolean
    action?: boolean
    moved_by?: boolean
    moved_by_name?: boolean
    notes?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_client_linking_history"]>

  export type ib_client_linking_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linking_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    from_ib_id?: boolean
    from_ib_name?: boolean
    from_ib_code?: boolean
    to_ib_id?: boolean
    to_ib_name?: boolean
    to_ib_code?: boolean
    action?: boolean
    moved_by?: boolean
    moved_by_name?: boolean
    notes?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_client_linking_history"]>

  export type ib_client_linking_historySelectScalar = {
    id?: boolean
    linking_id?: boolean
    user_id?: boolean
    user_name?: boolean
    user_email?: boolean
    from_ib_id?: boolean
    from_ib_name?: boolean
    from_ib_code?: boolean
    to_ib_id?: boolean
    to_ib_name?: boolean
    to_ib_code?: boolean
    action?: boolean
    moved_by?: boolean
    moved_by_name?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type ib_client_linking_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "linking_id" | "user_id" | "user_name" | "user_email" | "from_ib_id" | "from_ib_name" | "from_ib_code" | "to_ib_id" | "to_ib_name" | "to_ib_code" | "action" | "moved_by" | "moved_by_name" | "notes" | "created_at", ExtArgs["result"]["ib_client_linking_history"]>

  export type $ib_client_linking_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_client_linking_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      linking_id: number | null
      user_id: string
      user_name: string
      user_email: string
      from_ib_id: number | null
      from_ib_name: string | null
      from_ib_code: string | null
      to_ib_id: number
      to_ib_name: string
      to_ib_code: string | null
      action: string
      moved_by: number | null
      moved_by_name: string | null
      notes: string | null
      created_at: Date | null
    }, ExtArgs["result"]["ib_client_linking_history"]>
    composites: {}
  }

  type ib_client_linking_historyGetPayload<S extends boolean | null | undefined | ib_client_linking_historyDefaultArgs> = $Result.GetResult<Prisma.$ib_client_linking_historyPayload, S>

  type ib_client_linking_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_client_linking_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_client_linking_historyCountAggregateInputType | true
    }

  export interface ib_client_linking_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_client_linking_history'], meta: { name: 'ib_client_linking_history' } }
    /**
     * Find zero or one Ib_client_linking_history that matches the filter.
     * @param {ib_client_linking_historyFindUniqueArgs} args - Arguments to find a Ib_client_linking_history
     * @example
     * // Get one Ib_client_linking_history
     * const ib_client_linking_history = await prisma.ib_client_linking_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_client_linking_historyFindUniqueArgs>(args: SelectSubset<T, ib_client_linking_historyFindUniqueArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_client_linking_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_client_linking_historyFindUniqueOrThrowArgs} args - Arguments to find a Ib_client_linking_history
     * @example
     * // Get one Ib_client_linking_history
     * const ib_client_linking_history = await prisma.ib_client_linking_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_client_linking_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_client_linking_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_client_linking_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linking_historyFindFirstArgs} args - Arguments to find a Ib_client_linking_history
     * @example
     * // Get one Ib_client_linking_history
     * const ib_client_linking_history = await prisma.ib_client_linking_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_client_linking_historyFindFirstArgs>(args?: SelectSubset<T, ib_client_linking_historyFindFirstArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_client_linking_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linking_historyFindFirstOrThrowArgs} args - Arguments to find a Ib_client_linking_history
     * @example
     * // Get one Ib_client_linking_history
     * const ib_client_linking_history = await prisma.ib_client_linking_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_client_linking_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_client_linking_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_client_linking_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linking_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_client_linking_histories
     * const ib_client_linking_histories = await prisma.ib_client_linking_history.findMany()
     * 
     * // Get first 10 Ib_client_linking_histories
     * const ib_client_linking_histories = await prisma.ib_client_linking_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_client_linking_historyWithIdOnly = await prisma.ib_client_linking_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_client_linking_historyFindManyArgs>(args?: SelectSubset<T, ib_client_linking_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_client_linking_history.
     * @param {ib_client_linking_historyCreateArgs} args - Arguments to create a Ib_client_linking_history.
     * @example
     * // Create one Ib_client_linking_history
     * const Ib_client_linking_history = await prisma.ib_client_linking_history.create({
     *   data: {
     *     // ... data to create a Ib_client_linking_history
     *   }
     * })
     * 
     */
    create<T extends ib_client_linking_historyCreateArgs>(args: SelectSubset<T, ib_client_linking_historyCreateArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_client_linking_histories.
     * @param {ib_client_linking_historyCreateManyArgs} args - Arguments to create many Ib_client_linking_histories.
     * @example
     * // Create many Ib_client_linking_histories
     * const ib_client_linking_history = await prisma.ib_client_linking_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_client_linking_historyCreateManyArgs>(args?: SelectSubset<T, ib_client_linking_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_client_linking_histories and returns the data saved in the database.
     * @param {ib_client_linking_historyCreateManyAndReturnArgs} args - Arguments to create many Ib_client_linking_histories.
     * @example
     * // Create many Ib_client_linking_histories
     * const ib_client_linking_history = await prisma.ib_client_linking_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_client_linking_histories and only return the `id`
     * const ib_client_linking_historyWithIdOnly = await prisma.ib_client_linking_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_client_linking_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_client_linking_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_client_linking_history.
     * @param {ib_client_linking_historyDeleteArgs} args - Arguments to delete one Ib_client_linking_history.
     * @example
     * // Delete one Ib_client_linking_history
     * const Ib_client_linking_history = await prisma.ib_client_linking_history.delete({
     *   where: {
     *     // ... filter to delete one Ib_client_linking_history
     *   }
     * })
     * 
     */
    delete<T extends ib_client_linking_historyDeleteArgs>(args: SelectSubset<T, ib_client_linking_historyDeleteArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_client_linking_history.
     * @param {ib_client_linking_historyUpdateArgs} args - Arguments to update one Ib_client_linking_history.
     * @example
     * // Update one Ib_client_linking_history
     * const ib_client_linking_history = await prisma.ib_client_linking_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_client_linking_historyUpdateArgs>(args: SelectSubset<T, ib_client_linking_historyUpdateArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_client_linking_histories.
     * @param {ib_client_linking_historyDeleteManyArgs} args - Arguments to filter Ib_client_linking_histories to delete.
     * @example
     * // Delete a few Ib_client_linking_histories
     * const { count } = await prisma.ib_client_linking_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_client_linking_historyDeleteManyArgs>(args?: SelectSubset<T, ib_client_linking_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_client_linking_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linking_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_client_linking_histories
     * const ib_client_linking_history = await prisma.ib_client_linking_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_client_linking_historyUpdateManyArgs>(args: SelectSubset<T, ib_client_linking_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_client_linking_histories and returns the data updated in the database.
     * @param {ib_client_linking_historyUpdateManyAndReturnArgs} args - Arguments to update many Ib_client_linking_histories.
     * @example
     * // Update many Ib_client_linking_histories
     * const ib_client_linking_history = await prisma.ib_client_linking_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_client_linking_histories and only return the `id`
     * const ib_client_linking_historyWithIdOnly = await prisma.ib_client_linking_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_client_linking_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_client_linking_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_client_linking_history.
     * @param {ib_client_linking_historyUpsertArgs} args - Arguments to update or create a Ib_client_linking_history.
     * @example
     * // Update or create a Ib_client_linking_history
     * const ib_client_linking_history = await prisma.ib_client_linking_history.upsert({
     *   create: {
     *     // ... data to create a Ib_client_linking_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_client_linking_history we want to update
     *   }
     * })
     */
    upsert<T extends ib_client_linking_historyUpsertArgs>(args: SelectSubset<T, ib_client_linking_historyUpsertArgs<ExtArgs>>): Prisma__ib_client_linking_historyClient<$Result.GetResult<Prisma.$ib_client_linking_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_client_linking_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linking_historyCountArgs} args - Arguments to filter Ib_client_linking_histories to count.
     * @example
     * // Count the number of Ib_client_linking_histories
     * const count = await prisma.ib_client_linking_history.count({
     *   where: {
     *     // ... the filter for the Ib_client_linking_histories we want to count
     *   }
     * })
    **/
    count<T extends ib_client_linking_historyCountArgs>(
      args?: Subset<T, ib_client_linking_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_client_linking_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_client_linking_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_client_linking_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_client_linking_historyAggregateArgs>(args: Subset<T, Ib_client_linking_historyAggregateArgs>): Prisma.PrismaPromise<GetIb_client_linking_historyAggregateType<T>>

    /**
     * Group by Ib_client_linking_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_client_linking_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_client_linking_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_client_linking_historyGroupByArgs['orderBy'] }
        : { orderBy?: ib_client_linking_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_client_linking_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_client_linking_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_client_linking_history model
   */
  readonly fields: ib_client_linking_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_client_linking_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_client_linking_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_client_linking_history model
   */
  interface ib_client_linking_historyFieldRefs {
    readonly id: FieldRef<"ib_client_linking_history", 'Int'>
    readonly linking_id: FieldRef<"ib_client_linking_history", 'Int'>
    readonly user_id: FieldRef<"ib_client_linking_history", 'String'>
    readonly user_name: FieldRef<"ib_client_linking_history", 'String'>
    readonly user_email: FieldRef<"ib_client_linking_history", 'String'>
    readonly from_ib_id: FieldRef<"ib_client_linking_history", 'Int'>
    readonly from_ib_name: FieldRef<"ib_client_linking_history", 'String'>
    readonly from_ib_code: FieldRef<"ib_client_linking_history", 'String'>
    readonly to_ib_id: FieldRef<"ib_client_linking_history", 'Int'>
    readonly to_ib_name: FieldRef<"ib_client_linking_history", 'String'>
    readonly to_ib_code: FieldRef<"ib_client_linking_history", 'String'>
    readonly action: FieldRef<"ib_client_linking_history", 'String'>
    readonly moved_by: FieldRef<"ib_client_linking_history", 'Int'>
    readonly moved_by_name: FieldRef<"ib_client_linking_history", 'String'>
    readonly notes: FieldRef<"ib_client_linking_history", 'String'>
    readonly created_at: FieldRef<"ib_client_linking_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_client_linking_history findUnique
   */
  export type ib_client_linking_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking_history to fetch.
     */
    where: ib_client_linking_historyWhereUniqueInput
  }

  /**
   * ib_client_linking_history findUniqueOrThrow
   */
  export type ib_client_linking_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking_history to fetch.
     */
    where: ib_client_linking_historyWhereUniqueInput
  }

  /**
   * ib_client_linking_history findFirst
   */
  export type ib_client_linking_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking_history to fetch.
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linking_histories to fetch.
     */
    orderBy?: ib_client_linking_historyOrderByWithRelationInput | ib_client_linking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_client_linking_histories.
     */
    cursor?: ib_client_linking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linking_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_client_linking_histories.
     */
    distinct?: Ib_client_linking_historyScalarFieldEnum | Ib_client_linking_historyScalarFieldEnum[]
  }

  /**
   * ib_client_linking_history findFirstOrThrow
   */
  export type ib_client_linking_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking_history to fetch.
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linking_histories to fetch.
     */
    orderBy?: ib_client_linking_historyOrderByWithRelationInput | ib_client_linking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_client_linking_histories.
     */
    cursor?: ib_client_linking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linking_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_client_linking_histories.
     */
    distinct?: Ib_client_linking_historyScalarFieldEnum | Ib_client_linking_historyScalarFieldEnum[]
  }

  /**
   * ib_client_linking_history findMany
   */
  export type ib_client_linking_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_client_linking_histories to fetch.
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_client_linking_histories to fetch.
     */
    orderBy?: ib_client_linking_historyOrderByWithRelationInput | ib_client_linking_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_client_linking_histories.
     */
    cursor?: ib_client_linking_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_client_linking_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_client_linking_histories.
     */
    skip?: number
    distinct?: Ib_client_linking_historyScalarFieldEnum | Ib_client_linking_historyScalarFieldEnum[]
  }

  /**
   * ib_client_linking_history create
   */
  export type ib_client_linking_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_client_linking_history.
     */
    data: XOR<ib_client_linking_historyCreateInput, ib_client_linking_historyUncheckedCreateInput>
  }

  /**
   * ib_client_linking_history createMany
   */
  export type ib_client_linking_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_client_linking_histories.
     */
    data: ib_client_linking_historyCreateManyInput | ib_client_linking_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_client_linking_history createManyAndReturn
   */
  export type ib_client_linking_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * The data used to create many ib_client_linking_histories.
     */
    data: ib_client_linking_historyCreateManyInput | ib_client_linking_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_client_linking_history update
   */
  export type ib_client_linking_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_client_linking_history.
     */
    data: XOR<ib_client_linking_historyUpdateInput, ib_client_linking_historyUncheckedUpdateInput>
    /**
     * Choose, which ib_client_linking_history to update.
     */
    where: ib_client_linking_historyWhereUniqueInput
  }

  /**
   * ib_client_linking_history updateMany
   */
  export type ib_client_linking_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_client_linking_histories.
     */
    data: XOR<ib_client_linking_historyUpdateManyMutationInput, ib_client_linking_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_client_linking_histories to update
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * Limit how many ib_client_linking_histories to update.
     */
    limit?: number
  }

  /**
   * ib_client_linking_history updateManyAndReturn
   */
  export type ib_client_linking_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * The data used to update ib_client_linking_histories.
     */
    data: XOR<ib_client_linking_historyUpdateManyMutationInput, ib_client_linking_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_client_linking_histories to update
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * Limit how many ib_client_linking_histories to update.
     */
    limit?: number
  }

  /**
   * ib_client_linking_history upsert
   */
  export type ib_client_linking_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_client_linking_history to update in case it exists.
     */
    where: ib_client_linking_historyWhereUniqueInput
    /**
     * In case the ib_client_linking_history found by the `where` argument doesn't exist, create a new ib_client_linking_history with this data.
     */
    create: XOR<ib_client_linking_historyCreateInput, ib_client_linking_historyUncheckedCreateInput>
    /**
     * In case the ib_client_linking_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_client_linking_historyUpdateInput, ib_client_linking_historyUncheckedUpdateInput>
  }

  /**
   * ib_client_linking_history delete
   */
  export type ib_client_linking_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
    /**
     * Filter which ib_client_linking_history to delete.
     */
    where: ib_client_linking_historyWhereUniqueInput
  }

  /**
   * ib_client_linking_history deleteMany
   */
  export type ib_client_linking_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_client_linking_histories to delete
     */
    where?: ib_client_linking_historyWhereInput
    /**
     * Limit how many ib_client_linking_histories to delete.
     */
    limit?: number
  }

  /**
   * ib_client_linking_history without action
   */
  export type ib_client_linking_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_client_linking_history
     */
    select?: ib_client_linking_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_client_linking_history
     */
    omit?: ib_client_linking_historyOmit<ExtArgs> | null
  }


  /**
   * Model ib_commission
   */

  export type AggregateIb_commission = {
    _count: Ib_commissionCountAggregateOutputType | null
    _avg: Ib_commissionAvgAggregateOutputType | null
    _sum: Ib_commissionSumAggregateOutputType | null
    _min: Ib_commissionMinAggregateOutputType | null
    _max: Ib_commissionMaxAggregateOutputType | null
  }

  export type Ib_commissionAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    total_commission: Decimal | null
    total_trades: number | null
    total_lots: Decimal | null
    fixed_commission: Decimal | null
    spread_commission: Decimal | null
  }

  export type Ib_commissionSumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    total_commission: Decimal | null
    total_trades: number | null
    total_lots: Decimal | null
    fixed_commission: Decimal | null
    spread_commission: Decimal | null
  }

  export type Ib_commissionMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    user_id: string | null
    total_commission: Decimal | null
    last_updated: Date | null
    created_at: Date | null
    updated_at: Date | null
    total_trades: number | null
    total_lots: Decimal | null
    fixed_commission: Decimal | null
    spread_commission: Decimal | null
  }

  export type Ib_commissionMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    user_id: string | null
    total_commission: Decimal | null
    last_updated: Date | null
    created_at: Date | null
    updated_at: Date | null
    total_trades: number | null
    total_lots: Decimal | null
    fixed_commission: Decimal | null
    spread_commission: Decimal | null
  }

  export type Ib_commissionCountAggregateOutputType = {
    id: number
    ib_request_id: number
    user_id: number
    total_commission: number
    last_updated: number
    created_at: number
    updated_at: number
    total_trades: number
    total_lots: number
    fixed_commission: number
    spread_commission: number
    _all: number
  }


  export type Ib_commissionAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
    total_commission?: true
    total_trades?: true
    total_lots?: true
    fixed_commission?: true
    spread_commission?: true
  }

  export type Ib_commissionSumAggregateInputType = {
    id?: true
    ib_request_id?: true
    total_commission?: true
    total_trades?: true
    total_lots?: true
    fixed_commission?: true
    spread_commission?: true
  }

  export type Ib_commissionMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    total_commission?: true
    last_updated?: true
    created_at?: true
    updated_at?: true
    total_trades?: true
    total_lots?: true
    fixed_commission?: true
    spread_commission?: true
  }

  export type Ib_commissionMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    total_commission?: true
    last_updated?: true
    created_at?: true
    updated_at?: true
    total_trades?: true
    total_lots?: true
    fixed_commission?: true
    spread_commission?: true
  }

  export type Ib_commissionCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    total_commission?: true
    last_updated?: true
    created_at?: true
    updated_at?: true
    total_trades?: true
    total_lots?: true
    fixed_commission?: true
    spread_commission?: true
    _all?: true
  }

  export type Ib_commissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_commission to aggregate.
     */
    where?: ib_commissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_commissions to fetch.
     */
    orderBy?: ib_commissionOrderByWithRelationInput | ib_commissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_commissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_commissions
    **/
    _count?: true | Ib_commissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_commissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_commissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_commissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_commissionMaxAggregateInputType
  }

  export type GetIb_commissionAggregateType<T extends Ib_commissionAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_commission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_commission[P]>
      : GetScalarType<T[P], AggregateIb_commission[P]>
  }




  export type ib_commissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_commissionWhereInput
    orderBy?: ib_commissionOrderByWithAggregationInput | ib_commissionOrderByWithAggregationInput[]
    by: Ib_commissionScalarFieldEnum[] | Ib_commissionScalarFieldEnum
    having?: ib_commissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_commissionCountAggregateInputType | true
    _avg?: Ib_commissionAvgAggregateInputType
    _sum?: Ib_commissionSumAggregateInputType
    _min?: Ib_commissionMinAggregateInputType
    _max?: Ib_commissionMaxAggregateInputType
  }

  export type Ib_commissionGroupByOutputType = {
    id: number
    ib_request_id: number
    user_id: string
    total_commission: Decimal | null
    last_updated: Date | null
    created_at: Date | null
    updated_at: Date | null
    total_trades: number | null
    total_lots: Decimal | null
    fixed_commission: Decimal | null
    spread_commission: Decimal | null
    _count: Ib_commissionCountAggregateOutputType | null
    _avg: Ib_commissionAvgAggregateOutputType | null
    _sum: Ib_commissionSumAggregateOutputType | null
    _min: Ib_commissionMinAggregateOutputType | null
    _max: Ib_commissionMaxAggregateOutputType | null
  }

  type GetIb_commissionGroupByPayload<T extends ib_commissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_commissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_commissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_commissionGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_commissionGroupByOutputType[P]>
        }
      >
    >


  export type ib_commissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    total_commission?: boolean
    last_updated?: boolean
    created_at?: boolean
    updated_at?: boolean
    total_trades?: boolean
    total_lots?: boolean
    fixed_commission?: boolean
    spread_commission?: boolean
  }, ExtArgs["result"]["ib_commission"]>

  export type ib_commissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    total_commission?: boolean
    last_updated?: boolean
    created_at?: boolean
    updated_at?: boolean
    total_trades?: boolean
    total_lots?: boolean
    fixed_commission?: boolean
    spread_commission?: boolean
  }, ExtArgs["result"]["ib_commission"]>

  export type ib_commissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    total_commission?: boolean
    last_updated?: boolean
    created_at?: boolean
    updated_at?: boolean
    total_trades?: boolean
    total_lots?: boolean
    fixed_commission?: boolean
    spread_commission?: boolean
  }, ExtArgs["result"]["ib_commission"]>

  export type ib_commissionSelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    total_commission?: boolean
    last_updated?: boolean
    created_at?: boolean
    updated_at?: boolean
    total_trades?: boolean
    total_lots?: boolean
    fixed_commission?: boolean
    spread_commission?: boolean
  }

  export type ib_commissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "user_id" | "total_commission" | "last_updated" | "created_at" | "updated_at" | "total_trades" | "total_lots" | "fixed_commission" | "spread_commission", ExtArgs["result"]["ib_commission"]>

  export type $ib_commissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_commission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number
      user_id: string
      total_commission: Prisma.Decimal | null
      last_updated: Date | null
      created_at: Date | null
      updated_at: Date | null
      total_trades: number | null
      total_lots: Prisma.Decimal | null
      fixed_commission: Prisma.Decimal | null
      spread_commission: Prisma.Decimal | null
    }, ExtArgs["result"]["ib_commission"]>
    composites: {}
  }

  type ib_commissionGetPayload<S extends boolean | null | undefined | ib_commissionDefaultArgs> = $Result.GetResult<Prisma.$ib_commissionPayload, S>

  type ib_commissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_commissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_commissionCountAggregateInputType | true
    }

  export interface ib_commissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_commission'], meta: { name: 'ib_commission' } }
    /**
     * Find zero or one Ib_commission that matches the filter.
     * @param {ib_commissionFindUniqueArgs} args - Arguments to find a Ib_commission
     * @example
     * // Get one Ib_commission
     * const ib_commission = await prisma.ib_commission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_commissionFindUniqueArgs>(args: SelectSubset<T, ib_commissionFindUniqueArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_commission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_commissionFindUniqueOrThrowArgs} args - Arguments to find a Ib_commission
     * @example
     * // Get one Ib_commission
     * const ib_commission = await prisma.ib_commission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_commissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_commissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_commission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_commissionFindFirstArgs} args - Arguments to find a Ib_commission
     * @example
     * // Get one Ib_commission
     * const ib_commission = await prisma.ib_commission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_commissionFindFirstArgs>(args?: SelectSubset<T, ib_commissionFindFirstArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_commission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_commissionFindFirstOrThrowArgs} args - Arguments to find a Ib_commission
     * @example
     * // Get one Ib_commission
     * const ib_commission = await prisma.ib_commission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_commissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_commissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_commissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_commissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_commissions
     * const ib_commissions = await prisma.ib_commission.findMany()
     * 
     * // Get first 10 Ib_commissions
     * const ib_commissions = await prisma.ib_commission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_commissionWithIdOnly = await prisma.ib_commission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_commissionFindManyArgs>(args?: SelectSubset<T, ib_commissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_commission.
     * @param {ib_commissionCreateArgs} args - Arguments to create a Ib_commission.
     * @example
     * // Create one Ib_commission
     * const Ib_commission = await prisma.ib_commission.create({
     *   data: {
     *     // ... data to create a Ib_commission
     *   }
     * })
     * 
     */
    create<T extends ib_commissionCreateArgs>(args: SelectSubset<T, ib_commissionCreateArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_commissions.
     * @param {ib_commissionCreateManyArgs} args - Arguments to create many Ib_commissions.
     * @example
     * // Create many Ib_commissions
     * const ib_commission = await prisma.ib_commission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_commissionCreateManyArgs>(args?: SelectSubset<T, ib_commissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_commissions and returns the data saved in the database.
     * @param {ib_commissionCreateManyAndReturnArgs} args - Arguments to create many Ib_commissions.
     * @example
     * // Create many Ib_commissions
     * const ib_commission = await prisma.ib_commission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_commissions and only return the `id`
     * const ib_commissionWithIdOnly = await prisma.ib_commission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_commissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_commissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_commission.
     * @param {ib_commissionDeleteArgs} args - Arguments to delete one Ib_commission.
     * @example
     * // Delete one Ib_commission
     * const Ib_commission = await prisma.ib_commission.delete({
     *   where: {
     *     // ... filter to delete one Ib_commission
     *   }
     * })
     * 
     */
    delete<T extends ib_commissionDeleteArgs>(args: SelectSubset<T, ib_commissionDeleteArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_commission.
     * @param {ib_commissionUpdateArgs} args - Arguments to update one Ib_commission.
     * @example
     * // Update one Ib_commission
     * const ib_commission = await prisma.ib_commission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_commissionUpdateArgs>(args: SelectSubset<T, ib_commissionUpdateArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_commissions.
     * @param {ib_commissionDeleteManyArgs} args - Arguments to filter Ib_commissions to delete.
     * @example
     * // Delete a few Ib_commissions
     * const { count } = await prisma.ib_commission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_commissionDeleteManyArgs>(args?: SelectSubset<T, ib_commissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_commissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_commissions
     * const ib_commission = await prisma.ib_commission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_commissionUpdateManyArgs>(args: SelectSubset<T, ib_commissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_commissions and returns the data updated in the database.
     * @param {ib_commissionUpdateManyAndReturnArgs} args - Arguments to update many Ib_commissions.
     * @example
     * // Update many Ib_commissions
     * const ib_commission = await prisma.ib_commission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_commissions and only return the `id`
     * const ib_commissionWithIdOnly = await prisma.ib_commission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_commissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_commissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_commission.
     * @param {ib_commissionUpsertArgs} args - Arguments to update or create a Ib_commission.
     * @example
     * // Update or create a Ib_commission
     * const ib_commission = await prisma.ib_commission.upsert({
     *   create: {
     *     // ... data to create a Ib_commission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_commission we want to update
     *   }
     * })
     */
    upsert<T extends ib_commissionUpsertArgs>(args: SelectSubset<T, ib_commissionUpsertArgs<ExtArgs>>): Prisma__ib_commissionClient<$Result.GetResult<Prisma.$ib_commissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_commissionCountArgs} args - Arguments to filter Ib_commissions to count.
     * @example
     * // Count the number of Ib_commissions
     * const count = await prisma.ib_commission.count({
     *   where: {
     *     // ... the filter for the Ib_commissions we want to count
     *   }
     * })
    **/
    count<T extends ib_commissionCountArgs>(
      args?: Subset<T, ib_commissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_commissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_commission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_commissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_commissionAggregateArgs>(args: Subset<T, Ib_commissionAggregateArgs>): Prisma.PrismaPromise<GetIb_commissionAggregateType<T>>

    /**
     * Group by Ib_commission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_commissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_commissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_commissionGroupByArgs['orderBy'] }
        : { orderBy?: ib_commissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_commissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_commissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_commission model
   */
  readonly fields: ib_commissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_commission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_commissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_commission model
   */
  interface ib_commissionFieldRefs {
    readonly id: FieldRef<"ib_commission", 'Int'>
    readonly ib_request_id: FieldRef<"ib_commission", 'Int'>
    readonly user_id: FieldRef<"ib_commission", 'String'>
    readonly total_commission: FieldRef<"ib_commission", 'Decimal'>
    readonly last_updated: FieldRef<"ib_commission", 'DateTime'>
    readonly created_at: FieldRef<"ib_commission", 'DateTime'>
    readonly updated_at: FieldRef<"ib_commission", 'DateTime'>
    readonly total_trades: FieldRef<"ib_commission", 'Int'>
    readonly total_lots: FieldRef<"ib_commission", 'Decimal'>
    readonly fixed_commission: FieldRef<"ib_commission", 'Decimal'>
    readonly spread_commission: FieldRef<"ib_commission", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ib_commission findUnique
   */
  export type ib_commissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * Filter, which ib_commission to fetch.
     */
    where: ib_commissionWhereUniqueInput
  }

  /**
   * ib_commission findUniqueOrThrow
   */
  export type ib_commissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * Filter, which ib_commission to fetch.
     */
    where: ib_commissionWhereUniqueInput
  }

  /**
   * ib_commission findFirst
   */
  export type ib_commissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * Filter, which ib_commission to fetch.
     */
    where?: ib_commissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_commissions to fetch.
     */
    orderBy?: ib_commissionOrderByWithRelationInput | ib_commissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_commissions.
     */
    cursor?: ib_commissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_commissions.
     */
    distinct?: Ib_commissionScalarFieldEnum | Ib_commissionScalarFieldEnum[]
  }

  /**
   * ib_commission findFirstOrThrow
   */
  export type ib_commissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * Filter, which ib_commission to fetch.
     */
    where?: ib_commissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_commissions to fetch.
     */
    orderBy?: ib_commissionOrderByWithRelationInput | ib_commissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_commissions.
     */
    cursor?: ib_commissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_commissions.
     */
    distinct?: Ib_commissionScalarFieldEnum | Ib_commissionScalarFieldEnum[]
  }

  /**
   * ib_commission findMany
   */
  export type ib_commissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * Filter, which ib_commissions to fetch.
     */
    where?: ib_commissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_commissions to fetch.
     */
    orderBy?: ib_commissionOrderByWithRelationInput | ib_commissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_commissions.
     */
    cursor?: ib_commissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_commissions.
     */
    skip?: number
    distinct?: Ib_commissionScalarFieldEnum | Ib_commissionScalarFieldEnum[]
  }

  /**
   * ib_commission create
   */
  export type ib_commissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_commission.
     */
    data: XOR<ib_commissionCreateInput, ib_commissionUncheckedCreateInput>
  }

  /**
   * ib_commission createMany
   */
  export type ib_commissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_commissions.
     */
    data: ib_commissionCreateManyInput | ib_commissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_commission createManyAndReturn
   */
  export type ib_commissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * The data used to create many ib_commissions.
     */
    data: ib_commissionCreateManyInput | ib_commissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_commission update
   */
  export type ib_commissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_commission.
     */
    data: XOR<ib_commissionUpdateInput, ib_commissionUncheckedUpdateInput>
    /**
     * Choose, which ib_commission to update.
     */
    where: ib_commissionWhereUniqueInput
  }

  /**
   * ib_commission updateMany
   */
  export type ib_commissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_commissions.
     */
    data: XOR<ib_commissionUpdateManyMutationInput, ib_commissionUncheckedUpdateManyInput>
    /**
     * Filter which ib_commissions to update
     */
    where?: ib_commissionWhereInput
    /**
     * Limit how many ib_commissions to update.
     */
    limit?: number
  }

  /**
   * ib_commission updateManyAndReturn
   */
  export type ib_commissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * The data used to update ib_commissions.
     */
    data: XOR<ib_commissionUpdateManyMutationInput, ib_commissionUncheckedUpdateManyInput>
    /**
     * Filter which ib_commissions to update
     */
    where?: ib_commissionWhereInput
    /**
     * Limit how many ib_commissions to update.
     */
    limit?: number
  }

  /**
   * ib_commission upsert
   */
  export type ib_commissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_commission to update in case it exists.
     */
    where: ib_commissionWhereUniqueInput
    /**
     * In case the ib_commission found by the `where` argument doesn't exist, create a new ib_commission with this data.
     */
    create: XOR<ib_commissionCreateInput, ib_commissionUncheckedCreateInput>
    /**
     * In case the ib_commission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_commissionUpdateInput, ib_commissionUncheckedUpdateInput>
  }

  /**
   * ib_commission delete
   */
  export type ib_commissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
    /**
     * Filter which ib_commission to delete.
     */
    where: ib_commissionWhereUniqueInput
  }

  /**
   * ib_commission deleteMany
   */
  export type ib_commissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_commissions to delete
     */
    where?: ib_commissionWhereInput
    /**
     * Limit how many ib_commissions to delete.
     */
    limit?: number
  }

  /**
   * ib_commission without action
   */
  export type ib_commissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_commission
     */
    select?: ib_commissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_commission
     */
    omit?: ib_commissionOmit<ExtArgs> | null
  }


  /**
   * Model ib_level_up_history
   */

  export type AggregateIb_level_up_history = {
    _count: Ib_level_up_historyCountAggregateOutputType | null
    _avg: Ib_level_up_historyAvgAggregateOutputType | null
    _sum: Ib_level_up_historySumAggregateOutputType | null
    _min: Ib_level_up_historyMinAggregateOutputType | null
    _max: Ib_level_up_historyMaxAggregateOutputType | null
  }

  export type Ib_level_up_historyAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    from_structure_id: number | null
    to_structure_id: number | null
    trading_volume_at_upgrade: Decimal | null
    active_clients_at_upgrade: number | null
  }

  export type Ib_level_up_historySumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    from_structure_id: number | null
    to_structure_id: number | null
    trading_volume_at_upgrade: Decimal | null
    active_clients_at_upgrade: number | null
  }

  export type Ib_level_up_historyMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    from_structure_id: number | null
    to_structure_id: number | null
    from_structure_name: string | null
    to_structure_name: string | null
    trading_volume_at_upgrade: Decimal | null
    active_clients_at_upgrade: number | null
    upgraded_at: Date | null
    created_at: Date | null
  }

  export type Ib_level_up_historyMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    from_structure_id: number | null
    to_structure_id: number | null
    from_structure_name: string | null
    to_structure_name: string | null
    trading_volume_at_upgrade: Decimal | null
    active_clients_at_upgrade: number | null
    upgraded_at: Date | null
    created_at: Date | null
  }

  export type Ib_level_up_historyCountAggregateOutputType = {
    id: number
    ib_request_id: number
    from_structure_id: number
    to_structure_id: number
    from_structure_name: number
    to_structure_name: number
    trading_volume_at_upgrade: number
    active_clients_at_upgrade: number
    upgraded_at: number
    created_at: number
    _all: number
  }


  export type Ib_level_up_historyAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
    from_structure_id?: true
    to_structure_id?: true
    trading_volume_at_upgrade?: true
    active_clients_at_upgrade?: true
  }

  export type Ib_level_up_historySumAggregateInputType = {
    id?: true
    ib_request_id?: true
    from_structure_id?: true
    to_structure_id?: true
    trading_volume_at_upgrade?: true
    active_clients_at_upgrade?: true
  }

  export type Ib_level_up_historyMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    from_structure_id?: true
    to_structure_id?: true
    from_structure_name?: true
    to_structure_name?: true
    trading_volume_at_upgrade?: true
    active_clients_at_upgrade?: true
    upgraded_at?: true
    created_at?: true
  }

  export type Ib_level_up_historyMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    from_structure_id?: true
    to_structure_id?: true
    from_structure_name?: true
    to_structure_name?: true
    trading_volume_at_upgrade?: true
    active_clients_at_upgrade?: true
    upgraded_at?: true
    created_at?: true
  }

  export type Ib_level_up_historyCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    from_structure_id?: true
    to_structure_id?: true
    from_structure_name?: true
    to_structure_name?: true
    trading_volume_at_upgrade?: true
    active_clients_at_upgrade?: true
    upgraded_at?: true
    created_at?: true
    _all?: true
  }

  export type Ib_level_up_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_level_up_history to aggregate.
     */
    where?: ib_level_up_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_level_up_histories to fetch.
     */
    orderBy?: ib_level_up_historyOrderByWithRelationInput | ib_level_up_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_level_up_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_level_up_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_level_up_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_level_up_histories
    **/
    _count?: true | Ib_level_up_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_level_up_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_level_up_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_level_up_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_level_up_historyMaxAggregateInputType
  }

  export type GetIb_level_up_historyAggregateType<T extends Ib_level_up_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_level_up_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_level_up_history[P]>
      : GetScalarType<T[P], AggregateIb_level_up_history[P]>
  }




  export type ib_level_up_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_level_up_historyWhereInput
    orderBy?: ib_level_up_historyOrderByWithAggregationInput | ib_level_up_historyOrderByWithAggregationInput[]
    by: Ib_level_up_historyScalarFieldEnum[] | Ib_level_up_historyScalarFieldEnum
    having?: ib_level_up_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_level_up_historyCountAggregateInputType | true
    _avg?: Ib_level_up_historyAvgAggregateInputType
    _sum?: Ib_level_up_historySumAggregateInputType
    _min?: Ib_level_up_historyMinAggregateInputType
    _max?: Ib_level_up_historyMaxAggregateInputType
  }

  export type Ib_level_up_historyGroupByOutputType = {
    id: number
    ib_request_id: number
    from_structure_id: number | null
    to_structure_id: number
    from_structure_name: string | null
    to_structure_name: string | null
    trading_volume_at_upgrade: Decimal | null
    active_clients_at_upgrade: number | null
    upgraded_at: Date | null
    created_at: Date | null
    _count: Ib_level_up_historyCountAggregateOutputType | null
    _avg: Ib_level_up_historyAvgAggregateOutputType | null
    _sum: Ib_level_up_historySumAggregateOutputType | null
    _min: Ib_level_up_historyMinAggregateOutputType | null
    _max: Ib_level_up_historyMaxAggregateOutputType | null
  }

  type GetIb_level_up_historyGroupByPayload<T extends ib_level_up_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_level_up_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_level_up_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_level_up_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_level_up_historyGroupByOutputType[P]>
        }
      >
    >


  export type ib_level_up_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    from_structure_id?: boolean
    to_structure_id?: boolean
    from_structure_name?: boolean
    to_structure_name?: boolean
    trading_volume_at_upgrade?: boolean
    active_clients_at_upgrade?: boolean
    upgraded_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_level_up_history"]>

  export type ib_level_up_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    from_structure_id?: boolean
    to_structure_id?: boolean
    from_structure_name?: boolean
    to_structure_name?: boolean
    trading_volume_at_upgrade?: boolean
    active_clients_at_upgrade?: boolean
    upgraded_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_level_up_history"]>

  export type ib_level_up_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    from_structure_id?: boolean
    to_structure_id?: boolean
    from_structure_name?: boolean
    to_structure_name?: boolean
    trading_volume_at_upgrade?: boolean
    active_clients_at_upgrade?: boolean
    upgraded_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_level_up_history"]>

  export type ib_level_up_historySelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    from_structure_id?: boolean
    to_structure_id?: boolean
    from_structure_name?: boolean
    to_structure_name?: boolean
    trading_volume_at_upgrade?: boolean
    active_clients_at_upgrade?: boolean
    upgraded_at?: boolean
    created_at?: boolean
  }

  export type ib_level_up_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "from_structure_id" | "to_structure_id" | "from_structure_name" | "to_structure_name" | "trading_volume_at_upgrade" | "active_clients_at_upgrade" | "upgraded_at" | "created_at", ExtArgs["result"]["ib_level_up_history"]>

  export type $ib_level_up_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_level_up_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number
      from_structure_id: number | null
      to_structure_id: number
      from_structure_name: string | null
      to_structure_name: string | null
      trading_volume_at_upgrade: Prisma.Decimal | null
      active_clients_at_upgrade: number | null
      upgraded_at: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["ib_level_up_history"]>
    composites: {}
  }

  type ib_level_up_historyGetPayload<S extends boolean | null | undefined | ib_level_up_historyDefaultArgs> = $Result.GetResult<Prisma.$ib_level_up_historyPayload, S>

  type ib_level_up_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_level_up_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_level_up_historyCountAggregateInputType | true
    }

  export interface ib_level_up_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_level_up_history'], meta: { name: 'ib_level_up_history' } }
    /**
     * Find zero or one Ib_level_up_history that matches the filter.
     * @param {ib_level_up_historyFindUniqueArgs} args - Arguments to find a Ib_level_up_history
     * @example
     * // Get one Ib_level_up_history
     * const ib_level_up_history = await prisma.ib_level_up_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_level_up_historyFindUniqueArgs>(args: SelectSubset<T, ib_level_up_historyFindUniqueArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_level_up_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_level_up_historyFindUniqueOrThrowArgs} args - Arguments to find a Ib_level_up_history
     * @example
     * // Get one Ib_level_up_history
     * const ib_level_up_history = await prisma.ib_level_up_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_level_up_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_level_up_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_level_up_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_level_up_historyFindFirstArgs} args - Arguments to find a Ib_level_up_history
     * @example
     * // Get one Ib_level_up_history
     * const ib_level_up_history = await prisma.ib_level_up_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_level_up_historyFindFirstArgs>(args?: SelectSubset<T, ib_level_up_historyFindFirstArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_level_up_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_level_up_historyFindFirstOrThrowArgs} args - Arguments to find a Ib_level_up_history
     * @example
     * // Get one Ib_level_up_history
     * const ib_level_up_history = await prisma.ib_level_up_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_level_up_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_level_up_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_level_up_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_level_up_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_level_up_histories
     * const ib_level_up_histories = await prisma.ib_level_up_history.findMany()
     * 
     * // Get first 10 Ib_level_up_histories
     * const ib_level_up_histories = await prisma.ib_level_up_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_level_up_historyWithIdOnly = await prisma.ib_level_up_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_level_up_historyFindManyArgs>(args?: SelectSubset<T, ib_level_up_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_level_up_history.
     * @param {ib_level_up_historyCreateArgs} args - Arguments to create a Ib_level_up_history.
     * @example
     * // Create one Ib_level_up_history
     * const Ib_level_up_history = await prisma.ib_level_up_history.create({
     *   data: {
     *     // ... data to create a Ib_level_up_history
     *   }
     * })
     * 
     */
    create<T extends ib_level_up_historyCreateArgs>(args: SelectSubset<T, ib_level_up_historyCreateArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_level_up_histories.
     * @param {ib_level_up_historyCreateManyArgs} args - Arguments to create many Ib_level_up_histories.
     * @example
     * // Create many Ib_level_up_histories
     * const ib_level_up_history = await prisma.ib_level_up_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_level_up_historyCreateManyArgs>(args?: SelectSubset<T, ib_level_up_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_level_up_histories and returns the data saved in the database.
     * @param {ib_level_up_historyCreateManyAndReturnArgs} args - Arguments to create many Ib_level_up_histories.
     * @example
     * // Create many Ib_level_up_histories
     * const ib_level_up_history = await prisma.ib_level_up_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_level_up_histories and only return the `id`
     * const ib_level_up_historyWithIdOnly = await prisma.ib_level_up_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_level_up_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_level_up_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_level_up_history.
     * @param {ib_level_up_historyDeleteArgs} args - Arguments to delete one Ib_level_up_history.
     * @example
     * // Delete one Ib_level_up_history
     * const Ib_level_up_history = await prisma.ib_level_up_history.delete({
     *   where: {
     *     // ... filter to delete one Ib_level_up_history
     *   }
     * })
     * 
     */
    delete<T extends ib_level_up_historyDeleteArgs>(args: SelectSubset<T, ib_level_up_historyDeleteArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_level_up_history.
     * @param {ib_level_up_historyUpdateArgs} args - Arguments to update one Ib_level_up_history.
     * @example
     * // Update one Ib_level_up_history
     * const ib_level_up_history = await prisma.ib_level_up_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_level_up_historyUpdateArgs>(args: SelectSubset<T, ib_level_up_historyUpdateArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_level_up_histories.
     * @param {ib_level_up_historyDeleteManyArgs} args - Arguments to filter Ib_level_up_histories to delete.
     * @example
     * // Delete a few Ib_level_up_histories
     * const { count } = await prisma.ib_level_up_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_level_up_historyDeleteManyArgs>(args?: SelectSubset<T, ib_level_up_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_level_up_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_level_up_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_level_up_histories
     * const ib_level_up_history = await prisma.ib_level_up_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_level_up_historyUpdateManyArgs>(args: SelectSubset<T, ib_level_up_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_level_up_histories and returns the data updated in the database.
     * @param {ib_level_up_historyUpdateManyAndReturnArgs} args - Arguments to update many Ib_level_up_histories.
     * @example
     * // Update many Ib_level_up_histories
     * const ib_level_up_history = await prisma.ib_level_up_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_level_up_histories and only return the `id`
     * const ib_level_up_historyWithIdOnly = await prisma.ib_level_up_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_level_up_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_level_up_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_level_up_history.
     * @param {ib_level_up_historyUpsertArgs} args - Arguments to update or create a Ib_level_up_history.
     * @example
     * // Update or create a Ib_level_up_history
     * const ib_level_up_history = await prisma.ib_level_up_history.upsert({
     *   create: {
     *     // ... data to create a Ib_level_up_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_level_up_history we want to update
     *   }
     * })
     */
    upsert<T extends ib_level_up_historyUpsertArgs>(args: SelectSubset<T, ib_level_up_historyUpsertArgs<ExtArgs>>): Prisma__ib_level_up_historyClient<$Result.GetResult<Prisma.$ib_level_up_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_level_up_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_level_up_historyCountArgs} args - Arguments to filter Ib_level_up_histories to count.
     * @example
     * // Count the number of Ib_level_up_histories
     * const count = await prisma.ib_level_up_history.count({
     *   where: {
     *     // ... the filter for the Ib_level_up_histories we want to count
     *   }
     * })
    **/
    count<T extends ib_level_up_historyCountArgs>(
      args?: Subset<T, ib_level_up_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_level_up_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_level_up_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_level_up_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_level_up_historyAggregateArgs>(args: Subset<T, Ib_level_up_historyAggregateArgs>): Prisma.PrismaPromise<GetIb_level_up_historyAggregateType<T>>

    /**
     * Group by Ib_level_up_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_level_up_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_level_up_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_level_up_historyGroupByArgs['orderBy'] }
        : { orderBy?: ib_level_up_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_level_up_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_level_up_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_level_up_history model
   */
  readonly fields: ib_level_up_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_level_up_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_level_up_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_level_up_history model
   */
  interface ib_level_up_historyFieldRefs {
    readonly id: FieldRef<"ib_level_up_history", 'Int'>
    readonly ib_request_id: FieldRef<"ib_level_up_history", 'Int'>
    readonly from_structure_id: FieldRef<"ib_level_up_history", 'Int'>
    readonly to_structure_id: FieldRef<"ib_level_up_history", 'Int'>
    readonly from_structure_name: FieldRef<"ib_level_up_history", 'String'>
    readonly to_structure_name: FieldRef<"ib_level_up_history", 'String'>
    readonly trading_volume_at_upgrade: FieldRef<"ib_level_up_history", 'Decimal'>
    readonly active_clients_at_upgrade: FieldRef<"ib_level_up_history", 'Int'>
    readonly upgraded_at: FieldRef<"ib_level_up_history", 'DateTime'>
    readonly created_at: FieldRef<"ib_level_up_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_level_up_history findUnique
   */
  export type ib_level_up_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_level_up_history to fetch.
     */
    where: ib_level_up_historyWhereUniqueInput
  }

  /**
   * ib_level_up_history findUniqueOrThrow
   */
  export type ib_level_up_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_level_up_history to fetch.
     */
    where: ib_level_up_historyWhereUniqueInput
  }

  /**
   * ib_level_up_history findFirst
   */
  export type ib_level_up_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_level_up_history to fetch.
     */
    where?: ib_level_up_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_level_up_histories to fetch.
     */
    orderBy?: ib_level_up_historyOrderByWithRelationInput | ib_level_up_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_level_up_histories.
     */
    cursor?: ib_level_up_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_level_up_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_level_up_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_level_up_histories.
     */
    distinct?: Ib_level_up_historyScalarFieldEnum | Ib_level_up_historyScalarFieldEnum[]
  }

  /**
   * ib_level_up_history findFirstOrThrow
   */
  export type ib_level_up_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_level_up_history to fetch.
     */
    where?: ib_level_up_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_level_up_histories to fetch.
     */
    orderBy?: ib_level_up_historyOrderByWithRelationInput | ib_level_up_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_level_up_histories.
     */
    cursor?: ib_level_up_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_level_up_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_level_up_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_level_up_histories.
     */
    distinct?: Ib_level_up_historyScalarFieldEnum | Ib_level_up_historyScalarFieldEnum[]
  }

  /**
   * ib_level_up_history findMany
   */
  export type ib_level_up_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * Filter, which ib_level_up_histories to fetch.
     */
    where?: ib_level_up_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_level_up_histories to fetch.
     */
    orderBy?: ib_level_up_historyOrderByWithRelationInput | ib_level_up_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_level_up_histories.
     */
    cursor?: ib_level_up_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_level_up_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_level_up_histories.
     */
    skip?: number
    distinct?: Ib_level_up_historyScalarFieldEnum | Ib_level_up_historyScalarFieldEnum[]
  }

  /**
   * ib_level_up_history create
   */
  export type ib_level_up_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_level_up_history.
     */
    data: XOR<ib_level_up_historyCreateInput, ib_level_up_historyUncheckedCreateInput>
  }

  /**
   * ib_level_up_history createMany
   */
  export type ib_level_up_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_level_up_histories.
     */
    data: ib_level_up_historyCreateManyInput | ib_level_up_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_level_up_history createManyAndReturn
   */
  export type ib_level_up_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * The data used to create many ib_level_up_histories.
     */
    data: ib_level_up_historyCreateManyInput | ib_level_up_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_level_up_history update
   */
  export type ib_level_up_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_level_up_history.
     */
    data: XOR<ib_level_up_historyUpdateInput, ib_level_up_historyUncheckedUpdateInput>
    /**
     * Choose, which ib_level_up_history to update.
     */
    where: ib_level_up_historyWhereUniqueInput
  }

  /**
   * ib_level_up_history updateMany
   */
  export type ib_level_up_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_level_up_histories.
     */
    data: XOR<ib_level_up_historyUpdateManyMutationInput, ib_level_up_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_level_up_histories to update
     */
    where?: ib_level_up_historyWhereInput
    /**
     * Limit how many ib_level_up_histories to update.
     */
    limit?: number
  }

  /**
   * ib_level_up_history updateManyAndReturn
   */
  export type ib_level_up_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * The data used to update ib_level_up_histories.
     */
    data: XOR<ib_level_up_historyUpdateManyMutationInput, ib_level_up_historyUncheckedUpdateManyInput>
    /**
     * Filter which ib_level_up_histories to update
     */
    where?: ib_level_up_historyWhereInput
    /**
     * Limit how many ib_level_up_histories to update.
     */
    limit?: number
  }

  /**
   * ib_level_up_history upsert
   */
  export type ib_level_up_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_level_up_history to update in case it exists.
     */
    where: ib_level_up_historyWhereUniqueInput
    /**
     * In case the ib_level_up_history found by the `where` argument doesn't exist, create a new ib_level_up_history with this data.
     */
    create: XOR<ib_level_up_historyCreateInput, ib_level_up_historyUncheckedCreateInput>
    /**
     * In case the ib_level_up_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_level_up_historyUpdateInput, ib_level_up_historyUncheckedUpdateInput>
  }

  /**
   * ib_level_up_history delete
   */
  export type ib_level_up_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
    /**
     * Filter which ib_level_up_history to delete.
     */
    where: ib_level_up_historyWhereUniqueInput
  }

  /**
   * ib_level_up_history deleteMany
   */
  export type ib_level_up_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_level_up_histories to delete
     */
    where?: ib_level_up_historyWhereInput
    /**
     * Limit how many ib_level_up_histories to delete.
     */
    limit?: number
  }

  /**
   * ib_level_up_history without action
   */
  export type ib_level_up_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_level_up_history
     */
    select?: ib_level_up_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_level_up_history
     */
    omit?: ib_level_up_historyOmit<ExtArgs> | null
  }


  /**
   * Model ib_referrals
   */

  export type AggregateIb_referrals = {
    _count: Ib_referralsCountAggregateOutputType | null
    _avg: Ib_referralsAvgAggregateOutputType | null
    _sum: Ib_referralsSumAggregateOutputType | null
    _min: Ib_referralsMinAggregateOutputType | null
    _max: Ib_referralsMaxAggregateOutputType | null
  }

  export type Ib_referralsAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
  }

  export type Ib_referralsSumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
  }

  export type Ib_referralsMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    user_id: string | null
    email: string | null
    referral_code: string | null
    source: string | null
    created_at: Date | null
  }

  export type Ib_referralsMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    user_id: string | null
    email: string | null
    referral_code: string | null
    source: string | null
    created_at: Date | null
  }

  export type Ib_referralsCountAggregateOutputType = {
    id: number
    ib_request_id: number
    user_id: number
    email: number
    referral_code: number
    source: number
    created_at: number
    _all: number
  }


  export type Ib_referralsAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
  }

  export type Ib_referralsSumAggregateInputType = {
    id?: true
    ib_request_id?: true
  }

  export type Ib_referralsMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    email?: true
    referral_code?: true
    source?: true
    created_at?: true
  }

  export type Ib_referralsMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    email?: true
    referral_code?: true
    source?: true
    created_at?: true
  }

  export type Ib_referralsCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    email?: true
    referral_code?: true
    source?: true
    created_at?: true
    _all?: true
  }

  export type Ib_referralsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_referrals to aggregate.
     */
    where?: ib_referralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_referrals to fetch.
     */
    orderBy?: ib_referralsOrderByWithRelationInput | ib_referralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_referralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_referrals
    **/
    _count?: true | Ib_referralsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_referralsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_referralsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_referralsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_referralsMaxAggregateInputType
  }

  export type GetIb_referralsAggregateType<T extends Ib_referralsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_referrals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_referrals[P]>
      : GetScalarType<T[P], AggregateIb_referrals[P]>
  }




  export type ib_referralsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_referralsWhereInput
    orderBy?: ib_referralsOrderByWithAggregationInput | ib_referralsOrderByWithAggregationInput[]
    by: Ib_referralsScalarFieldEnum[] | Ib_referralsScalarFieldEnum
    having?: ib_referralsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_referralsCountAggregateInputType | true
    _avg?: Ib_referralsAvgAggregateInputType
    _sum?: Ib_referralsSumAggregateInputType
    _min?: Ib_referralsMinAggregateInputType
    _max?: Ib_referralsMaxAggregateInputType
  }

  export type Ib_referralsGroupByOutputType = {
    id: number
    ib_request_id: number
    user_id: string | null
    email: string
    referral_code: string
    source: string | null
    created_at: Date | null
    _count: Ib_referralsCountAggregateOutputType | null
    _avg: Ib_referralsAvgAggregateOutputType | null
    _sum: Ib_referralsSumAggregateOutputType | null
    _min: Ib_referralsMinAggregateOutputType | null
    _max: Ib_referralsMaxAggregateOutputType | null
  }

  type GetIb_referralsGroupByPayload<T extends ib_referralsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_referralsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_referralsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_referralsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_referralsGroupByOutputType[P]>
        }
      >
    >


  export type ib_referralsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    email?: boolean
    referral_code?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_referrals"]>

  export type ib_referralsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    email?: boolean
    referral_code?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_referrals"]>

  export type ib_referralsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    email?: boolean
    referral_code?: boolean
    source?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_referrals"]>

  export type ib_referralsSelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    email?: boolean
    referral_code?: boolean
    source?: boolean
    created_at?: boolean
  }

  export type ib_referralsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "user_id" | "email" | "referral_code" | "source" | "created_at", ExtArgs["result"]["ib_referrals"]>

  export type $ib_referralsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_referrals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number
      user_id: string | null
      email: string
      referral_code: string
      source: string | null
      created_at: Date | null
    }, ExtArgs["result"]["ib_referrals"]>
    composites: {}
  }

  type ib_referralsGetPayload<S extends boolean | null | undefined | ib_referralsDefaultArgs> = $Result.GetResult<Prisma.$ib_referralsPayload, S>

  type ib_referralsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_referralsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_referralsCountAggregateInputType | true
    }

  export interface ib_referralsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_referrals'], meta: { name: 'ib_referrals' } }
    /**
     * Find zero or one Ib_referrals that matches the filter.
     * @param {ib_referralsFindUniqueArgs} args - Arguments to find a Ib_referrals
     * @example
     * // Get one Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_referralsFindUniqueArgs>(args: SelectSubset<T, ib_referralsFindUniqueArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_referrals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_referralsFindUniqueOrThrowArgs} args - Arguments to find a Ib_referrals
     * @example
     * // Get one Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_referralsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_referralsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_referralsFindFirstArgs} args - Arguments to find a Ib_referrals
     * @example
     * // Get one Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_referralsFindFirstArgs>(args?: SelectSubset<T, ib_referralsFindFirstArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_referrals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_referralsFindFirstOrThrowArgs} args - Arguments to find a Ib_referrals
     * @example
     * // Get one Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_referralsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_referralsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_referralsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.findMany()
     * 
     * // Get first 10 Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_referralsWithIdOnly = await prisma.ib_referrals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_referralsFindManyArgs>(args?: SelectSubset<T, ib_referralsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_referrals.
     * @param {ib_referralsCreateArgs} args - Arguments to create a Ib_referrals.
     * @example
     * // Create one Ib_referrals
     * const Ib_referrals = await prisma.ib_referrals.create({
     *   data: {
     *     // ... data to create a Ib_referrals
     *   }
     * })
     * 
     */
    create<T extends ib_referralsCreateArgs>(args: SelectSubset<T, ib_referralsCreateArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_referrals.
     * @param {ib_referralsCreateManyArgs} args - Arguments to create many Ib_referrals.
     * @example
     * // Create many Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_referralsCreateManyArgs>(args?: SelectSubset<T, ib_referralsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_referrals and returns the data saved in the database.
     * @param {ib_referralsCreateManyAndReturnArgs} args - Arguments to create many Ib_referrals.
     * @example
     * // Create many Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_referrals and only return the `id`
     * const ib_referralsWithIdOnly = await prisma.ib_referrals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_referralsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_referralsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_referrals.
     * @param {ib_referralsDeleteArgs} args - Arguments to delete one Ib_referrals.
     * @example
     * // Delete one Ib_referrals
     * const Ib_referrals = await prisma.ib_referrals.delete({
     *   where: {
     *     // ... filter to delete one Ib_referrals
     *   }
     * })
     * 
     */
    delete<T extends ib_referralsDeleteArgs>(args: SelectSubset<T, ib_referralsDeleteArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_referrals.
     * @param {ib_referralsUpdateArgs} args - Arguments to update one Ib_referrals.
     * @example
     * // Update one Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_referralsUpdateArgs>(args: SelectSubset<T, ib_referralsUpdateArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_referrals.
     * @param {ib_referralsDeleteManyArgs} args - Arguments to filter Ib_referrals to delete.
     * @example
     * // Delete a few Ib_referrals
     * const { count } = await prisma.ib_referrals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_referralsDeleteManyArgs>(args?: SelectSubset<T, ib_referralsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_referralsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_referralsUpdateManyArgs>(args: SelectSubset<T, ib_referralsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_referrals and returns the data updated in the database.
     * @param {ib_referralsUpdateManyAndReturnArgs} args - Arguments to update many Ib_referrals.
     * @example
     * // Update many Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_referrals and only return the `id`
     * const ib_referralsWithIdOnly = await prisma.ib_referrals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_referralsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_referralsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_referrals.
     * @param {ib_referralsUpsertArgs} args - Arguments to update or create a Ib_referrals.
     * @example
     * // Update or create a Ib_referrals
     * const ib_referrals = await prisma.ib_referrals.upsert({
     *   create: {
     *     // ... data to create a Ib_referrals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_referrals we want to update
     *   }
     * })
     */
    upsert<T extends ib_referralsUpsertArgs>(args: SelectSubset<T, ib_referralsUpsertArgs<ExtArgs>>): Prisma__ib_referralsClient<$Result.GetResult<Prisma.$ib_referralsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_referralsCountArgs} args - Arguments to filter Ib_referrals to count.
     * @example
     * // Count the number of Ib_referrals
     * const count = await prisma.ib_referrals.count({
     *   where: {
     *     // ... the filter for the Ib_referrals we want to count
     *   }
     * })
    **/
    count<T extends ib_referralsCountArgs>(
      args?: Subset<T, ib_referralsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_referralsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_referralsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_referralsAggregateArgs>(args: Subset<T, Ib_referralsAggregateArgs>): Prisma.PrismaPromise<GetIb_referralsAggregateType<T>>

    /**
     * Group by Ib_referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_referralsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_referralsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_referralsGroupByArgs['orderBy'] }
        : { orderBy?: ib_referralsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_referralsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_referralsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_referrals model
   */
  readonly fields: ib_referralsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_referrals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_referralsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_referrals model
   */
  interface ib_referralsFieldRefs {
    readonly id: FieldRef<"ib_referrals", 'Int'>
    readonly ib_request_id: FieldRef<"ib_referrals", 'Int'>
    readonly user_id: FieldRef<"ib_referrals", 'String'>
    readonly email: FieldRef<"ib_referrals", 'String'>
    readonly referral_code: FieldRef<"ib_referrals", 'String'>
    readonly source: FieldRef<"ib_referrals", 'String'>
    readonly created_at: FieldRef<"ib_referrals", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_referrals findUnique
   */
  export type ib_referralsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * Filter, which ib_referrals to fetch.
     */
    where: ib_referralsWhereUniqueInput
  }

  /**
   * ib_referrals findUniqueOrThrow
   */
  export type ib_referralsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * Filter, which ib_referrals to fetch.
     */
    where: ib_referralsWhereUniqueInput
  }

  /**
   * ib_referrals findFirst
   */
  export type ib_referralsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * Filter, which ib_referrals to fetch.
     */
    where?: ib_referralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_referrals to fetch.
     */
    orderBy?: ib_referralsOrderByWithRelationInput | ib_referralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_referrals.
     */
    cursor?: ib_referralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_referrals.
     */
    distinct?: Ib_referralsScalarFieldEnum | Ib_referralsScalarFieldEnum[]
  }

  /**
   * ib_referrals findFirstOrThrow
   */
  export type ib_referralsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * Filter, which ib_referrals to fetch.
     */
    where?: ib_referralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_referrals to fetch.
     */
    orderBy?: ib_referralsOrderByWithRelationInput | ib_referralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_referrals.
     */
    cursor?: ib_referralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_referrals.
     */
    distinct?: Ib_referralsScalarFieldEnum | Ib_referralsScalarFieldEnum[]
  }

  /**
   * ib_referrals findMany
   */
  export type ib_referralsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * Filter, which ib_referrals to fetch.
     */
    where?: ib_referralsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_referrals to fetch.
     */
    orderBy?: ib_referralsOrderByWithRelationInput | ib_referralsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_referrals.
     */
    cursor?: ib_referralsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_referrals.
     */
    skip?: number
    distinct?: Ib_referralsScalarFieldEnum | Ib_referralsScalarFieldEnum[]
  }

  /**
   * ib_referrals create
   */
  export type ib_referralsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_referrals.
     */
    data: XOR<ib_referralsCreateInput, ib_referralsUncheckedCreateInput>
  }

  /**
   * ib_referrals createMany
   */
  export type ib_referralsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_referrals.
     */
    data: ib_referralsCreateManyInput | ib_referralsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_referrals createManyAndReturn
   */
  export type ib_referralsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_referrals.
     */
    data: ib_referralsCreateManyInput | ib_referralsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_referrals update
   */
  export type ib_referralsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_referrals.
     */
    data: XOR<ib_referralsUpdateInput, ib_referralsUncheckedUpdateInput>
    /**
     * Choose, which ib_referrals to update.
     */
    where: ib_referralsWhereUniqueInput
  }

  /**
   * ib_referrals updateMany
   */
  export type ib_referralsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_referrals.
     */
    data: XOR<ib_referralsUpdateManyMutationInput, ib_referralsUncheckedUpdateManyInput>
    /**
     * Filter which ib_referrals to update
     */
    where?: ib_referralsWhereInput
    /**
     * Limit how many ib_referrals to update.
     */
    limit?: number
  }

  /**
   * ib_referrals updateManyAndReturn
   */
  export type ib_referralsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * The data used to update ib_referrals.
     */
    data: XOR<ib_referralsUpdateManyMutationInput, ib_referralsUncheckedUpdateManyInput>
    /**
     * Filter which ib_referrals to update
     */
    where?: ib_referralsWhereInput
    /**
     * Limit how many ib_referrals to update.
     */
    limit?: number
  }

  /**
   * ib_referrals upsert
   */
  export type ib_referralsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_referrals to update in case it exists.
     */
    where: ib_referralsWhereUniqueInput
    /**
     * In case the ib_referrals found by the `where` argument doesn't exist, create a new ib_referrals with this data.
     */
    create: XOR<ib_referralsCreateInput, ib_referralsUncheckedCreateInput>
    /**
     * In case the ib_referrals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_referralsUpdateInput, ib_referralsUncheckedUpdateInput>
  }

  /**
   * ib_referrals delete
   */
  export type ib_referralsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
    /**
     * Filter which ib_referrals to delete.
     */
    where: ib_referralsWhereUniqueInput
  }

  /**
   * ib_referrals deleteMany
   */
  export type ib_referralsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_referrals to delete
     */
    where?: ib_referralsWhereInput
    /**
     * Limit how many ib_referrals to delete.
     */
    limit?: number
  }

  /**
   * ib_referrals without action
   */
  export type ib_referralsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_referrals
     */
    select?: ib_referralsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_referrals
     */
    omit?: ib_referralsOmit<ExtArgs> | null
  }


  /**
   * Model ib_reward_claims
   */

  export type AggregateIb_reward_claims = {
    _count: Ib_reward_claimsCountAggregateOutputType | null
    _avg: Ib_reward_claimsAvgAggregateOutputType | null
    _sum: Ib_reward_claimsSumAggregateOutputType | null
    _min: Ib_reward_claimsMinAggregateOutputType | null
    _max: Ib_reward_claimsMaxAggregateOutputType | null
  }

  export type Ib_reward_claimsAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    reward_id: number | null
    total_volume_mln: Decimal | null
  }

  export type Ib_reward_claimsSumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    reward_id: number | null
    total_volume_mln: Decimal | null
  }

  export type Ib_reward_claimsMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    user_id: string | null
    reward_id: number | null
    reward_value: string | null
    reward_description: string | null
    reward_type: string | null
    claimant_name: string | null
    claimant_phone: string | null
    claimant_email: string | null
    claimant_address_street: string | null
    claimant_address_city: string | null
    claimant_address_state: string | null
    claimant_address_country: string | null
    claimant_address_postal_code: string | null
    status: string | null
    total_volume_mln: Decimal | null
    admin_notes: string | null
    claimed_at: Date | null
    updated_at: Date | null
    created_at: Date | null
  }

  export type Ib_reward_claimsMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    user_id: string | null
    reward_id: number | null
    reward_value: string | null
    reward_description: string | null
    reward_type: string | null
    claimant_name: string | null
    claimant_phone: string | null
    claimant_email: string | null
    claimant_address_street: string | null
    claimant_address_city: string | null
    claimant_address_state: string | null
    claimant_address_country: string | null
    claimant_address_postal_code: string | null
    status: string | null
    total_volume_mln: Decimal | null
    admin_notes: string | null
    claimed_at: Date | null
    updated_at: Date | null
    created_at: Date | null
  }

  export type Ib_reward_claimsCountAggregateOutputType = {
    id: number
    ib_request_id: number
    user_id: number
    reward_id: number
    reward_value: number
    reward_description: number
    reward_type: number
    claimant_name: number
    claimant_phone: number
    claimant_email: number
    claimant_address_street: number
    claimant_address_city: number
    claimant_address_state: number
    claimant_address_country: number
    claimant_address_postal_code: number
    status: number
    total_volume_mln: number
    admin_notes: number
    claimed_at: number
    updated_at: number
    created_at: number
    _all: number
  }


  export type Ib_reward_claimsAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
    reward_id?: true
    total_volume_mln?: true
  }

  export type Ib_reward_claimsSumAggregateInputType = {
    id?: true
    ib_request_id?: true
    reward_id?: true
    total_volume_mln?: true
  }

  export type Ib_reward_claimsMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    reward_id?: true
    reward_value?: true
    reward_description?: true
    reward_type?: true
    claimant_name?: true
    claimant_phone?: true
    claimant_email?: true
    claimant_address_street?: true
    claimant_address_city?: true
    claimant_address_state?: true
    claimant_address_country?: true
    claimant_address_postal_code?: true
    status?: true
    total_volume_mln?: true
    admin_notes?: true
    claimed_at?: true
    updated_at?: true
    created_at?: true
  }

  export type Ib_reward_claimsMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    reward_id?: true
    reward_value?: true
    reward_description?: true
    reward_type?: true
    claimant_name?: true
    claimant_phone?: true
    claimant_email?: true
    claimant_address_street?: true
    claimant_address_city?: true
    claimant_address_state?: true
    claimant_address_country?: true
    claimant_address_postal_code?: true
    status?: true
    total_volume_mln?: true
    admin_notes?: true
    claimed_at?: true
    updated_at?: true
    created_at?: true
  }

  export type Ib_reward_claimsCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    user_id?: true
    reward_id?: true
    reward_value?: true
    reward_description?: true
    reward_type?: true
    claimant_name?: true
    claimant_phone?: true
    claimant_email?: true
    claimant_address_street?: true
    claimant_address_city?: true
    claimant_address_state?: true
    claimant_address_country?: true
    claimant_address_postal_code?: true
    status?: true
    total_volume_mln?: true
    admin_notes?: true
    claimed_at?: true
    updated_at?: true
    created_at?: true
    _all?: true
  }

  export type Ib_reward_claimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_reward_claims to aggregate.
     */
    where?: ib_reward_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_reward_claims to fetch.
     */
    orderBy?: ib_reward_claimsOrderByWithRelationInput | ib_reward_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_reward_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_reward_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_reward_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_reward_claims
    **/
    _count?: true | Ib_reward_claimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_reward_claimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_reward_claimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_reward_claimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_reward_claimsMaxAggregateInputType
  }

  export type GetIb_reward_claimsAggregateType<T extends Ib_reward_claimsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_reward_claims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_reward_claims[P]>
      : GetScalarType<T[P], AggregateIb_reward_claims[P]>
  }




  export type ib_reward_claimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_reward_claimsWhereInput
    orderBy?: ib_reward_claimsOrderByWithAggregationInput | ib_reward_claimsOrderByWithAggregationInput[]
    by: Ib_reward_claimsScalarFieldEnum[] | Ib_reward_claimsScalarFieldEnum
    having?: ib_reward_claimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_reward_claimsCountAggregateInputType | true
    _avg?: Ib_reward_claimsAvgAggregateInputType
    _sum?: Ib_reward_claimsSumAggregateInputType
    _min?: Ib_reward_claimsMinAggregateInputType
    _max?: Ib_reward_claimsMaxAggregateInputType
  }

  export type Ib_reward_claimsGroupByOutputType = {
    id: number
    ib_request_id: number
    user_id: string
    reward_id: number
    reward_value: string
    reward_description: string
    reward_type: string
    claimant_name: string
    claimant_phone: string
    claimant_email: string
    claimant_address_street: string | null
    claimant_address_city: string | null
    claimant_address_state: string | null
    claimant_address_country: string | null
    claimant_address_postal_code: string | null
    status: string
    total_volume_mln: Decimal
    admin_notes: string | null
    claimed_at: Date | null
    updated_at: Date | null
    created_at: Date | null
    _count: Ib_reward_claimsCountAggregateOutputType | null
    _avg: Ib_reward_claimsAvgAggregateOutputType | null
    _sum: Ib_reward_claimsSumAggregateOutputType | null
    _min: Ib_reward_claimsMinAggregateOutputType | null
    _max: Ib_reward_claimsMaxAggregateOutputType | null
  }

  type GetIb_reward_claimsGroupByPayload<T extends ib_reward_claimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_reward_claimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_reward_claimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_reward_claimsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_reward_claimsGroupByOutputType[P]>
        }
      >
    >


  export type ib_reward_claimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    reward_value?: boolean
    reward_description?: boolean
    reward_type?: boolean
    claimant_name?: boolean
    claimant_phone?: boolean
    claimant_email?: boolean
    claimant_address_street?: boolean
    claimant_address_city?: boolean
    claimant_address_state?: boolean
    claimant_address_country?: boolean
    claimant_address_postal_code?: boolean
    status?: boolean
    total_volume_mln?: boolean
    admin_notes?: boolean
    claimed_at?: boolean
    updated_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_reward_claims"]>

  export type ib_reward_claimsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    reward_value?: boolean
    reward_description?: boolean
    reward_type?: boolean
    claimant_name?: boolean
    claimant_phone?: boolean
    claimant_email?: boolean
    claimant_address_street?: boolean
    claimant_address_city?: boolean
    claimant_address_state?: boolean
    claimant_address_country?: boolean
    claimant_address_postal_code?: boolean
    status?: boolean
    total_volume_mln?: boolean
    admin_notes?: boolean
    claimed_at?: boolean
    updated_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_reward_claims"]>

  export type ib_reward_claimsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    reward_value?: boolean
    reward_description?: boolean
    reward_type?: boolean
    claimant_name?: boolean
    claimant_phone?: boolean
    claimant_email?: boolean
    claimant_address_street?: boolean
    claimant_address_city?: boolean
    claimant_address_state?: boolean
    claimant_address_country?: boolean
    claimant_address_postal_code?: boolean
    status?: boolean
    total_volume_mln?: boolean
    admin_notes?: boolean
    claimed_at?: boolean
    updated_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ib_reward_claims"]>

  export type ib_reward_claimsSelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    user_id?: boolean
    reward_id?: boolean
    reward_value?: boolean
    reward_description?: boolean
    reward_type?: boolean
    claimant_name?: boolean
    claimant_phone?: boolean
    claimant_email?: boolean
    claimant_address_street?: boolean
    claimant_address_city?: boolean
    claimant_address_state?: boolean
    claimant_address_country?: boolean
    claimant_address_postal_code?: boolean
    status?: boolean
    total_volume_mln?: boolean
    admin_notes?: boolean
    claimed_at?: boolean
    updated_at?: boolean
    created_at?: boolean
  }

  export type ib_reward_claimsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "user_id" | "reward_id" | "reward_value" | "reward_description" | "reward_type" | "claimant_name" | "claimant_phone" | "claimant_email" | "claimant_address_street" | "claimant_address_city" | "claimant_address_state" | "claimant_address_country" | "claimant_address_postal_code" | "status" | "total_volume_mln" | "admin_notes" | "claimed_at" | "updated_at" | "created_at", ExtArgs["result"]["ib_reward_claims"]>

  export type $ib_reward_claimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_reward_claims"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number
      user_id: string
      reward_id: number
      reward_value: string
      reward_description: string
      reward_type: string
      claimant_name: string
      claimant_phone: string
      claimant_email: string
      claimant_address_street: string | null
      claimant_address_city: string | null
      claimant_address_state: string | null
      claimant_address_country: string | null
      claimant_address_postal_code: string | null
      status: string
      total_volume_mln: Prisma.Decimal
      admin_notes: string | null
      claimed_at: Date | null
      updated_at: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["ib_reward_claims"]>
    composites: {}
  }

  type ib_reward_claimsGetPayload<S extends boolean | null | undefined | ib_reward_claimsDefaultArgs> = $Result.GetResult<Prisma.$ib_reward_claimsPayload, S>

  type ib_reward_claimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_reward_claimsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_reward_claimsCountAggregateInputType | true
    }

  export interface ib_reward_claimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_reward_claims'], meta: { name: 'ib_reward_claims' } }
    /**
     * Find zero or one Ib_reward_claims that matches the filter.
     * @param {ib_reward_claimsFindUniqueArgs} args - Arguments to find a Ib_reward_claims
     * @example
     * // Get one Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_reward_claimsFindUniqueArgs>(args: SelectSubset<T, ib_reward_claimsFindUniqueArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_reward_claims that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_reward_claimsFindUniqueOrThrowArgs} args - Arguments to find a Ib_reward_claims
     * @example
     * // Get one Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_reward_claimsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_reward_claimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_reward_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_reward_claimsFindFirstArgs} args - Arguments to find a Ib_reward_claims
     * @example
     * // Get one Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_reward_claimsFindFirstArgs>(args?: SelectSubset<T, ib_reward_claimsFindFirstArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_reward_claims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_reward_claimsFindFirstOrThrowArgs} args - Arguments to find a Ib_reward_claims
     * @example
     * // Get one Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_reward_claimsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_reward_claimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_reward_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_reward_claimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.findMany()
     * 
     * // Get first 10 Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_reward_claimsWithIdOnly = await prisma.ib_reward_claims.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_reward_claimsFindManyArgs>(args?: SelectSubset<T, ib_reward_claimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_reward_claims.
     * @param {ib_reward_claimsCreateArgs} args - Arguments to create a Ib_reward_claims.
     * @example
     * // Create one Ib_reward_claims
     * const Ib_reward_claims = await prisma.ib_reward_claims.create({
     *   data: {
     *     // ... data to create a Ib_reward_claims
     *   }
     * })
     * 
     */
    create<T extends ib_reward_claimsCreateArgs>(args: SelectSubset<T, ib_reward_claimsCreateArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_reward_claims.
     * @param {ib_reward_claimsCreateManyArgs} args - Arguments to create many Ib_reward_claims.
     * @example
     * // Create many Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_reward_claimsCreateManyArgs>(args?: SelectSubset<T, ib_reward_claimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_reward_claims and returns the data saved in the database.
     * @param {ib_reward_claimsCreateManyAndReturnArgs} args - Arguments to create many Ib_reward_claims.
     * @example
     * // Create many Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_reward_claims and only return the `id`
     * const ib_reward_claimsWithIdOnly = await prisma.ib_reward_claims.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_reward_claimsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_reward_claimsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_reward_claims.
     * @param {ib_reward_claimsDeleteArgs} args - Arguments to delete one Ib_reward_claims.
     * @example
     * // Delete one Ib_reward_claims
     * const Ib_reward_claims = await prisma.ib_reward_claims.delete({
     *   where: {
     *     // ... filter to delete one Ib_reward_claims
     *   }
     * })
     * 
     */
    delete<T extends ib_reward_claimsDeleteArgs>(args: SelectSubset<T, ib_reward_claimsDeleteArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_reward_claims.
     * @param {ib_reward_claimsUpdateArgs} args - Arguments to update one Ib_reward_claims.
     * @example
     * // Update one Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_reward_claimsUpdateArgs>(args: SelectSubset<T, ib_reward_claimsUpdateArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_reward_claims.
     * @param {ib_reward_claimsDeleteManyArgs} args - Arguments to filter Ib_reward_claims to delete.
     * @example
     * // Delete a few Ib_reward_claims
     * const { count } = await prisma.ib_reward_claims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_reward_claimsDeleteManyArgs>(args?: SelectSubset<T, ib_reward_claimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_reward_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_reward_claimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_reward_claimsUpdateManyArgs>(args: SelectSubset<T, ib_reward_claimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_reward_claims and returns the data updated in the database.
     * @param {ib_reward_claimsUpdateManyAndReturnArgs} args - Arguments to update many Ib_reward_claims.
     * @example
     * // Update many Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_reward_claims and only return the `id`
     * const ib_reward_claimsWithIdOnly = await prisma.ib_reward_claims.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_reward_claimsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_reward_claimsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_reward_claims.
     * @param {ib_reward_claimsUpsertArgs} args - Arguments to update or create a Ib_reward_claims.
     * @example
     * // Update or create a Ib_reward_claims
     * const ib_reward_claims = await prisma.ib_reward_claims.upsert({
     *   create: {
     *     // ... data to create a Ib_reward_claims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_reward_claims we want to update
     *   }
     * })
     */
    upsert<T extends ib_reward_claimsUpsertArgs>(args: SelectSubset<T, ib_reward_claimsUpsertArgs<ExtArgs>>): Prisma__ib_reward_claimsClient<$Result.GetResult<Prisma.$ib_reward_claimsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_reward_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_reward_claimsCountArgs} args - Arguments to filter Ib_reward_claims to count.
     * @example
     * // Count the number of Ib_reward_claims
     * const count = await prisma.ib_reward_claims.count({
     *   where: {
     *     // ... the filter for the Ib_reward_claims we want to count
     *   }
     * })
    **/
    count<T extends ib_reward_claimsCountArgs>(
      args?: Subset<T, ib_reward_claimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_reward_claimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_reward_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_reward_claimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_reward_claimsAggregateArgs>(args: Subset<T, Ib_reward_claimsAggregateArgs>): Prisma.PrismaPromise<GetIb_reward_claimsAggregateType<T>>

    /**
     * Group by Ib_reward_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_reward_claimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_reward_claimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_reward_claimsGroupByArgs['orderBy'] }
        : { orderBy?: ib_reward_claimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_reward_claimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_reward_claimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_reward_claims model
   */
  readonly fields: ib_reward_claimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_reward_claims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_reward_claimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_reward_claims model
   */
  interface ib_reward_claimsFieldRefs {
    readonly id: FieldRef<"ib_reward_claims", 'Int'>
    readonly ib_request_id: FieldRef<"ib_reward_claims", 'Int'>
    readonly user_id: FieldRef<"ib_reward_claims", 'String'>
    readonly reward_id: FieldRef<"ib_reward_claims", 'Int'>
    readonly reward_value: FieldRef<"ib_reward_claims", 'String'>
    readonly reward_description: FieldRef<"ib_reward_claims", 'String'>
    readonly reward_type: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_name: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_phone: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_email: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_address_street: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_address_city: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_address_state: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_address_country: FieldRef<"ib_reward_claims", 'String'>
    readonly claimant_address_postal_code: FieldRef<"ib_reward_claims", 'String'>
    readonly status: FieldRef<"ib_reward_claims", 'String'>
    readonly total_volume_mln: FieldRef<"ib_reward_claims", 'Decimal'>
    readonly admin_notes: FieldRef<"ib_reward_claims", 'String'>
    readonly claimed_at: FieldRef<"ib_reward_claims", 'DateTime'>
    readonly updated_at: FieldRef<"ib_reward_claims", 'DateTime'>
    readonly created_at: FieldRef<"ib_reward_claims", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_reward_claims findUnique
   */
  export type ib_reward_claimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * Filter, which ib_reward_claims to fetch.
     */
    where: ib_reward_claimsWhereUniqueInput
  }

  /**
   * ib_reward_claims findUniqueOrThrow
   */
  export type ib_reward_claimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * Filter, which ib_reward_claims to fetch.
     */
    where: ib_reward_claimsWhereUniqueInput
  }

  /**
   * ib_reward_claims findFirst
   */
  export type ib_reward_claimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * Filter, which ib_reward_claims to fetch.
     */
    where?: ib_reward_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_reward_claims to fetch.
     */
    orderBy?: ib_reward_claimsOrderByWithRelationInput | ib_reward_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_reward_claims.
     */
    cursor?: ib_reward_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_reward_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_reward_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_reward_claims.
     */
    distinct?: Ib_reward_claimsScalarFieldEnum | Ib_reward_claimsScalarFieldEnum[]
  }

  /**
   * ib_reward_claims findFirstOrThrow
   */
  export type ib_reward_claimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * Filter, which ib_reward_claims to fetch.
     */
    where?: ib_reward_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_reward_claims to fetch.
     */
    orderBy?: ib_reward_claimsOrderByWithRelationInput | ib_reward_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_reward_claims.
     */
    cursor?: ib_reward_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_reward_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_reward_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_reward_claims.
     */
    distinct?: Ib_reward_claimsScalarFieldEnum | Ib_reward_claimsScalarFieldEnum[]
  }

  /**
   * ib_reward_claims findMany
   */
  export type ib_reward_claimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * Filter, which ib_reward_claims to fetch.
     */
    where?: ib_reward_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_reward_claims to fetch.
     */
    orderBy?: ib_reward_claimsOrderByWithRelationInput | ib_reward_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_reward_claims.
     */
    cursor?: ib_reward_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_reward_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_reward_claims.
     */
    skip?: number
    distinct?: Ib_reward_claimsScalarFieldEnum | Ib_reward_claimsScalarFieldEnum[]
  }

  /**
   * ib_reward_claims create
   */
  export type ib_reward_claimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_reward_claims.
     */
    data: XOR<ib_reward_claimsCreateInput, ib_reward_claimsUncheckedCreateInput>
  }

  /**
   * ib_reward_claims createMany
   */
  export type ib_reward_claimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_reward_claims.
     */
    data: ib_reward_claimsCreateManyInput | ib_reward_claimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_reward_claims createManyAndReturn
   */
  export type ib_reward_claimsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_reward_claims.
     */
    data: ib_reward_claimsCreateManyInput | ib_reward_claimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_reward_claims update
   */
  export type ib_reward_claimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_reward_claims.
     */
    data: XOR<ib_reward_claimsUpdateInput, ib_reward_claimsUncheckedUpdateInput>
    /**
     * Choose, which ib_reward_claims to update.
     */
    where: ib_reward_claimsWhereUniqueInput
  }

  /**
   * ib_reward_claims updateMany
   */
  export type ib_reward_claimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_reward_claims.
     */
    data: XOR<ib_reward_claimsUpdateManyMutationInput, ib_reward_claimsUncheckedUpdateManyInput>
    /**
     * Filter which ib_reward_claims to update
     */
    where?: ib_reward_claimsWhereInput
    /**
     * Limit how many ib_reward_claims to update.
     */
    limit?: number
  }

  /**
   * ib_reward_claims updateManyAndReturn
   */
  export type ib_reward_claimsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * The data used to update ib_reward_claims.
     */
    data: XOR<ib_reward_claimsUpdateManyMutationInput, ib_reward_claimsUncheckedUpdateManyInput>
    /**
     * Filter which ib_reward_claims to update
     */
    where?: ib_reward_claimsWhereInput
    /**
     * Limit how many ib_reward_claims to update.
     */
    limit?: number
  }

  /**
   * ib_reward_claims upsert
   */
  export type ib_reward_claimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_reward_claims to update in case it exists.
     */
    where: ib_reward_claimsWhereUniqueInput
    /**
     * In case the ib_reward_claims found by the `where` argument doesn't exist, create a new ib_reward_claims with this data.
     */
    create: XOR<ib_reward_claimsCreateInput, ib_reward_claimsUncheckedCreateInput>
    /**
     * In case the ib_reward_claims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_reward_claimsUpdateInput, ib_reward_claimsUncheckedUpdateInput>
  }

  /**
   * ib_reward_claims delete
   */
  export type ib_reward_claimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
    /**
     * Filter which ib_reward_claims to delete.
     */
    where: ib_reward_claimsWhereUniqueInput
  }

  /**
   * ib_reward_claims deleteMany
   */
  export type ib_reward_claimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_reward_claims to delete
     */
    where?: ib_reward_claimsWhereInput
    /**
     * Limit how many ib_reward_claims to delete.
     */
    limit?: number
  }

  /**
   * ib_reward_claims without action
   */
  export type ib_reward_claimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_reward_claims
     */
    select?: ib_reward_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_reward_claims
     */
    omit?: ib_reward_claimsOmit<ExtArgs> | null
  }


  /**
   * Model ib_withdrawal_requests
   */

  export type AggregateIb_withdrawal_requests = {
    _count: Ib_withdrawal_requestsCountAggregateOutputType | null
    _avg: Ib_withdrawal_requestsAvgAggregateOutputType | null
    _sum: Ib_withdrawal_requestsSumAggregateOutputType | null
    _min: Ib_withdrawal_requestsMinAggregateOutputType | null
    _max: Ib_withdrawal_requestsMaxAggregateOutputType | null
  }

  export type Ib_withdrawal_requestsAvgAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    amount: Decimal | null
  }

  export type Ib_withdrawal_requestsSumAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    amount: Decimal | null
  }

  export type Ib_withdrawal_requestsMinAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    amount: Decimal | null
    method: string | null
    account_details: string | null
    status: string | null
    created_at: Date | null
    transaction_id: string | null
    updated_at: Date | null
  }

  export type Ib_withdrawal_requestsMaxAggregateOutputType = {
    id: number | null
    ib_request_id: number | null
    amount: Decimal | null
    method: string | null
    account_details: string | null
    status: string | null
    created_at: Date | null
    transaction_id: string | null
    updated_at: Date | null
  }

  export type Ib_withdrawal_requestsCountAggregateOutputType = {
    id: number
    ib_request_id: number
    amount: number
    method: number
    account_details: number
    status: number
    created_at: number
    transaction_id: number
    updated_at: number
    _all: number
  }


  export type Ib_withdrawal_requestsAvgAggregateInputType = {
    id?: true
    ib_request_id?: true
    amount?: true
  }

  export type Ib_withdrawal_requestsSumAggregateInputType = {
    id?: true
    ib_request_id?: true
    amount?: true
  }

  export type Ib_withdrawal_requestsMinAggregateInputType = {
    id?: true
    ib_request_id?: true
    amount?: true
    method?: true
    account_details?: true
    status?: true
    created_at?: true
    transaction_id?: true
    updated_at?: true
  }

  export type Ib_withdrawal_requestsMaxAggregateInputType = {
    id?: true
    ib_request_id?: true
    amount?: true
    method?: true
    account_details?: true
    status?: true
    created_at?: true
    transaction_id?: true
    updated_at?: true
  }

  export type Ib_withdrawal_requestsCountAggregateInputType = {
    id?: true
    ib_request_id?: true
    amount?: true
    method?: true
    account_details?: true
    status?: true
    created_at?: true
    transaction_id?: true
    updated_at?: true
    _all?: true
  }

  export type Ib_withdrawal_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_withdrawal_requests to aggregate.
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_withdrawal_requests to fetch.
     */
    orderBy?: ib_withdrawal_requestsOrderByWithRelationInput | ib_withdrawal_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ib_withdrawal_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_withdrawal_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_withdrawal_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ib_withdrawal_requests
    **/
    _count?: true | Ib_withdrawal_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ib_withdrawal_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ib_withdrawal_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ib_withdrawal_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ib_withdrawal_requestsMaxAggregateInputType
  }

  export type GetIb_withdrawal_requestsAggregateType<T extends Ib_withdrawal_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateIb_withdrawal_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIb_withdrawal_requests[P]>
      : GetScalarType<T[P], AggregateIb_withdrawal_requests[P]>
  }




  export type ib_withdrawal_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ib_withdrawal_requestsWhereInput
    orderBy?: ib_withdrawal_requestsOrderByWithAggregationInput | ib_withdrawal_requestsOrderByWithAggregationInput[]
    by: Ib_withdrawal_requestsScalarFieldEnum[] | Ib_withdrawal_requestsScalarFieldEnum
    having?: ib_withdrawal_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ib_withdrawal_requestsCountAggregateInputType | true
    _avg?: Ib_withdrawal_requestsAvgAggregateInputType
    _sum?: Ib_withdrawal_requestsSumAggregateInputType
    _min?: Ib_withdrawal_requestsMinAggregateInputType
    _max?: Ib_withdrawal_requestsMaxAggregateInputType
  }

  export type Ib_withdrawal_requestsGroupByOutputType = {
    id: number
    ib_request_id: number
    amount: Decimal
    method: string
    account_details: string | null
    status: string
    created_at: Date | null
    transaction_id: string | null
    updated_at: Date | null
    _count: Ib_withdrawal_requestsCountAggregateOutputType | null
    _avg: Ib_withdrawal_requestsAvgAggregateOutputType | null
    _sum: Ib_withdrawal_requestsSumAggregateOutputType | null
    _min: Ib_withdrawal_requestsMinAggregateOutputType | null
    _max: Ib_withdrawal_requestsMaxAggregateOutputType | null
  }

  type GetIb_withdrawal_requestsGroupByPayload<T extends ib_withdrawal_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ib_withdrawal_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ib_withdrawal_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ib_withdrawal_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Ib_withdrawal_requestsGroupByOutputType[P]>
        }
      >
    >


  export type ib_withdrawal_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    amount?: boolean
    method?: boolean
    account_details?: boolean
    status?: boolean
    created_at?: boolean
    transaction_id?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_withdrawal_requests"]>

  export type ib_withdrawal_requestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    amount?: boolean
    method?: boolean
    account_details?: boolean
    status?: boolean
    created_at?: boolean
    transaction_id?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_withdrawal_requests"]>

  export type ib_withdrawal_requestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ib_request_id?: boolean
    amount?: boolean
    method?: boolean
    account_details?: boolean
    status?: boolean
    created_at?: boolean
    transaction_id?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ib_withdrawal_requests"]>

  export type ib_withdrawal_requestsSelectScalar = {
    id?: boolean
    ib_request_id?: boolean
    amount?: boolean
    method?: boolean
    account_details?: boolean
    status?: boolean
    created_at?: boolean
    transaction_id?: boolean
    updated_at?: boolean
  }

  export type ib_withdrawal_requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ib_request_id" | "amount" | "method" | "account_details" | "status" | "created_at" | "transaction_id" | "updated_at", ExtArgs["result"]["ib_withdrawal_requests"]>

  export type $ib_withdrawal_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ib_withdrawal_requests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ib_request_id: number
      amount: Prisma.Decimal
      method: string
      account_details: string | null
      status: string
      created_at: Date | null
      transaction_id: string | null
      updated_at: Date | null
    }, ExtArgs["result"]["ib_withdrawal_requests"]>
    composites: {}
  }

  type ib_withdrawal_requestsGetPayload<S extends boolean | null | undefined | ib_withdrawal_requestsDefaultArgs> = $Result.GetResult<Prisma.$ib_withdrawal_requestsPayload, S>

  type ib_withdrawal_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ib_withdrawal_requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ib_withdrawal_requestsCountAggregateInputType | true
    }

  export interface ib_withdrawal_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ib_withdrawal_requests'], meta: { name: 'ib_withdrawal_requests' } }
    /**
     * Find zero or one Ib_withdrawal_requests that matches the filter.
     * @param {ib_withdrawal_requestsFindUniqueArgs} args - Arguments to find a Ib_withdrawal_requests
     * @example
     * // Get one Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ib_withdrawal_requestsFindUniqueArgs>(args: SelectSubset<T, ib_withdrawal_requestsFindUniqueArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ib_withdrawal_requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ib_withdrawal_requestsFindUniqueOrThrowArgs} args - Arguments to find a Ib_withdrawal_requests
     * @example
     * // Get one Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ib_withdrawal_requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, ib_withdrawal_requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_withdrawal_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_withdrawal_requestsFindFirstArgs} args - Arguments to find a Ib_withdrawal_requests
     * @example
     * // Get one Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ib_withdrawal_requestsFindFirstArgs>(args?: SelectSubset<T, ib_withdrawal_requestsFindFirstArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ib_withdrawal_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_withdrawal_requestsFindFirstOrThrowArgs} args - Arguments to find a Ib_withdrawal_requests
     * @example
     * // Get one Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ib_withdrawal_requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, ib_withdrawal_requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ib_withdrawal_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_withdrawal_requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findMany()
     * 
     * // Get first 10 Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ib_withdrawal_requestsWithIdOnly = await prisma.ib_withdrawal_requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ib_withdrawal_requestsFindManyArgs>(args?: SelectSubset<T, ib_withdrawal_requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ib_withdrawal_requests.
     * @param {ib_withdrawal_requestsCreateArgs} args - Arguments to create a Ib_withdrawal_requests.
     * @example
     * // Create one Ib_withdrawal_requests
     * const Ib_withdrawal_requests = await prisma.ib_withdrawal_requests.create({
     *   data: {
     *     // ... data to create a Ib_withdrawal_requests
     *   }
     * })
     * 
     */
    create<T extends ib_withdrawal_requestsCreateArgs>(args: SelectSubset<T, ib_withdrawal_requestsCreateArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ib_withdrawal_requests.
     * @param {ib_withdrawal_requestsCreateManyArgs} args - Arguments to create many Ib_withdrawal_requests.
     * @example
     * // Create many Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ib_withdrawal_requestsCreateManyArgs>(args?: SelectSubset<T, ib_withdrawal_requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ib_withdrawal_requests and returns the data saved in the database.
     * @param {ib_withdrawal_requestsCreateManyAndReturnArgs} args - Arguments to create many Ib_withdrawal_requests.
     * @example
     * // Create many Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ib_withdrawal_requests and only return the `id`
     * const ib_withdrawal_requestsWithIdOnly = await prisma.ib_withdrawal_requests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ib_withdrawal_requestsCreateManyAndReturnArgs>(args?: SelectSubset<T, ib_withdrawal_requestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ib_withdrawal_requests.
     * @param {ib_withdrawal_requestsDeleteArgs} args - Arguments to delete one Ib_withdrawal_requests.
     * @example
     * // Delete one Ib_withdrawal_requests
     * const Ib_withdrawal_requests = await prisma.ib_withdrawal_requests.delete({
     *   where: {
     *     // ... filter to delete one Ib_withdrawal_requests
     *   }
     * })
     * 
     */
    delete<T extends ib_withdrawal_requestsDeleteArgs>(args: SelectSubset<T, ib_withdrawal_requestsDeleteArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ib_withdrawal_requests.
     * @param {ib_withdrawal_requestsUpdateArgs} args - Arguments to update one Ib_withdrawal_requests.
     * @example
     * // Update one Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ib_withdrawal_requestsUpdateArgs>(args: SelectSubset<T, ib_withdrawal_requestsUpdateArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ib_withdrawal_requests.
     * @param {ib_withdrawal_requestsDeleteManyArgs} args - Arguments to filter Ib_withdrawal_requests to delete.
     * @example
     * // Delete a few Ib_withdrawal_requests
     * const { count } = await prisma.ib_withdrawal_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ib_withdrawal_requestsDeleteManyArgs>(args?: SelectSubset<T, ib_withdrawal_requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_withdrawal_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_withdrawal_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ib_withdrawal_requestsUpdateManyArgs>(args: SelectSubset<T, ib_withdrawal_requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ib_withdrawal_requests and returns the data updated in the database.
     * @param {ib_withdrawal_requestsUpdateManyAndReturnArgs} args - Arguments to update many Ib_withdrawal_requests.
     * @example
     * // Update many Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ib_withdrawal_requests and only return the `id`
     * const ib_withdrawal_requestsWithIdOnly = await prisma.ib_withdrawal_requests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ib_withdrawal_requestsUpdateManyAndReturnArgs>(args: SelectSubset<T, ib_withdrawal_requestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ib_withdrawal_requests.
     * @param {ib_withdrawal_requestsUpsertArgs} args - Arguments to update or create a Ib_withdrawal_requests.
     * @example
     * // Update or create a Ib_withdrawal_requests
     * const ib_withdrawal_requests = await prisma.ib_withdrawal_requests.upsert({
     *   create: {
     *     // ... data to create a Ib_withdrawal_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ib_withdrawal_requests we want to update
     *   }
     * })
     */
    upsert<T extends ib_withdrawal_requestsUpsertArgs>(args: SelectSubset<T, ib_withdrawal_requestsUpsertArgs<ExtArgs>>): Prisma__ib_withdrawal_requestsClient<$Result.GetResult<Prisma.$ib_withdrawal_requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ib_withdrawal_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_withdrawal_requestsCountArgs} args - Arguments to filter Ib_withdrawal_requests to count.
     * @example
     * // Count the number of Ib_withdrawal_requests
     * const count = await prisma.ib_withdrawal_requests.count({
     *   where: {
     *     // ... the filter for the Ib_withdrawal_requests we want to count
     *   }
     * })
    **/
    count<T extends ib_withdrawal_requestsCountArgs>(
      args?: Subset<T, ib_withdrawal_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ib_withdrawal_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ib_withdrawal_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ib_withdrawal_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ib_withdrawal_requestsAggregateArgs>(args: Subset<T, Ib_withdrawal_requestsAggregateArgs>): Prisma.PrismaPromise<GetIb_withdrawal_requestsAggregateType<T>>

    /**
     * Group by Ib_withdrawal_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ib_withdrawal_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ib_withdrawal_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ib_withdrawal_requestsGroupByArgs['orderBy'] }
        : { orderBy?: ib_withdrawal_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ib_withdrawal_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIb_withdrawal_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ib_withdrawal_requests model
   */
  readonly fields: ib_withdrawal_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ib_withdrawal_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ib_withdrawal_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ib_withdrawal_requests model
   */
  interface ib_withdrawal_requestsFieldRefs {
    readonly id: FieldRef<"ib_withdrawal_requests", 'Int'>
    readonly ib_request_id: FieldRef<"ib_withdrawal_requests", 'Int'>
    readonly amount: FieldRef<"ib_withdrawal_requests", 'Decimal'>
    readonly method: FieldRef<"ib_withdrawal_requests", 'String'>
    readonly account_details: FieldRef<"ib_withdrawal_requests", 'String'>
    readonly status: FieldRef<"ib_withdrawal_requests", 'String'>
    readonly created_at: FieldRef<"ib_withdrawal_requests", 'DateTime'>
    readonly transaction_id: FieldRef<"ib_withdrawal_requests", 'String'>
    readonly updated_at: FieldRef<"ib_withdrawal_requests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ib_withdrawal_requests findUnique
   */
  export type ib_withdrawal_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * Filter, which ib_withdrawal_requests to fetch.
     */
    where: ib_withdrawal_requestsWhereUniqueInput
  }

  /**
   * ib_withdrawal_requests findUniqueOrThrow
   */
  export type ib_withdrawal_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * Filter, which ib_withdrawal_requests to fetch.
     */
    where: ib_withdrawal_requestsWhereUniqueInput
  }

  /**
   * ib_withdrawal_requests findFirst
   */
  export type ib_withdrawal_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * Filter, which ib_withdrawal_requests to fetch.
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_withdrawal_requests to fetch.
     */
    orderBy?: ib_withdrawal_requestsOrderByWithRelationInput | ib_withdrawal_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_withdrawal_requests.
     */
    cursor?: ib_withdrawal_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_withdrawal_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_withdrawal_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_withdrawal_requests.
     */
    distinct?: Ib_withdrawal_requestsScalarFieldEnum | Ib_withdrawal_requestsScalarFieldEnum[]
  }

  /**
   * ib_withdrawal_requests findFirstOrThrow
   */
  export type ib_withdrawal_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * Filter, which ib_withdrawal_requests to fetch.
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_withdrawal_requests to fetch.
     */
    orderBy?: ib_withdrawal_requestsOrderByWithRelationInput | ib_withdrawal_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ib_withdrawal_requests.
     */
    cursor?: ib_withdrawal_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_withdrawal_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_withdrawal_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ib_withdrawal_requests.
     */
    distinct?: Ib_withdrawal_requestsScalarFieldEnum | Ib_withdrawal_requestsScalarFieldEnum[]
  }

  /**
   * ib_withdrawal_requests findMany
   */
  export type ib_withdrawal_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * Filter, which ib_withdrawal_requests to fetch.
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ib_withdrawal_requests to fetch.
     */
    orderBy?: ib_withdrawal_requestsOrderByWithRelationInput | ib_withdrawal_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ib_withdrawal_requests.
     */
    cursor?: ib_withdrawal_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ib_withdrawal_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ib_withdrawal_requests.
     */
    skip?: number
    distinct?: Ib_withdrawal_requestsScalarFieldEnum | Ib_withdrawal_requestsScalarFieldEnum[]
  }

  /**
   * ib_withdrawal_requests create
   */
  export type ib_withdrawal_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * The data needed to create a ib_withdrawal_requests.
     */
    data: XOR<ib_withdrawal_requestsCreateInput, ib_withdrawal_requestsUncheckedCreateInput>
  }

  /**
   * ib_withdrawal_requests createMany
   */
  export type ib_withdrawal_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ib_withdrawal_requests.
     */
    data: ib_withdrawal_requestsCreateManyInput | ib_withdrawal_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_withdrawal_requests createManyAndReturn
   */
  export type ib_withdrawal_requestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * The data used to create many ib_withdrawal_requests.
     */
    data: ib_withdrawal_requestsCreateManyInput | ib_withdrawal_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ib_withdrawal_requests update
   */
  export type ib_withdrawal_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * The data needed to update a ib_withdrawal_requests.
     */
    data: XOR<ib_withdrawal_requestsUpdateInput, ib_withdrawal_requestsUncheckedUpdateInput>
    /**
     * Choose, which ib_withdrawal_requests to update.
     */
    where: ib_withdrawal_requestsWhereUniqueInput
  }

  /**
   * ib_withdrawal_requests updateMany
   */
  export type ib_withdrawal_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ib_withdrawal_requests.
     */
    data: XOR<ib_withdrawal_requestsUpdateManyMutationInput, ib_withdrawal_requestsUncheckedUpdateManyInput>
    /**
     * Filter which ib_withdrawal_requests to update
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * Limit how many ib_withdrawal_requests to update.
     */
    limit?: number
  }

  /**
   * ib_withdrawal_requests updateManyAndReturn
   */
  export type ib_withdrawal_requestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * The data used to update ib_withdrawal_requests.
     */
    data: XOR<ib_withdrawal_requestsUpdateManyMutationInput, ib_withdrawal_requestsUncheckedUpdateManyInput>
    /**
     * Filter which ib_withdrawal_requests to update
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * Limit how many ib_withdrawal_requests to update.
     */
    limit?: number
  }

  /**
   * ib_withdrawal_requests upsert
   */
  export type ib_withdrawal_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * The filter to search for the ib_withdrawal_requests to update in case it exists.
     */
    where: ib_withdrawal_requestsWhereUniqueInput
    /**
     * In case the ib_withdrawal_requests found by the `where` argument doesn't exist, create a new ib_withdrawal_requests with this data.
     */
    create: XOR<ib_withdrawal_requestsCreateInput, ib_withdrawal_requestsUncheckedCreateInput>
    /**
     * In case the ib_withdrawal_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ib_withdrawal_requestsUpdateInput, ib_withdrawal_requestsUncheckedUpdateInput>
  }

  /**
   * ib_withdrawal_requests delete
   */
  export type ib_withdrawal_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
    /**
     * Filter which ib_withdrawal_requests to delete.
     */
    where: ib_withdrawal_requestsWhereUniqueInput
  }

  /**
   * ib_withdrawal_requests deleteMany
   */
  export type ib_withdrawal_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ib_withdrawal_requests to delete
     */
    where?: ib_withdrawal_requestsWhereInput
    /**
     * Limit how many ib_withdrawal_requests to delete.
     */
    limit?: number
  }

  /**
   * ib_withdrawal_requests without action
   */
  export type ib_withdrawal_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ib_withdrawal_requests
     */
    select?: ib_withdrawal_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ib_withdrawal_requests
     */
    omit?: ib_withdrawal_requestsOmit<ExtArgs> | null
  }


  /**
   * Model sent_emails
   */

  export type AggregateSent_emails = {
    _count: Sent_emailsCountAggregateOutputType | null
    _avg: Sent_emailsAvgAggregateOutputType | null
    _sum: Sent_emailsSumAggregateOutputType | null
    _min: Sent_emailsMinAggregateOutputType | null
    _max: Sent_emailsMaxAggregateOutputType | null
  }

  export type Sent_emailsAvgAggregateOutputType = {
    id: number | null
    attachments_count: number | null
  }

  export type Sent_emailsSumAggregateOutputType = {
    id: number | null
    attachments_count: number | null
  }

  export type Sent_emailsMinAggregateOutputType = {
    id: number | null
    recipient_email: string | null
    recipient_name: string | null
    subject: string | null
    content_body: string | null
    is_html: boolean | null
    recipient_type: string | null
    status: string | null
    error_message: string | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    admin_id: string | null
    attachments_count: number | null
  }

  export type Sent_emailsMaxAggregateOutputType = {
    id: number | null
    recipient_email: string | null
    recipient_name: string | null
    subject: string | null
    content_body: string | null
    is_html: boolean | null
    recipient_type: string | null
    status: string | null
    error_message: string | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    admin_id: string | null
    attachments_count: number | null
  }

  export type Sent_emailsCountAggregateOutputType = {
    id: number
    recipient_email: number
    recipient_name: number
    subject: number
    content_body: number
    is_html: number
    recipient_type: number
    status: number
    error_message: number
    sent_at: number
    created_at: number
    updated_at: number
    admin_id: number
    attachments_count: number
    _all: number
  }


  export type Sent_emailsAvgAggregateInputType = {
    id?: true
    attachments_count?: true
  }

  export type Sent_emailsSumAggregateInputType = {
    id?: true
    attachments_count?: true
  }

  export type Sent_emailsMinAggregateInputType = {
    id?: true
    recipient_email?: true
    recipient_name?: true
    subject?: true
    content_body?: true
    is_html?: true
    recipient_type?: true
    status?: true
    error_message?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    admin_id?: true
    attachments_count?: true
  }

  export type Sent_emailsMaxAggregateInputType = {
    id?: true
    recipient_email?: true
    recipient_name?: true
    subject?: true
    content_body?: true
    is_html?: true
    recipient_type?: true
    status?: true
    error_message?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    admin_id?: true
    attachments_count?: true
  }

  export type Sent_emailsCountAggregateInputType = {
    id?: true
    recipient_email?: true
    recipient_name?: true
    subject?: true
    content_body?: true
    is_html?: true
    recipient_type?: true
    status?: true
    error_message?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    admin_id?: true
    attachments_count?: true
    _all?: true
  }

  export type Sent_emailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sent_emails to aggregate.
     */
    where?: sent_emailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sent_emails to fetch.
     */
    orderBy?: sent_emailsOrderByWithRelationInput | sent_emailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sent_emailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sent_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sent_emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sent_emails
    **/
    _count?: true | Sent_emailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sent_emailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sent_emailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sent_emailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sent_emailsMaxAggregateInputType
  }

  export type GetSent_emailsAggregateType<T extends Sent_emailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSent_emails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSent_emails[P]>
      : GetScalarType<T[P], AggregateSent_emails[P]>
  }




  export type sent_emailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sent_emailsWhereInput
    orderBy?: sent_emailsOrderByWithAggregationInput | sent_emailsOrderByWithAggregationInput[]
    by: Sent_emailsScalarFieldEnum[] | Sent_emailsScalarFieldEnum
    having?: sent_emailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sent_emailsCountAggregateInputType | true
    _avg?: Sent_emailsAvgAggregateInputType
    _sum?: Sent_emailsSumAggregateInputType
    _min?: Sent_emailsMinAggregateInputType
    _max?: Sent_emailsMaxAggregateInputType
  }

  export type Sent_emailsGroupByOutputType = {
    id: number
    recipient_email: string
    recipient_name: string | null
    subject: string
    content_body: string
    is_html: boolean | null
    recipient_type: string | null
    status: string | null
    error_message: string | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    admin_id: string | null
    attachments_count: number | null
    _count: Sent_emailsCountAggregateOutputType | null
    _avg: Sent_emailsAvgAggregateOutputType | null
    _sum: Sent_emailsSumAggregateOutputType | null
    _min: Sent_emailsMinAggregateOutputType | null
    _max: Sent_emailsMaxAggregateOutputType | null
  }

  type GetSent_emailsGroupByPayload<T extends sent_emailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sent_emailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sent_emailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sent_emailsGroupByOutputType[P]>
            : GetScalarType<T[P], Sent_emailsGroupByOutputType[P]>
        }
      >
    >


  export type sent_emailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient_email?: boolean
    recipient_name?: boolean
    subject?: boolean
    content_body?: boolean
    is_html?: boolean
    recipient_type?: boolean
    status?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    admin_id?: boolean
    attachments_count?: boolean
  }, ExtArgs["result"]["sent_emails"]>

  export type sent_emailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient_email?: boolean
    recipient_name?: boolean
    subject?: boolean
    content_body?: boolean
    is_html?: boolean
    recipient_type?: boolean
    status?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    admin_id?: boolean
    attachments_count?: boolean
  }, ExtArgs["result"]["sent_emails"]>

  export type sent_emailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipient_email?: boolean
    recipient_name?: boolean
    subject?: boolean
    content_body?: boolean
    is_html?: boolean
    recipient_type?: boolean
    status?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    admin_id?: boolean
    attachments_count?: boolean
  }, ExtArgs["result"]["sent_emails"]>

  export type sent_emailsSelectScalar = {
    id?: boolean
    recipient_email?: boolean
    recipient_name?: boolean
    subject?: boolean
    content_body?: boolean
    is_html?: boolean
    recipient_type?: boolean
    status?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    admin_id?: boolean
    attachments_count?: boolean
  }

  export type sent_emailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipient_email" | "recipient_name" | "subject" | "content_body" | "is_html" | "recipient_type" | "status" | "error_message" | "sent_at" | "created_at" | "updated_at" | "admin_id" | "attachments_count", ExtArgs["result"]["sent_emails"]>

  export type $sent_emailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sent_emails"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recipient_email: string
      recipient_name: string | null
      subject: string
      content_body: string
      is_html: boolean | null
      recipient_type: string | null
      status: string | null
      error_message: string | null
      sent_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      admin_id: string | null
      attachments_count: number | null
    }, ExtArgs["result"]["sent_emails"]>
    composites: {}
  }

  type sent_emailsGetPayload<S extends boolean | null | undefined | sent_emailsDefaultArgs> = $Result.GetResult<Prisma.$sent_emailsPayload, S>

  type sent_emailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sent_emailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sent_emailsCountAggregateInputType | true
    }

  export interface sent_emailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sent_emails'], meta: { name: 'sent_emails' } }
    /**
     * Find zero or one Sent_emails that matches the filter.
     * @param {sent_emailsFindUniqueArgs} args - Arguments to find a Sent_emails
     * @example
     * // Get one Sent_emails
     * const sent_emails = await prisma.sent_emails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sent_emailsFindUniqueArgs>(args: SelectSubset<T, sent_emailsFindUniqueArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sent_emails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sent_emailsFindUniqueOrThrowArgs} args - Arguments to find a Sent_emails
     * @example
     * // Get one Sent_emails
     * const sent_emails = await prisma.sent_emails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sent_emailsFindUniqueOrThrowArgs>(args: SelectSubset<T, sent_emailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sent_emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sent_emailsFindFirstArgs} args - Arguments to find a Sent_emails
     * @example
     * // Get one Sent_emails
     * const sent_emails = await prisma.sent_emails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sent_emailsFindFirstArgs>(args?: SelectSubset<T, sent_emailsFindFirstArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sent_emails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sent_emailsFindFirstOrThrowArgs} args - Arguments to find a Sent_emails
     * @example
     * // Get one Sent_emails
     * const sent_emails = await prisma.sent_emails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sent_emailsFindFirstOrThrowArgs>(args?: SelectSubset<T, sent_emailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sent_emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sent_emailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sent_emails
     * const sent_emails = await prisma.sent_emails.findMany()
     * 
     * // Get first 10 Sent_emails
     * const sent_emails = await prisma.sent_emails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sent_emailsWithIdOnly = await prisma.sent_emails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sent_emailsFindManyArgs>(args?: SelectSubset<T, sent_emailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sent_emails.
     * @param {sent_emailsCreateArgs} args - Arguments to create a Sent_emails.
     * @example
     * // Create one Sent_emails
     * const Sent_emails = await prisma.sent_emails.create({
     *   data: {
     *     // ... data to create a Sent_emails
     *   }
     * })
     * 
     */
    create<T extends sent_emailsCreateArgs>(args: SelectSubset<T, sent_emailsCreateArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sent_emails.
     * @param {sent_emailsCreateManyArgs} args - Arguments to create many Sent_emails.
     * @example
     * // Create many Sent_emails
     * const sent_emails = await prisma.sent_emails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sent_emailsCreateManyArgs>(args?: SelectSubset<T, sent_emailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sent_emails and returns the data saved in the database.
     * @param {sent_emailsCreateManyAndReturnArgs} args - Arguments to create many Sent_emails.
     * @example
     * // Create many Sent_emails
     * const sent_emails = await prisma.sent_emails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sent_emails and only return the `id`
     * const sent_emailsWithIdOnly = await prisma.sent_emails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sent_emailsCreateManyAndReturnArgs>(args?: SelectSubset<T, sent_emailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sent_emails.
     * @param {sent_emailsDeleteArgs} args - Arguments to delete one Sent_emails.
     * @example
     * // Delete one Sent_emails
     * const Sent_emails = await prisma.sent_emails.delete({
     *   where: {
     *     // ... filter to delete one Sent_emails
     *   }
     * })
     * 
     */
    delete<T extends sent_emailsDeleteArgs>(args: SelectSubset<T, sent_emailsDeleteArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sent_emails.
     * @param {sent_emailsUpdateArgs} args - Arguments to update one Sent_emails.
     * @example
     * // Update one Sent_emails
     * const sent_emails = await prisma.sent_emails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sent_emailsUpdateArgs>(args: SelectSubset<T, sent_emailsUpdateArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sent_emails.
     * @param {sent_emailsDeleteManyArgs} args - Arguments to filter Sent_emails to delete.
     * @example
     * // Delete a few Sent_emails
     * const { count } = await prisma.sent_emails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sent_emailsDeleteManyArgs>(args?: SelectSubset<T, sent_emailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sent_emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sent_emailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sent_emails
     * const sent_emails = await prisma.sent_emails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sent_emailsUpdateManyArgs>(args: SelectSubset<T, sent_emailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sent_emails and returns the data updated in the database.
     * @param {sent_emailsUpdateManyAndReturnArgs} args - Arguments to update many Sent_emails.
     * @example
     * // Update many Sent_emails
     * const sent_emails = await prisma.sent_emails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sent_emails and only return the `id`
     * const sent_emailsWithIdOnly = await prisma.sent_emails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sent_emailsUpdateManyAndReturnArgs>(args: SelectSubset<T, sent_emailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sent_emails.
     * @param {sent_emailsUpsertArgs} args - Arguments to update or create a Sent_emails.
     * @example
     * // Update or create a Sent_emails
     * const sent_emails = await prisma.sent_emails.upsert({
     *   create: {
     *     // ... data to create a Sent_emails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sent_emails we want to update
     *   }
     * })
     */
    upsert<T extends sent_emailsUpsertArgs>(args: SelectSubset<T, sent_emailsUpsertArgs<ExtArgs>>): Prisma__sent_emailsClient<$Result.GetResult<Prisma.$sent_emailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sent_emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sent_emailsCountArgs} args - Arguments to filter Sent_emails to count.
     * @example
     * // Count the number of Sent_emails
     * const count = await prisma.sent_emails.count({
     *   where: {
     *     // ... the filter for the Sent_emails we want to count
     *   }
     * })
    **/
    count<T extends sent_emailsCountArgs>(
      args?: Subset<T, sent_emailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sent_emailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sent_emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sent_emailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sent_emailsAggregateArgs>(args: Subset<T, Sent_emailsAggregateArgs>): Prisma.PrismaPromise<GetSent_emailsAggregateType<T>>

    /**
     * Group by Sent_emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sent_emailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sent_emailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sent_emailsGroupByArgs['orderBy'] }
        : { orderBy?: sent_emailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sent_emailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSent_emailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sent_emails model
   */
  readonly fields: sent_emailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sent_emails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sent_emailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sent_emails model
   */
  interface sent_emailsFieldRefs {
    readonly id: FieldRef<"sent_emails", 'Int'>
    readonly recipient_email: FieldRef<"sent_emails", 'String'>
    readonly recipient_name: FieldRef<"sent_emails", 'String'>
    readonly subject: FieldRef<"sent_emails", 'String'>
    readonly content_body: FieldRef<"sent_emails", 'String'>
    readonly is_html: FieldRef<"sent_emails", 'Boolean'>
    readonly recipient_type: FieldRef<"sent_emails", 'String'>
    readonly status: FieldRef<"sent_emails", 'String'>
    readonly error_message: FieldRef<"sent_emails", 'String'>
    readonly sent_at: FieldRef<"sent_emails", 'DateTime'>
    readonly created_at: FieldRef<"sent_emails", 'DateTime'>
    readonly updated_at: FieldRef<"sent_emails", 'DateTime'>
    readonly admin_id: FieldRef<"sent_emails", 'String'>
    readonly attachments_count: FieldRef<"sent_emails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * sent_emails findUnique
   */
  export type sent_emailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * Filter, which sent_emails to fetch.
     */
    where: sent_emailsWhereUniqueInput
  }

  /**
   * sent_emails findUniqueOrThrow
   */
  export type sent_emailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * Filter, which sent_emails to fetch.
     */
    where: sent_emailsWhereUniqueInput
  }

  /**
   * sent_emails findFirst
   */
  export type sent_emailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * Filter, which sent_emails to fetch.
     */
    where?: sent_emailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sent_emails to fetch.
     */
    orderBy?: sent_emailsOrderByWithRelationInput | sent_emailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sent_emails.
     */
    cursor?: sent_emailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sent_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sent_emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sent_emails.
     */
    distinct?: Sent_emailsScalarFieldEnum | Sent_emailsScalarFieldEnum[]
  }

  /**
   * sent_emails findFirstOrThrow
   */
  export type sent_emailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * Filter, which sent_emails to fetch.
     */
    where?: sent_emailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sent_emails to fetch.
     */
    orderBy?: sent_emailsOrderByWithRelationInput | sent_emailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sent_emails.
     */
    cursor?: sent_emailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sent_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sent_emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sent_emails.
     */
    distinct?: Sent_emailsScalarFieldEnum | Sent_emailsScalarFieldEnum[]
  }

  /**
   * sent_emails findMany
   */
  export type sent_emailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * Filter, which sent_emails to fetch.
     */
    where?: sent_emailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sent_emails to fetch.
     */
    orderBy?: sent_emailsOrderByWithRelationInput | sent_emailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sent_emails.
     */
    cursor?: sent_emailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sent_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sent_emails.
     */
    skip?: number
    distinct?: Sent_emailsScalarFieldEnum | Sent_emailsScalarFieldEnum[]
  }

  /**
   * sent_emails create
   */
  export type sent_emailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * The data needed to create a sent_emails.
     */
    data: XOR<sent_emailsCreateInput, sent_emailsUncheckedCreateInput>
  }

  /**
   * sent_emails createMany
   */
  export type sent_emailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sent_emails.
     */
    data: sent_emailsCreateManyInput | sent_emailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sent_emails createManyAndReturn
   */
  export type sent_emailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * The data used to create many sent_emails.
     */
    data: sent_emailsCreateManyInput | sent_emailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sent_emails update
   */
  export type sent_emailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * The data needed to update a sent_emails.
     */
    data: XOR<sent_emailsUpdateInput, sent_emailsUncheckedUpdateInput>
    /**
     * Choose, which sent_emails to update.
     */
    where: sent_emailsWhereUniqueInput
  }

  /**
   * sent_emails updateMany
   */
  export type sent_emailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sent_emails.
     */
    data: XOR<sent_emailsUpdateManyMutationInput, sent_emailsUncheckedUpdateManyInput>
    /**
     * Filter which sent_emails to update
     */
    where?: sent_emailsWhereInput
    /**
     * Limit how many sent_emails to update.
     */
    limit?: number
  }

  /**
   * sent_emails updateManyAndReturn
   */
  export type sent_emailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * The data used to update sent_emails.
     */
    data: XOR<sent_emailsUpdateManyMutationInput, sent_emailsUncheckedUpdateManyInput>
    /**
     * Filter which sent_emails to update
     */
    where?: sent_emailsWhereInput
    /**
     * Limit how many sent_emails to update.
     */
    limit?: number
  }

  /**
   * sent_emails upsert
   */
  export type sent_emailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * The filter to search for the sent_emails to update in case it exists.
     */
    where: sent_emailsWhereUniqueInput
    /**
     * In case the sent_emails found by the `where` argument doesn't exist, create a new sent_emails with this data.
     */
    create: XOR<sent_emailsCreateInput, sent_emailsUncheckedCreateInput>
    /**
     * In case the sent_emails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sent_emailsUpdateInput, sent_emailsUncheckedUpdateInput>
  }

  /**
   * sent_emails delete
   */
  export type sent_emailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
    /**
     * Filter which sent_emails to delete.
     */
    where: sent_emailsWhereUniqueInput
  }

  /**
   * sent_emails deleteMany
   */
  export type sent_emailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sent_emails to delete
     */
    where?: sent_emailsWhereInput
    /**
     * Limit how many sent_emails to delete.
     */
    limit?: number
  }

  /**
   * sent_emails without action
   */
  export type sent_emailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sent_emails
     */
    select?: sent_emailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sent_emails
     */
    omit?: sent_emailsOmit<ExtArgs> | null
  }


  /**
   * Model symbols_with_categories
   */

  export type AggregateSymbols_with_categories = {
    _count: Symbols_with_categoriesCountAggregateOutputType | null
    _avg: Symbols_with_categoriesAvgAggregateOutputType | null
    _sum: Symbols_with_categoriesSumAggregateOutputType | null
    _min: Symbols_with_categoriesMinAggregateOutputType | null
    _max: Symbols_with_categoriesMaxAggregateOutputType | null
  }

  export type Symbols_with_categoriesAvgAggregateOutputType = {
    id: number | null
    pip_per_lot: Decimal | null
    pip_value: Decimal | null
    commission: Decimal | null
    contract_size: number | null
    digits: number | null
    spread: Decimal | null
  }

  export type Symbols_with_categoriesSumAggregateOutputType = {
    id: number | null
    pip_per_lot: Decimal | null
    pip_value: Decimal | null
    commission: Decimal | null
    contract_size: number | null
    digits: number | null
    spread: Decimal | null
  }

  export type Symbols_with_categoriesMinAggregateOutputType = {
    id: number | null
    symbol: string | null
    pair: string | null
    group_name: string | null
    category: string | null
    pip_per_lot: Decimal | null
    pip_value: Decimal | null
    commission: Decimal | null
    currency: string | null
    status: string | null
    contract_size: number | null
    digits: number | null
    spread: Decimal | null
    profit_mode: string | null
    is_override: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Symbols_with_categoriesMaxAggregateOutputType = {
    id: number | null
    symbol: string | null
    pair: string | null
    group_name: string | null
    category: string | null
    pip_per_lot: Decimal | null
    pip_value: Decimal | null
    commission: Decimal | null
    currency: string | null
    status: string | null
    contract_size: number | null
    digits: number | null
    spread: Decimal | null
    profit_mode: string | null
    is_override: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Symbols_with_categoriesCountAggregateOutputType = {
    id: number
    symbol: number
    pair: number
    group_name: number
    category: number
    pip_per_lot: number
    pip_value: number
    commission: number
    currency: number
    status: number
    contract_size: number
    digits: number
    spread: number
    profit_mode: number
    is_override: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Symbols_with_categoriesAvgAggregateInputType = {
    id?: true
    pip_per_lot?: true
    pip_value?: true
    commission?: true
    contract_size?: true
    digits?: true
    spread?: true
  }

  export type Symbols_with_categoriesSumAggregateInputType = {
    id?: true
    pip_per_lot?: true
    pip_value?: true
    commission?: true
    contract_size?: true
    digits?: true
    spread?: true
  }

  export type Symbols_with_categoriesMinAggregateInputType = {
    id?: true
    symbol?: true
    pair?: true
    group_name?: true
    category?: true
    pip_per_lot?: true
    pip_value?: true
    commission?: true
    currency?: true
    status?: true
    contract_size?: true
    digits?: true
    spread?: true
    profit_mode?: true
    is_override?: true
    created_at?: true
    updated_at?: true
  }

  export type Symbols_with_categoriesMaxAggregateInputType = {
    id?: true
    symbol?: true
    pair?: true
    group_name?: true
    category?: true
    pip_per_lot?: true
    pip_value?: true
    commission?: true
    currency?: true
    status?: true
    contract_size?: true
    digits?: true
    spread?: true
    profit_mode?: true
    is_override?: true
    created_at?: true
    updated_at?: true
  }

  export type Symbols_with_categoriesCountAggregateInputType = {
    id?: true
    symbol?: true
    pair?: true
    group_name?: true
    category?: true
    pip_per_lot?: true
    pip_value?: true
    commission?: true
    currency?: true
    status?: true
    contract_size?: true
    digits?: true
    spread?: true
    profit_mode?: true
    is_override?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Symbols_with_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which symbols_with_categories to aggregate.
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols_with_categories to fetch.
     */
    orderBy?: symbols_with_categoriesOrderByWithRelationInput | symbols_with_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: symbols_with_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols_with_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols_with_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned symbols_with_categories
    **/
    _count?: true | Symbols_with_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Symbols_with_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Symbols_with_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Symbols_with_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Symbols_with_categoriesMaxAggregateInputType
  }

  export type GetSymbols_with_categoriesAggregateType<T extends Symbols_with_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSymbols_with_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymbols_with_categories[P]>
      : GetScalarType<T[P], AggregateSymbols_with_categories[P]>
  }




  export type symbols_with_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: symbols_with_categoriesWhereInput
    orderBy?: symbols_with_categoriesOrderByWithAggregationInput | symbols_with_categoriesOrderByWithAggregationInput[]
    by: Symbols_with_categoriesScalarFieldEnum[] | Symbols_with_categoriesScalarFieldEnum
    having?: symbols_with_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Symbols_with_categoriesCountAggregateInputType | true
    _avg?: Symbols_with_categoriesAvgAggregateInputType
    _sum?: Symbols_with_categoriesSumAggregateInputType
    _min?: Symbols_with_categoriesMinAggregateInputType
    _max?: Symbols_with_categoriesMaxAggregateInputType
  }

  export type Symbols_with_categoriesGroupByOutputType = {
    id: number
    symbol: string
    pair: string | null
    group_name: string | null
    category: string | null
    pip_per_lot: Decimal | null
    pip_value: Decimal | null
    commission: Decimal | null
    currency: string | null
    status: string | null
    contract_size: number | null
    digits: number | null
    spread: Decimal | null
    profit_mode: string | null
    is_override: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: Symbols_with_categoriesCountAggregateOutputType | null
    _avg: Symbols_with_categoriesAvgAggregateOutputType | null
    _sum: Symbols_with_categoriesSumAggregateOutputType | null
    _min: Symbols_with_categoriesMinAggregateOutputType | null
    _max: Symbols_with_categoriesMaxAggregateOutputType | null
  }

  type GetSymbols_with_categoriesGroupByPayload<T extends symbols_with_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Symbols_with_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Symbols_with_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Symbols_with_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Symbols_with_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type symbols_with_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    pair?: boolean
    group_name?: boolean
    category?: boolean
    pip_per_lot?: boolean
    pip_value?: boolean
    commission?: boolean
    currency?: boolean
    status?: boolean
    contract_size?: boolean
    digits?: boolean
    spread?: boolean
    profit_mode?: boolean
    is_override?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols_with_categories"]>

  export type symbols_with_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    pair?: boolean
    group_name?: boolean
    category?: boolean
    pip_per_lot?: boolean
    pip_value?: boolean
    commission?: boolean
    currency?: boolean
    status?: boolean
    contract_size?: boolean
    digits?: boolean
    spread?: boolean
    profit_mode?: boolean
    is_override?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols_with_categories"]>

  export type symbols_with_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    pair?: boolean
    group_name?: boolean
    category?: boolean
    pip_per_lot?: boolean
    pip_value?: boolean
    commission?: boolean
    currency?: boolean
    status?: boolean
    contract_size?: boolean
    digits?: boolean
    spread?: boolean
    profit_mode?: boolean
    is_override?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["symbols_with_categories"]>

  export type symbols_with_categoriesSelectScalar = {
    id?: boolean
    symbol?: boolean
    pair?: boolean
    group_name?: boolean
    category?: boolean
    pip_per_lot?: boolean
    pip_value?: boolean
    commission?: boolean
    currency?: boolean
    status?: boolean
    contract_size?: boolean
    digits?: boolean
    spread?: boolean
    profit_mode?: boolean
    is_override?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type symbols_with_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "pair" | "group_name" | "category" | "pip_per_lot" | "pip_value" | "commission" | "currency" | "status" | "contract_size" | "digits" | "spread" | "profit_mode" | "is_override" | "created_at" | "updated_at", ExtArgs["result"]["symbols_with_categories"]>

  export type $symbols_with_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "symbols_with_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      symbol: string
      pair: string | null
      group_name: string | null
      category: string | null
      pip_per_lot: Prisma.Decimal | null
      pip_value: Prisma.Decimal | null
      commission: Prisma.Decimal | null
      currency: string | null
      status: string | null
      contract_size: number | null
      digits: number | null
      spread: Prisma.Decimal | null
      profit_mode: string | null
      is_override: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["symbols_with_categories"]>
    composites: {}
  }

  type symbols_with_categoriesGetPayload<S extends boolean | null | undefined | symbols_with_categoriesDefaultArgs> = $Result.GetResult<Prisma.$symbols_with_categoriesPayload, S>

  type symbols_with_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<symbols_with_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Symbols_with_categoriesCountAggregateInputType | true
    }

  export interface symbols_with_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['symbols_with_categories'], meta: { name: 'symbols_with_categories' } }
    /**
     * Find zero or one Symbols_with_categories that matches the filter.
     * @param {symbols_with_categoriesFindUniqueArgs} args - Arguments to find a Symbols_with_categories
     * @example
     * // Get one Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends symbols_with_categoriesFindUniqueArgs>(args: SelectSubset<T, symbols_with_categoriesFindUniqueArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Symbols_with_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {symbols_with_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Symbols_with_categories
     * @example
     * // Get one Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends symbols_with_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, symbols_with_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbols_with_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbols_with_categoriesFindFirstArgs} args - Arguments to find a Symbols_with_categories
     * @example
     * // Get one Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends symbols_with_categoriesFindFirstArgs>(args?: SelectSubset<T, symbols_with_categoriesFindFirstArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Symbols_with_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbols_with_categoriesFindFirstOrThrowArgs} args - Arguments to find a Symbols_with_categories
     * @example
     * // Get one Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends symbols_with_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, symbols_with_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Symbols_with_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbols_with_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.findMany()
     * 
     * // Get first 10 Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symbols_with_categoriesWithIdOnly = await prisma.symbols_with_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends symbols_with_categoriesFindManyArgs>(args?: SelectSubset<T, symbols_with_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Symbols_with_categories.
     * @param {symbols_with_categoriesCreateArgs} args - Arguments to create a Symbols_with_categories.
     * @example
     * // Create one Symbols_with_categories
     * const Symbols_with_categories = await prisma.symbols_with_categories.create({
     *   data: {
     *     // ... data to create a Symbols_with_categories
     *   }
     * })
     * 
     */
    create<T extends symbols_with_categoriesCreateArgs>(args: SelectSubset<T, symbols_with_categoriesCreateArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Symbols_with_categories.
     * @param {symbols_with_categoriesCreateManyArgs} args - Arguments to create many Symbols_with_categories.
     * @example
     * // Create many Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends symbols_with_categoriesCreateManyArgs>(args?: SelectSubset<T, symbols_with_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Symbols_with_categories and returns the data saved in the database.
     * @param {symbols_with_categoriesCreateManyAndReturnArgs} args - Arguments to create many Symbols_with_categories.
     * @example
     * // Create many Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Symbols_with_categories and only return the `id`
     * const symbols_with_categoriesWithIdOnly = await prisma.symbols_with_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends symbols_with_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, symbols_with_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Symbols_with_categories.
     * @param {symbols_with_categoriesDeleteArgs} args - Arguments to delete one Symbols_with_categories.
     * @example
     * // Delete one Symbols_with_categories
     * const Symbols_with_categories = await prisma.symbols_with_categories.delete({
     *   where: {
     *     // ... filter to delete one Symbols_with_categories
     *   }
     * })
     * 
     */
    delete<T extends symbols_with_categoriesDeleteArgs>(args: SelectSubset<T, symbols_with_categoriesDeleteArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Symbols_with_categories.
     * @param {symbols_with_categoriesUpdateArgs} args - Arguments to update one Symbols_with_categories.
     * @example
     * // Update one Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends symbols_with_categoriesUpdateArgs>(args: SelectSubset<T, symbols_with_categoriesUpdateArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Symbols_with_categories.
     * @param {symbols_with_categoriesDeleteManyArgs} args - Arguments to filter Symbols_with_categories to delete.
     * @example
     * // Delete a few Symbols_with_categories
     * const { count } = await prisma.symbols_with_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends symbols_with_categoriesDeleteManyArgs>(args?: SelectSubset<T, symbols_with_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols_with_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbols_with_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends symbols_with_categoriesUpdateManyArgs>(args: SelectSubset<T, symbols_with_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symbols_with_categories and returns the data updated in the database.
     * @param {symbols_with_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Symbols_with_categories.
     * @example
     * // Update many Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Symbols_with_categories and only return the `id`
     * const symbols_with_categoriesWithIdOnly = await prisma.symbols_with_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends symbols_with_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, symbols_with_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Symbols_with_categories.
     * @param {symbols_with_categoriesUpsertArgs} args - Arguments to update or create a Symbols_with_categories.
     * @example
     * // Update or create a Symbols_with_categories
     * const symbols_with_categories = await prisma.symbols_with_categories.upsert({
     *   create: {
     *     // ... data to create a Symbols_with_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symbols_with_categories we want to update
     *   }
     * })
     */
    upsert<T extends symbols_with_categoriesUpsertArgs>(args: SelectSubset<T, symbols_with_categoriesUpsertArgs<ExtArgs>>): Prisma__symbols_with_categoriesClient<$Result.GetResult<Prisma.$symbols_with_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Symbols_with_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbols_with_categoriesCountArgs} args - Arguments to filter Symbols_with_categories to count.
     * @example
     * // Count the number of Symbols_with_categories
     * const count = await prisma.symbols_with_categories.count({
     *   where: {
     *     // ... the filter for the Symbols_with_categories we want to count
     *   }
     * })
    **/
    count<T extends symbols_with_categoriesCountArgs>(
      args?: Subset<T, symbols_with_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Symbols_with_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Symbols_with_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Symbols_with_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Symbols_with_categoriesAggregateArgs>(args: Subset<T, Symbols_with_categoriesAggregateArgs>): Prisma.PrismaPromise<GetSymbols_with_categoriesAggregateType<T>>

    /**
     * Group by Symbols_with_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {symbols_with_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends symbols_with_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: symbols_with_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: symbols_with_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, symbols_with_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymbols_with_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the symbols_with_categories model
   */
  readonly fields: symbols_with_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for symbols_with_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__symbols_with_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the symbols_with_categories model
   */
  interface symbols_with_categoriesFieldRefs {
    readonly id: FieldRef<"symbols_with_categories", 'Int'>
    readonly symbol: FieldRef<"symbols_with_categories", 'String'>
    readonly pair: FieldRef<"symbols_with_categories", 'String'>
    readonly group_name: FieldRef<"symbols_with_categories", 'String'>
    readonly category: FieldRef<"symbols_with_categories", 'String'>
    readonly pip_per_lot: FieldRef<"symbols_with_categories", 'Decimal'>
    readonly pip_value: FieldRef<"symbols_with_categories", 'Decimal'>
    readonly commission: FieldRef<"symbols_with_categories", 'Decimal'>
    readonly currency: FieldRef<"symbols_with_categories", 'String'>
    readonly status: FieldRef<"symbols_with_categories", 'String'>
    readonly contract_size: FieldRef<"symbols_with_categories", 'Int'>
    readonly digits: FieldRef<"symbols_with_categories", 'Int'>
    readonly spread: FieldRef<"symbols_with_categories", 'Decimal'>
    readonly profit_mode: FieldRef<"symbols_with_categories", 'String'>
    readonly is_override: FieldRef<"symbols_with_categories", 'Boolean'>
    readonly created_at: FieldRef<"symbols_with_categories", 'DateTime'>
    readonly updated_at: FieldRef<"symbols_with_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * symbols_with_categories findUnique
   */
  export type symbols_with_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which symbols_with_categories to fetch.
     */
    where: symbols_with_categoriesWhereUniqueInput
  }

  /**
   * symbols_with_categories findUniqueOrThrow
   */
  export type symbols_with_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which symbols_with_categories to fetch.
     */
    where: symbols_with_categoriesWhereUniqueInput
  }

  /**
   * symbols_with_categories findFirst
   */
  export type symbols_with_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which symbols_with_categories to fetch.
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols_with_categories to fetch.
     */
    orderBy?: symbols_with_categoriesOrderByWithRelationInput | symbols_with_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for symbols_with_categories.
     */
    cursor?: symbols_with_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols_with_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols_with_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of symbols_with_categories.
     */
    distinct?: Symbols_with_categoriesScalarFieldEnum | Symbols_with_categoriesScalarFieldEnum[]
  }

  /**
   * symbols_with_categories findFirstOrThrow
   */
  export type symbols_with_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which symbols_with_categories to fetch.
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols_with_categories to fetch.
     */
    orderBy?: symbols_with_categoriesOrderByWithRelationInput | symbols_with_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for symbols_with_categories.
     */
    cursor?: symbols_with_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols_with_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols_with_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of symbols_with_categories.
     */
    distinct?: Symbols_with_categoriesScalarFieldEnum | Symbols_with_categoriesScalarFieldEnum[]
  }

  /**
   * symbols_with_categories findMany
   */
  export type symbols_with_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which symbols_with_categories to fetch.
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of symbols_with_categories to fetch.
     */
    orderBy?: symbols_with_categoriesOrderByWithRelationInput | symbols_with_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing symbols_with_categories.
     */
    cursor?: symbols_with_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` symbols_with_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` symbols_with_categories.
     */
    skip?: number
    distinct?: Symbols_with_categoriesScalarFieldEnum | Symbols_with_categoriesScalarFieldEnum[]
  }

  /**
   * symbols_with_categories create
   */
  export type symbols_with_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a symbols_with_categories.
     */
    data: XOR<symbols_with_categoriesCreateInput, symbols_with_categoriesUncheckedCreateInput>
  }

  /**
   * symbols_with_categories createMany
   */
  export type symbols_with_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many symbols_with_categories.
     */
    data: symbols_with_categoriesCreateManyInput | symbols_with_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * symbols_with_categories createManyAndReturn
   */
  export type symbols_with_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many symbols_with_categories.
     */
    data: symbols_with_categoriesCreateManyInput | symbols_with_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * symbols_with_categories update
   */
  export type symbols_with_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a symbols_with_categories.
     */
    data: XOR<symbols_with_categoriesUpdateInput, symbols_with_categoriesUncheckedUpdateInput>
    /**
     * Choose, which symbols_with_categories to update.
     */
    where: symbols_with_categoriesWhereUniqueInput
  }

  /**
   * symbols_with_categories updateMany
   */
  export type symbols_with_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update symbols_with_categories.
     */
    data: XOR<symbols_with_categoriesUpdateManyMutationInput, symbols_with_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which symbols_with_categories to update
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * Limit how many symbols_with_categories to update.
     */
    limit?: number
  }

  /**
   * symbols_with_categories updateManyAndReturn
   */
  export type symbols_with_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update symbols_with_categories.
     */
    data: XOR<symbols_with_categoriesUpdateManyMutationInput, symbols_with_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which symbols_with_categories to update
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * Limit how many symbols_with_categories to update.
     */
    limit?: number
  }

  /**
   * symbols_with_categories upsert
   */
  export type symbols_with_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the symbols_with_categories to update in case it exists.
     */
    where: symbols_with_categoriesWhereUniqueInput
    /**
     * In case the symbols_with_categories found by the `where` argument doesn't exist, create a new symbols_with_categories with this data.
     */
    create: XOR<symbols_with_categoriesCreateInput, symbols_with_categoriesUncheckedCreateInput>
    /**
     * In case the symbols_with_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<symbols_with_categoriesUpdateInput, symbols_with_categoriesUncheckedUpdateInput>
  }

  /**
   * symbols_with_categories delete
   */
  export type symbols_with_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
    /**
     * Filter which symbols_with_categories to delete.
     */
    where: symbols_with_categoriesWhereUniqueInput
  }

  /**
   * symbols_with_categories deleteMany
   */
  export type symbols_with_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which symbols_with_categories to delete
     */
    where?: symbols_with_categoriesWhereInput
    /**
     * Limit how many symbols_with_categories to delete.
     */
    limit?: number
  }

  /**
   * symbols_with_categories without action
   */
  export type symbols_with_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the symbols_with_categories
     */
    select?: symbols_with_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the symbols_with_categories
     */
    omit?: symbols_with_categoriesOmit<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    phoneCode: string | null
    currency: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    phoneCode: string | null
    currency: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    phoneCode: number
    currency: number
    region: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phoneCode?: true
    currency?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phoneCode?: true
    currency?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    phoneCode?: true
    currency?: true
    region?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    code: string
    name: string
    phoneCode: string | null
    currency: string | null
    region: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phoneCode?: boolean
    currency?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phoneCode?: boolean
    currency?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    phoneCode?: boolean
    currency?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    phoneCode?: boolean
    currency?: boolean
    region?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "phoneCode" | "currency" | "region" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["country"]>

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      phoneCode: string | null
      currency: string | null
      region: string | null
      isActive: boolean | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly code: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly phoneCode: FieldRef<"Country", 'String'>
    readonly currency: FieldRef<"Country", 'String'>
    readonly region: FieldRef<"Country", 'String'>
    readonly isActive: FieldRef<"Country", 'Boolean'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
  }


  /**
   * Model Suggestion
   */

  export type AggregateSuggestion = {
    _count: SuggestionCountAggregateOutputType | null
    _min: SuggestionMinAggregateOutputType | null
    _max: SuggestionMaxAggregateOutputType | null
  }

  export type SuggestionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    comment: string | null
    remarks: string | null
    createdAt: Date | null
  }

  export type SuggestionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    comment: string | null
    remarks: string | null
    createdAt: Date | null
  }

  export type SuggestionCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userEmail: number
    comment: number
    remarks: number
    createdAt: number
    _all: number
  }


  export type SuggestionMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    comment?: true
    remarks?: true
    createdAt?: true
  }

  export type SuggestionMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    comment?: true
    remarks?: true
    createdAt?: true
  }

  export type SuggestionCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    comment?: true
    remarks?: true
    createdAt?: true
    _all?: true
  }

  export type SuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suggestion to aggregate.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suggestions
    **/
    _count?: true | SuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionMaxAggregateInputType
  }

  export type GetSuggestionAggregateType<T extends SuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestion[P]>
      : GetScalarType<T[P], AggregateSuggestion[P]>
  }




  export type SuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionWhereInput
    orderBy?: SuggestionOrderByWithAggregationInput | SuggestionOrderByWithAggregationInput[]
    by: SuggestionScalarFieldEnum[] | SuggestionScalarFieldEnum
    having?: SuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionCountAggregateInputType | true
    _min?: SuggestionMinAggregateInputType
    _max?: SuggestionMaxAggregateInputType
  }

  export type SuggestionGroupByOutputType = {
    id: string
    userId: string
    userName: string | null
    userEmail: string | null
    comment: string
    remarks: string | null
    createdAt: Date
    _count: SuggestionCountAggregateOutputType | null
    _min: SuggestionMinAggregateOutputType | null
    _max: SuggestionMaxAggregateOutputType | null
  }

  type GetSuggestionGroupByPayload<T extends SuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionGroupByOutputType[P]>
        }
      >
    >


  export type SuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    comment?: boolean
    remarks?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    comment?: boolean
    remarks?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    comment?: boolean
    remarks?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    comment?: boolean
    remarks?: boolean
    createdAt?: boolean
  }

  export type SuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userName" | "userEmail" | "comment" | "remarks" | "createdAt", ExtArgs["result"]["suggestion"]>
  export type SuggestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SuggestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SuggestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Suggestion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string | null
      userEmail: string | null
      comment: string
      remarks: string | null
      createdAt: Date
    }, ExtArgs["result"]["suggestion"]>
    composites: {}
  }

  type SuggestionGetPayload<S extends boolean | null | undefined | SuggestionDefaultArgs> = $Result.GetResult<Prisma.$SuggestionPayload, S>

  type SuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuggestionCountAggregateInputType | true
    }

  export interface SuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Suggestion'], meta: { name: 'Suggestion' } }
    /**
     * Find zero or one Suggestion that matches the filter.
     * @param {SuggestionFindUniqueArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuggestionFindUniqueArgs>(args: SelectSubset<T, SuggestionFindUniqueArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuggestionFindUniqueOrThrowArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindFirstArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuggestionFindFirstArgs>(args?: SelectSubset<T, SuggestionFindFirstArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindFirstOrThrowArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suggestions
     * const suggestions = await prisma.suggestion.findMany()
     * 
     * // Get first 10 Suggestions
     * const suggestions = await prisma.suggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestionWithIdOnly = await prisma.suggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuggestionFindManyArgs>(args?: SelectSubset<T, SuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suggestion.
     * @param {SuggestionCreateArgs} args - Arguments to create a Suggestion.
     * @example
     * // Create one Suggestion
     * const Suggestion = await prisma.suggestion.create({
     *   data: {
     *     // ... data to create a Suggestion
     *   }
     * })
     * 
     */
    create<T extends SuggestionCreateArgs>(args: SelectSubset<T, SuggestionCreateArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suggestions.
     * @param {SuggestionCreateManyArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestion = await prisma.suggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuggestionCreateManyArgs>(args?: SelectSubset<T, SuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suggestions and returns the data saved in the database.
     * @param {SuggestionCreateManyAndReturnArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestion = await prisma.suggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suggestions and only return the `id`
     * const suggestionWithIdOnly = await prisma.suggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Suggestion.
     * @param {SuggestionDeleteArgs} args - Arguments to delete one Suggestion.
     * @example
     * // Delete one Suggestion
     * const Suggestion = await prisma.suggestion.delete({
     *   where: {
     *     // ... filter to delete one Suggestion
     *   }
     * })
     * 
     */
    delete<T extends SuggestionDeleteArgs>(args: SelectSubset<T, SuggestionDeleteArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suggestion.
     * @param {SuggestionUpdateArgs} args - Arguments to update one Suggestion.
     * @example
     * // Update one Suggestion
     * const suggestion = await prisma.suggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuggestionUpdateArgs>(args: SelectSubset<T, SuggestionUpdateArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suggestions.
     * @param {SuggestionDeleteManyArgs} args - Arguments to filter Suggestions to delete.
     * @example
     * // Delete a few Suggestions
     * const { count } = await prisma.suggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuggestionDeleteManyArgs>(args?: SelectSubset<T, SuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suggestions
     * const suggestion = await prisma.suggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuggestionUpdateManyArgs>(args: SelectSubset<T, SuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions and returns the data updated in the database.
     * @param {SuggestionUpdateManyAndReturnArgs} args - Arguments to update many Suggestions.
     * @example
     * // Update many Suggestions
     * const suggestion = await prisma.suggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suggestions and only return the `id`
     * const suggestionWithIdOnly = await prisma.suggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Suggestion.
     * @param {SuggestionUpsertArgs} args - Arguments to update or create a Suggestion.
     * @example
     * // Update or create a Suggestion
     * const suggestion = await prisma.suggestion.upsert({
     *   create: {
     *     // ... data to create a Suggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suggestion we want to update
     *   }
     * })
     */
    upsert<T extends SuggestionUpsertArgs>(args: SelectSubset<T, SuggestionUpsertArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionCountArgs} args - Arguments to filter Suggestions to count.
     * @example
     * // Count the number of Suggestions
     * const count = await prisma.suggestion.count({
     *   where: {
     *     // ... the filter for the Suggestions we want to count
     *   }
     * })
    **/
    count<T extends SuggestionCountArgs>(
      args?: Subset<T, SuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionAggregateArgs>(args: Subset<T, SuggestionAggregateArgs>): Prisma.PrismaPromise<GetSuggestionAggregateType<T>>

    /**
     * Group by Suggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestionGroupByArgs['orderBy'] }
        : { orderBy?: SuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Suggestion model
   */
  readonly fields: SuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Suggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Suggestion model
   */
  interface SuggestionFieldRefs {
    readonly id: FieldRef<"Suggestion", 'String'>
    readonly userId: FieldRef<"Suggestion", 'String'>
    readonly userName: FieldRef<"Suggestion", 'String'>
    readonly userEmail: FieldRef<"Suggestion", 'String'>
    readonly comment: FieldRef<"Suggestion", 'String'>
    readonly remarks: FieldRef<"Suggestion", 'String'>
    readonly createdAt: FieldRef<"Suggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Suggestion findUnique
   */
  export type SuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion findUniqueOrThrow
   */
  export type SuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion findFirst
   */
  export type SuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suggestions.
     */
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Suggestion findFirstOrThrow
   */
  export type SuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suggestions.
     */
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Suggestion findMany
   */
  export type SuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestions to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Suggestion create
   */
  export type SuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Suggestion.
     */
    data: XOR<SuggestionCreateInput, SuggestionUncheckedCreateInput>
  }

  /**
   * Suggestion createMany
   */
  export type SuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suggestions.
     */
    data: SuggestionCreateManyInput | SuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suggestion createManyAndReturn
   */
  export type SuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many Suggestions.
     */
    data: SuggestionCreateManyInput | SuggestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Suggestion update
   */
  export type SuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Suggestion.
     */
    data: XOR<SuggestionUpdateInput, SuggestionUncheckedUpdateInput>
    /**
     * Choose, which Suggestion to update.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion updateMany
   */
  export type SuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suggestions.
     */
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyInput>
    /**
     * Filter which Suggestions to update
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to update.
     */
    limit?: number
  }

  /**
   * Suggestion updateManyAndReturn
   */
  export type SuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data used to update Suggestions.
     */
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyInput>
    /**
     * Filter which Suggestions to update
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Suggestion upsert
   */
  export type SuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Suggestion to update in case it exists.
     */
    where: SuggestionWhereUniqueInput
    /**
     * In case the Suggestion found by the `where` argument doesn't exist, create a new Suggestion with this data.
     */
    create: XOR<SuggestionCreateInput, SuggestionUncheckedCreateInput>
    /**
     * In case the Suggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestionUpdateInput, SuggestionUncheckedUpdateInput>
  }

  /**
   * Suggestion delete
   */
  export type SuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter which Suggestion to delete.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion deleteMany
   */
  export type SuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suggestions to delete
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to delete.
     */
    limit?: number
  }

  /**
   * Suggestion without action
   */
  export type SuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
  }


  /**
   * Model PriceAlert
   */

  export type AggregatePriceAlert = {
    _count: PriceAlertCountAggregateOutputType | null
    _avg: PriceAlertAvgAggregateOutputType | null
    _sum: PriceAlertSumAggregateOutputType | null
    _min: PriceAlertMinAggregateOutputType | null
    _max: PriceAlertMaxAggregateOutputType | null
  }

  export type PriceAlertAvgAggregateOutputType = {
    targetPrice: number | null
  }

  export type PriceAlertSumAggregateOutputType = {
    targetPrice: number | null
  }

  export type PriceAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    symbol: string | null
    targetPrice: number | null
    condition: string | null
    isActive: boolean | null
    isTriggered: boolean | null
    triggeredAt: Date | null
    createdAt: Date | null
  }

  export type PriceAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    symbol: string | null
    targetPrice: number | null
    condition: string | null
    isActive: boolean | null
    isTriggered: boolean | null
    triggeredAt: Date | null
    createdAt: Date | null
  }

  export type PriceAlertCountAggregateOutputType = {
    id: number
    userId: number
    symbol: number
    targetPrice: number
    condition: number
    isActive: number
    isTriggered: number
    triggeredAt: number
    createdAt: number
    _all: number
  }


  export type PriceAlertAvgAggregateInputType = {
    targetPrice?: true
  }

  export type PriceAlertSumAggregateInputType = {
    targetPrice?: true
  }

  export type PriceAlertMinAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    targetPrice?: true
    condition?: true
    isActive?: true
    isTriggered?: true
    triggeredAt?: true
    createdAt?: true
  }

  export type PriceAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    targetPrice?: true
    condition?: true
    isActive?: true
    isTriggered?: true
    triggeredAt?: true
    createdAt?: true
  }

  export type PriceAlertCountAggregateInputType = {
    id?: true
    userId?: true
    symbol?: true
    targetPrice?: true
    condition?: true
    isActive?: true
    isTriggered?: true
    triggeredAt?: true
    createdAt?: true
    _all?: true
  }

  export type PriceAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceAlert to aggregate.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceAlerts
    **/
    _count?: true | PriceAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceAlertMaxAggregateInputType
  }

  export type GetPriceAlertAggregateType<T extends PriceAlertAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceAlert[P]>
      : GetScalarType<T[P], AggregatePriceAlert[P]>
  }




  export type PriceAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceAlertWhereInput
    orderBy?: PriceAlertOrderByWithAggregationInput | PriceAlertOrderByWithAggregationInput[]
    by: PriceAlertScalarFieldEnum[] | PriceAlertScalarFieldEnum
    having?: PriceAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceAlertCountAggregateInputType | true
    _avg?: PriceAlertAvgAggregateInputType
    _sum?: PriceAlertSumAggregateInputType
    _min?: PriceAlertMinAggregateInputType
    _max?: PriceAlertMaxAggregateInputType
  }

  export type PriceAlertGroupByOutputType = {
    id: string
    userId: string
    symbol: string
    targetPrice: number
    condition: string
    isActive: boolean
    isTriggered: boolean
    triggeredAt: Date | null
    createdAt: Date
    _count: PriceAlertCountAggregateOutputType | null
    _avg: PriceAlertAvgAggregateOutputType | null
    _sum: PriceAlertSumAggregateOutputType | null
    _min: PriceAlertMinAggregateOutputType | null
    _max: PriceAlertMaxAggregateOutputType | null
  }

  type GetPriceAlertGroupByPayload<T extends PriceAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceAlertGroupByOutputType[P]>
            : GetScalarType<T[P], PriceAlertGroupByOutputType[P]>
        }
      >
    >


  export type PriceAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    targetPrice?: boolean
    condition?: boolean
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceAlert"]>

  export type PriceAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    targetPrice?: boolean
    condition?: boolean
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceAlert"]>

  export type PriceAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    symbol?: boolean
    targetPrice?: boolean
    condition?: boolean
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceAlert"]>

  export type PriceAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    symbol?: boolean
    targetPrice?: boolean
    condition?: boolean
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: boolean
    createdAt?: boolean
  }

  export type PriceAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "symbol" | "targetPrice" | "condition" | "isActive" | "isTriggered" | "triggeredAt" | "createdAt", ExtArgs["result"]["priceAlert"]>
  export type PriceAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PriceAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PriceAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PriceAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      symbol: string
      targetPrice: number
      condition: string
      isActive: boolean
      isTriggered: boolean
      triggeredAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["priceAlert"]>
    composites: {}
  }

  type PriceAlertGetPayload<S extends boolean | null | undefined | PriceAlertDefaultArgs> = $Result.GetResult<Prisma.$PriceAlertPayload, S>

  type PriceAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceAlertCountAggregateInputType | true
    }

  export interface PriceAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceAlert'], meta: { name: 'PriceAlert' } }
    /**
     * Find zero or one PriceAlert that matches the filter.
     * @param {PriceAlertFindUniqueArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceAlertFindUniqueArgs>(args: SelectSubset<T, PriceAlertFindUniqueArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceAlertFindUniqueOrThrowArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertFindFirstArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceAlertFindFirstArgs>(args?: SelectSubset<T, PriceAlertFindFirstArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertFindFirstOrThrowArgs} args - Arguments to find a PriceAlert
     * @example
     * // Get one PriceAlert
     * const priceAlert = await prisma.priceAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceAlerts
     * const priceAlerts = await prisma.priceAlert.findMany()
     * 
     * // Get first 10 PriceAlerts
     * const priceAlerts = await prisma.priceAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceAlertWithIdOnly = await prisma.priceAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceAlertFindManyArgs>(args?: SelectSubset<T, PriceAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceAlert.
     * @param {PriceAlertCreateArgs} args - Arguments to create a PriceAlert.
     * @example
     * // Create one PriceAlert
     * const PriceAlert = await prisma.priceAlert.create({
     *   data: {
     *     // ... data to create a PriceAlert
     *   }
     * })
     * 
     */
    create<T extends PriceAlertCreateArgs>(args: SelectSubset<T, PriceAlertCreateArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceAlerts.
     * @param {PriceAlertCreateManyArgs} args - Arguments to create many PriceAlerts.
     * @example
     * // Create many PriceAlerts
     * const priceAlert = await prisma.priceAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceAlertCreateManyArgs>(args?: SelectSubset<T, PriceAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceAlerts and returns the data saved in the database.
     * @param {PriceAlertCreateManyAndReturnArgs} args - Arguments to create many PriceAlerts.
     * @example
     * // Create many PriceAlerts
     * const priceAlert = await prisma.priceAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceAlerts and only return the `id`
     * const priceAlertWithIdOnly = await prisma.priceAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceAlert.
     * @param {PriceAlertDeleteArgs} args - Arguments to delete one PriceAlert.
     * @example
     * // Delete one PriceAlert
     * const PriceAlert = await prisma.priceAlert.delete({
     *   where: {
     *     // ... filter to delete one PriceAlert
     *   }
     * })
     * 
     */
    delete<T extends PriceAlertDeleteArgs>(args: SelectSubset<T, PriceAlertDeleteArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceAlert.
     * @param {PriceAlertUpdateArgs} args - Arguments to update one PriceAlert.
     * @example
     * // Update one PriceAlert
     * const priceAlert = await prisma.priceAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceAlertUpdateArgs>(args: SelectSubset<T, PriceAlertUpdateArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceAlerts.
     * @param {PriceAlertDeleteManyArgs} args - Arguments to filter PriceAlerts to delete.
     * @example
     * // Delete a few PriceAlerts
     * const { count } = await prisma.priceAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceAlertDeleteManyArgs>(args?: SelectSubset<T, PriceAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceAlerts
     * const priceAlert = await prisma.priceAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceAlertUpdateManyArgs>(args: SelectSubset<T, PriceAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceAlerts and returns the data updated in the database.
     * @param {PriceAlertUpdateManyAndReturnArgs} args - Arguments to update many PriceAlerts.
     * @example
     * // Update many PriceAlerts
     * const priceAlert = await prisma.priceAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceAlerts and only return the `id`
     * const priceAlertWithIdOnly = await prisma.priceAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceAlert.
     * @param {PriceAlertUpsertArgs} args - Arguments to update or create a PriceAlert.
     * @example
     * // Update or create a PriceAlert
     * const priceAlert = await prisma.priceAlert.upsert({
     *   create: {
     *     // ... data to create a PriceAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceAlert we want to update
     *   }
     * })
     */
    upsert<T extends PriceAlertUpsertArgs>(args: SelectSubset<T, PriceAlertUpsertArgs<ExtArgs>>): Prisma__PriceAlertClient<$Result.GetResult<Prisma.$PriceAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertCountArgs} args - Arguments to filter PriceAlerts to count.
     * @example
     * // Count the number of PriceAlerts
     * const count = await prisma.priceAlert.count({
     *   where: {
     *     // ... the filter for the PriceAlerts we want to count
     *   }
     * })
    **/
    count<T extends PriceAlertCountArgs>(
      args?: Subset<T, PriceAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAlertAggregateArgs>(args: Subset<T, PriceAlertAggregateArgs>): Prisma.PrismaPromise<GetPriceAlertAggregateType<T>>

    /**
     * Group by PriceAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceAlertGroupByArgs['orderBy'] }
        : { orderBy?: PriceAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceAlert model
   */
  readonly fields: PriceAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceAlert model
   */
  interface PriceAlertFieldRefs {
    readonly id: FieldRef<"PriceAlert", 'String'>
    readonly userId: FieldRef<"PriceAlert", 'String'>
    readonly symbol: FieldRef<"PriceAlert", 'String'>
    readonly targetPrice: FieldRef<"PriceAlert", 'Float'>
    readonly condition: FieldRef<"PriceAlert", 'String'>
    readonly isActive: FieldRef<"PriceAlert", 'Boolean'>
    readonly isTriggered: FieldRef<"PriceAlert", 'Boolean'>
    readonly triggeredAt: FieldRef<"PriceAlert", 'DateTime'>
    readonly createdAt: FieldRef<"PriceAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceAlert findUnique
   */
  export type PriceAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert findUniqueOrThrow
   */
  export type PriceAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert findFirst
   */
  export type PriceAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceAlerts.
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceAlerts.
     */
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * PriceAlert findFirstOrThrow
   */
  export type PriceAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlert to fetch.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceAlerts.
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceAlerts.
     */
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * PriceAlert findMany
   */
  export type PriceAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter, which PriceAlerts to fetch.
     */
    where?: PriceAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceAlerts to fetch.
     */
    orderBy?: PriceAlertOrderByWithRelationInput | PriceAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceAlerts.
     */
    cursor?: PriceAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceAlerts.
     */
    skip?: number
    distinct?: PriceAlertScalarFieldEnum | PriceAlertScalarFieldEnum[]
  }

  /**
   * PriceAlert create
   */
  export type PriceAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceAlert.
     */
    data: XOR<PriceAlertCreateInput, PriceAlertUncheckedCreateInput>
  }

  /**
   * PriceAlert createMany
   */
  export type PriceAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceAlerts.
     */
    data: PriceAlertCreateManyInput | PriceAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceAlert createManyAndReturn
   */
  export type PriceAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * The data used to create many PriceAlerts.
     */
    data: PriceAlertCreateManyInput | PriceAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceAlert update
   */
  export type PriceAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceAlert.
     */
    data: XOR<PriceAlertUpdateInput, PriceAlertUncheckedUpdateInput>
    /**
     * Choose, which PriceAlert to update.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert updateMany
   */
  export type PriceAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceAlerts.
     */
    data: XOR<PriceAlertUpdateManyMutationInput, PriceAlertUncheckedUpdateManyInput>
    /**
     * Filter which PriceAlerts to update
     */
    where?: PriceAlertWhereInput
    /**
     * Limit how many PriceAlerts to update.
     */
    limit?: number
  }

  /**
   * PriceAlert updateManyAndReturn
   */
  export type PriceAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * The data used to update PriceAlerts.
     */
    data: XOR<PriceAlertUpdateManyMutationInput, PriceAlertUncheckedUpdateManyInput>
    /**
     * Filter which PriceAlerts to update
     */
    where?: PriceAlertWhereInput
    /**
     * Limit how many PriceAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceAlert upsert
   */
  export type PriceAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceAlert to update in case it exists.
     */
    where: PriceAlertWhereUniqueInput
    /**
     * In case the PriceAlert found by the `where` argument doesn't exist, create a new PriceAlert with this data.
     */
    create: XOR<PriceAlertCreateInput, PriceAlertUncheckedCreateInput>
    /**
     * In case the PriceAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceAlertUpdateInput, PriceAlertUncheckedUpdateInput>
  }

  /**
   * PriceAlert delete
   */
  export type PriceAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
    /**
     * Filter which PriceAlert to delete.
     */
    where: PriceAlertWhereUniqueInput
  }

  /**
   * PriceAlert deleteMany
   */
  export type PriceAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceAlerts to delete
     */
    where?: PriceAlertWhereInput
    /**
     * Limit how many PriceAlerts to delete.
     */
    limit?: number
  }

  /**
   * PriceAlert without action
   */
  export type PriceAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceAlert
     */
    select?: PriceAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceAlert
     */
    omit?: PriceAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceAlertInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    country: 'country',
    createdAt: 'createdAt',
    emailVerified: 'emailVerified',
    lastLoginAt: 'lastLoginAt',
    role: 'role',
    status: 'status',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    resetToken: 'resetToken',
    resetTokenExpires: 'resetTokenExpires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const KYCScalarFieldEnum: {
    id: 'id',
    isDocumentVerified: 'isDocumentVerified',
    isAddressVerified: 'isAddressVerified',
    verificationStatus: 'verificationStatus',
    documentReference: 'documentReference',
    addressReference: 'addressReference',
    amlReference: 'amlReference',
    documentSubmittedAt: 'documentSubmittedAt',
    addressSubmittedAt: 'addressSubmittedAt',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type KYCScalarFieldEnum = (typeof KYCScalarFieldEnum)[keyof typeof KYCScalarFieldEnum]


  export const MT5AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    userId: 'userId',
    accountType: 'accountType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    password: 'password',
    leverage: 'leverage',
    nameOnAccount: 'nameOnAccount',
    package: 'package',
    group: 'group',
    balance: 'balance',
    credit: 'credit',
    currency: 'currency',
    equity: 'equity',
    lastSyncedAt: 'lastSyncedAt',
    margin: 'margin',
    marginFree: 'marginFree',
    marginLevel: 'marginLevel',
    profit: 'profit',
    archived: 'archived',
    archived_at: 'archived_at'
  };

  export type MT5AccountScalarFieldEnum = (typeof MT5AccountScalarFieldEnum)[keyof typeof MT5AccountScalarFieldEnum]


  export const MT5TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    comment: 'comment',
    mt5AccountId: 'mt5AccountId',
    createdAt: 'createdAt',
    currency: 'currency',
    depositId: 'depositId',
    withdrawalId: 'withdrawalId',
    userId: 'userId',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    updatedAt: 'updatedAt'
  };

  export type MT5TransactionScalarFieldEnum = (typeof MT5TransactionScalarFieldEnum)[keyof typeof MT5TransactionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountType: 'accountType',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const DepositScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    paymentMethod: 'paymentMethod',
    transactionHash: 'transactionHash',
    proofFileUrl: 'proofFileUrl',
    bankDetails: 'bankDetails',
    cryptoAddress: 'cryptoAddress',
    depositAddress: 'depositAddress',
    externalTransactionId: 'externalTransactionId',
    status: 'status',
    rejectionReason: 'rejectionReason',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositScalarFieldEnum = (typeof DepositScalarFieldEnum)[keyof typeof DepositScalarFieldEnum]


  export const CregisDepositScalarFieldEnum: {
    id: 'id',
    depositId: 'depositId',
    cregisOrderId: 'cregisOrderId',
    cregisStatus: 'cregisStatus',
    amount: 'amount',
    currency: 'currency',
    paymentUrl: 'paymentUrl',
    qrCodeUrl: 'qrCodeUrl',
    expiresAt: 'expiresAt',
    webhookData: 'webhookData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CregisDepositScalarFieldEnum = (typeof CregisDepositScalarFieldEnum)[keyof typeof CregisDepositScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    method: 'method',
    bankDetails: 'bankDetails',
    cryptoAddress: 'cryptoAddress',
    status: 'status',
    rejectionReason: 'rejectionReason',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    externalTransactionId: 'externalTransactionId',
    paymentMethod: 'paymentMethod',
    processedAt: 'processedAt',
    walletAddress: 'walletAddress',
    walletId: 'walletId',
    mt5AccountId: 'mt5AccountId'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balance: 'balance',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    walletNumber: 'walletNumber'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    status: 'status',
    description: 'description',
    mt5AccountId: 'mt5AccountId',
    withdrawalId: 'withdrawalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminId: 'adminId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    oldValues: 'oldValues',
    newValues: 'newValues',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    permissions: 'permissions',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    address: 'address',
    currency: 'currency',
    network: 'network',
    status: 'status',
    submittedAt: 'submittedAt',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    methodType: 'methodType',
    bankName: 'bankName',
    accountName: 'accountName',
    accountNumber: 'accountNumber',
    ifscSwiftCode: 'ifscSwiftCode',
    accountType: 'accountType'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const DefaultMT5AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mt5AccountId: 'mt5AccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DefaultMT5AccountScalarFieldEnum = (typeof DefaultMT5AccountScalarFieldEnum)[keyof typeof DefaultMT5AccountScalarFieldEnum]


  export const InstrumentScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    name: 'name',
    description: 'description',
    category: 'category',
    group: 'group',
    digits: 'digits',
    contractSize: 'contractSize',
    minVolume: 'minVolume',
    maxVolume: 'maxVolume',
    volumeStep: 'volumeStep',
    spread: 'spread',
    isActive: 'isActive',
    tradingHours: 'tradingHours',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    path: 'path',
    accountGroup: 'accountGroup',
    isin: 'isin',
    sector: 'sector',
    industry: 'industry',
    country: 'country',
    currency: 'currency',
    currencyProfit: 'currencyProfit',
    currencyMargin: 'currencyMargin',
    point: 'point',
    multiply: 'multiply',
    tickSize: 'tickSize',
    tickValue: 'tickValue',
    volumeLimit: 'volumeLimit',
    marginInitial: 'marginInitial',
    marginMaintenance: 'marginMaintenance',
    tradeMode: 'tradeMode',
    tradeFlags: 'tradeFlags',
    calcMode: 'calcMode',
    execMode: 'execMode',
    swapLong: 'swapLong',
    swapShort: 'swapShort',
    swapMode: 'swapMode'
  };

  export type InstrumentScalarFieldEnum = (typeof InstrumentScalarFieldEnum)[keyof typeof InstrumentScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revoked: 'revoked',
    deviceName: 'deviceName',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    lastActivity: 'lastActivity'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const UserFavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    instrumentId: 'instrumentId',
    mt5AccountId: 'mt5AccountId',
    sortOrder: 'sortOrder',
    addedAt: 'addedAt'
  };

  export type UserFavoriteScalarFieldEnum = (typeof UserFavoriteScalarFieldEnum)[keyof typeof UserFavoriteScalarFieldEnum]


  export const UserLoginLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    user_agent: 'user_agent',
    device: 'device',
    browser: 'browser',
    success: 'success',
    failure_reason: 'failure_reason',
    createdAt: 'createdAt'
  };

  export type UserLoginLogScalarFieldEnum = (typeof UserLoginLogScalarFieldEnum)[keyof typeof UserLoginLogScalarFieldEnum]


  export const TerminalSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    showOnChart: 'showOnChart',
    showSignals: 'showSignals',
    showHMR: 'showHMR',
    showPriceAlerts: 'showPriceAlerts',
    showOpenPositions: 'showOpenPositions',
    showTPSL: 'showTPSL',
    showEconomicCalendar: 'showEconomicCalendar',
    economicCalendarHighImpact: 'economicCalendarHighImpact',
    economicCalendarMiddleImpact: 'economicCalendarMiddleImpact',
    economicCalendarLowImpact: 'economicCalendarLowImpact',
    economicCalendarLowestImpact: 'economicCalendarLowestImpact',
    priceAlertSound: 'priceAlertSound',
    closingSound: 'closingSound',
    autoTPSL: 'autoTPSL',
    openOrderMode: 'openOrderMode',
    priceSource: 'priceSource',
    appearance: 'appearance',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TerminalSettingsScalarFieldEnum = (typeof TerminalSettingsScalarFieldEnum)[keyof typeof TerminalSettingsScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password_hash: 'password_hash',
    admin_role: 'admin_role',
    is_active: 'is_active',
    last_login: 'last_login',
    login_attempts: 'login_attempts',
    locked_until: 'locked_until',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const Admin_login_logScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    location: 'location',
    device: 'device',
    browser: 'browser',
    os: 'os',
    success: 'success',
    failure_reason: 'failure_reason',
    created_at: 'created_at'
  };

  export type Admin_login_logScalarFieldEnum = (typeof Admin_login_logScalarFieldEnum)[keyof typeof Admin_login_logScalarFieldEnum]


  export const Balance_operation_historyScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    mt5_login: 'mt5_login',
    operation_type: 'operation_type',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    status: 'status',
    error_message: 'error_message',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    created_at: 'created_at'
  };

  export type Balance_operation_historyScalarFieldEnum = (typeof Balance_operation_historyScalarFieldEnum)[keyof typeof Balance_operation_historyScalarFieldEnum]


  export const Chat_conversationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_name: 'user_name',
    user_email: 'user_email',
    admin_id: 'admin_id',
    status: 'status',
    priority: 'priority',
    subject: 'subject',
    last_message_at: 'last_message_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    closed_at: 'closed_at',
    closed_by: 'closed_by',
    tags: 'tags',
    unread_count_admin: 'unread_count_admin',
    unread_count_user: 'unread_count_user'
  };

  export type Chat_conversationsScalarFieldEnum = (typeof Chat_conversationsScalarFieldEnum)[keyof typeof Chat_conversationsScalarFieldEnum]


  export const Chat_messagesScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    sender_id: 'sender_id',
    sender_name: 'sender_name',
    sender_type: 'sender_type',
    message_type: 'message_type',
    content: 'content',
    metadata: 'metadata',
    is_read: 'is_read',
    read_at: 'read_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Chat_messagesScalarFieldEnum = (typeof Chat_messagesScalarFieldEnum)[keyof typeof Chat_messagesScalarFieldEnum]


  export const Chat_participantsScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    user_id: 'user_id',
    user_name: 'user_name',
    user_type: 'user_type',
    role: 'role',
    joined_at: 'joined_at',
    left_at: 'left_at',
    is_active: 'is_active'
  };

  export type Chat_participantsScalarFieldEnum = (typeof Chat_participantsScalarFieldEnum)[keyof typeof Chat_participantsScalarFieldEnum]


  export const Group_commission_structuresScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    structure_name: 'structure_name',
    usd_per_lot: 'usd_per_lot',
    spread_share_percentage: 'spread_share_percentage',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    level_order: 'level_order',
    min_trading_volume: 'min_trading_volume',
    max_trading_volume: 'max_trading_volume',
    min_active_clients: 'min_active_clients'
  };

  export type Group_commission_structuresScalarFieldEnum = (typeof Group_commission_structuresScalarFieldEnum)[keyof typeof Group_commission_structuresScalarFieldEnum]


  export const Ib_adminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    is_active: 'is_active',
    last_login: 'last_login',
    login_attempts: 'login_attempts',
    locked_until: 'locked_until',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ib_adminScalarFieldEnum = (typeof Ib_adminScalarFieldEnum)[keyof typeof Ib_adminScalarFieldEnum]


  export const Ib_requestsScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    password_hash: 'password_hash',
    status: 'status',
    ib_type: 'ib_type',
    submitted_at: 'submitted_at',
    approved_at: 'approved_at',
    usd_per_lot: 'usd_per_lot',
    spread_percentage_per_lot: 'spread_percentage_per_lot',
    admin_comments: 'admin_comments',
    group_id: 'group_id',
    structure_id: 'structure_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    referral_code: 'referral_code',
    referred_by: 'referred_by',
    country: 'country'
  };

  export type Ib_requestsScalarFieldEnum = (typeof Ib_requestsScalarFieldEnum)[keyof typeof Ib_requestsScalarFieldEnum]


  export const Manual_gatewayScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    details: 'details',
    icon_url: 'icon_url',
    qr_code_url: 'qr_code_url',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    vpa_address: 'vpa_address',
    crypto_address: 'crypto_address',
    bank_name: 'bank_name',
    account_name: 'account_name',
    account_number: 'account_number',
    ifsc_code: 'ifsc_code',
    swift_code: 'swift_code',
    account_type: 'account_type',
    country_code: 'country_code'
  };

  export type Manual_gatewayScalarFieldEnum = (typeof Manual_gatewayScalarFieldEnum)[keyof typeof Manual_gatewayScalarFieldEnum]


  export const Mt5_groupsScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    name: 'name',
    description: 'description',
    synced_at: 'synced_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Mt5_groupsScalarFieldEnum = (typeof Mt5_groupsScalarFieldEnum)[keyof typeof Mt5_groupsScalarFieldEnum]


  export const Payment_gatewayScalarFieldEnum: {
    id: 'id',
    wallet_name: 'wallet_name',
    deposit_wallet_address: 'deposit_wallet_address',
    api_key: 'api_key',
    secret_key: 'secret_key',
    gateway_type: 'gateway_type',
    is_active: 'is_active',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Payment_gatewayScalarFieldEnum = (typeof Payment_gatewayScalarFieldEnum)[keyof typeof Payment_gatewayScalarFieldEnum]


  export const SymbolsScalarFieldEnum: {
    id: 'id',
    symbol_name: 'symbol_name',
    description: 'description',
    symbol_type: 'symbol_type',
    group_name: 'group_name',
    digits: 'digits',
    spread: 'spread',
    contract_size: 'contract_size',
    profit_mode: 'profit_mode',
    enable: 'enable',
    swap_mode: 'swap_mode',
    swap_long: 'swap_long',
    swap_short: 'swap_short',
    swap3_day: 'swap3_day',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SymbolsScalarFieldEnum = (typeof SymbolsScalarFieldEnum)[keyof typeof SymbolsScalarFieldEnum]


  export const Ib_group_assignmentsScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    group_id: 'group_id',
    group_name: 'group_name',
    structure_id: 'structure_id',
    structure_name: 'structure_name',
    usd_per_lot: 'usd_per_lot',
    spread_share_percentage: 'spread_share_percentage',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ib_group_assignmentsScalarFieldEnum = (typeof Ib_group_assignmentsScalarFieldEnum)[keyof typeof Ib_group_assignmentsScalarFieldEnum]


  export const Ib_trade_historyScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    account_id: 'account_id',
    user_id: 'user_id',
    ib_request_id: 'ib_request_id',
    symbol: 'symbol',
    order_type: 'order_type',
    volume_lots: 'volume_lots',
    open_price: 'open_price',
    close_price: 'close_price',
    profit: 'profit',
    ib_commission: 'ib_commission',
    take_profit: 'take_profit',
    stop_loss: 'stop_loss',
    created_at: 'created_at',
    updated_at: 'updated_at',
    synced_at: 'synced_at',
    group_id: 'group_id'
  };

  export type Ib_trade_historyScalarFieldEnum = (typeof Ib_trade_historyScalarFieldEnum)[keyof typeof Ib_trade_historyScalarFieldEnum]


  export const Support_ticketsScalarFieldEnum: {
    id: 'id',
    ticket_no: 'ticket_no',
    parent_id: 'parent_id',
    title: 'title',
    description: 'description',
    ticket_type: 'ticket_type',
    status: 'status',
    priority: 'priority',
    assigned_to: 'assigned_to',
    account_number: 'account_number',
    tags: 'tags',
    created_at: 'created_at',
    updated_at: 'updated_at',
    last_reply_at: 'last_reply_at',
    closed_at: 'closed_at',
    closed_by: 'closed_by'
  };

  export type Support_ticketsScalarFieldEnum = (typeof Support_ticketsScalarFieldEnum)[keyof typeof Support_ticketsScalarFieldEnum]


  export const Support_ticket_repliesScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    reply_id: 'reply_id',
    sender_id: 'sender_id',
    sender_name: 'sender_name',
    sender_type: 'sender_type',
    content: 'content',
    is_internal: 'is_internal',
    attachments: 'attachments',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_read: 'is_read'
  };

  export type Support_ticket_repliesScalarFieldEnum = (typeof Support_ticket_repliesScalarFieldEnum)[keyof typeof Support_ticket_repliesScalarFieldEnum]


  export const Support_articlesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    category: 'category',
    tags: 'tags',
    views: 'views',
    helpful_count: 'helpful_count',
    not_helpful_count: 'not_helpful_count',
    is_published: 'is_published',
    author_id: 'author_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    published_at: 'published_at'
  };

  export type Support_articlesScalarFieldEnum = (typeof Support_articlesScalarFieldEnum)[keyof typeof Support_articlesScalarFieldEnum]


  export const Support_faqScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    tags: 'tags',
    helpful_count: 'helpful_count',
    not_helpful_count: 'not_helpful_count',
    display_order: 'display_order',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Support_faqScalarFieldEnum = (typeof Support_faqScalarFieldEnum)[keyof typeof Support_faqScalarFieldEnum]


  export const Support_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    display_order: 'display_order',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Support_categoriesScalarFieldEnum = (typeof Support_categoriesScalarFieldEnum)[keyof typeof Support_categoriesScalarFieldEnum]


  export const Support_repliesScalarFieldEnum: {
    id: 'id',
    ticket_id: 'ticket_id',
    sender_id: 'sender_id',
    sender_name: 'sender_name',
    sender_type: 'sender_type',
    content: 'content',
    is_internal: 'is_internal',
    created_at: 'created_at'
  };

  export type Support_repliesScalarFieldEnum = (typeof Support_repliesScalarFieldEnum)[keyof typeof Support_repliesScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const Group_managementScalarFieldEnum: {
    id: 'id',
    group: 'group',
    server: 'server',
    auth_mode: 'auth_mode',
    auth_password_min: 'auth_password_min',
    currency: 'currency',
    is_active: 'is_active',
    synced_at: 'synced_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    dedicated_name: 'dedicated_name',
    account_type: 'account_type',
    leverage: 'leverage',
    min_deposit: 'min_deposit',
    spread: 'spread',
    commission: 'commission'
  };

  export type Group_managementScalarFieldEnum = (typeof Group_managementScalarFieldEnum)[keyof typeof Group_managementScalarFieldEnum]


  export const SymbolGroupAccessScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    group_name: 'group_name',
    is_allowed: 'is_allowed',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SymbolGroupAccessScalarFieldEnum = (typeof SymbolGroupAccessScalarFieldEnum)[keyof typeof SymbolGroupAccessScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    status: 'status',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    description: 'description',
    metadata: 'metadata',
    depositId: 'depositId',
    withdrawalId: 'withdrawalId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const Admin_transactionsScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    user_id: 'user_id',
    mt5_account_id: 'mt5_account_id',
    mt5_login: 'mt5_login',
    operation_type: 'operation_type',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    comment: 'comment',
    external_transaction_id: 'external_transaction_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    error_message: 'error_message',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Admin_transactionsScalarFieldEnum = (typeof Admin_transactionsScalarFieldEnum)[keyof typeof Admin_transactionsScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    code: 'code',
    country: 'country',
    country_code: 'country_code'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const Country_adminsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    status: 'status',
    country_code: 'country_code',
    features: 'features',
    created_at: 'created_at'
  };

  export type Country_adminsScalarFieldEnum = (typeof Country_adminsScalarFieldEnum)[keyof typeof Country_adminsScalarFieldEnum]


  export const Email_templatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    html_code: 'html_code',
    variables: 'variables',
    is_default: 'is_default',
    preview_image_url: 'preview_image_url',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by'
  };

  export type Email_templatesScalarFieldEnum = (typeof Email_templatesScalarFieldEnum)[keyof typeof Email_templatesScalarFieldEnum]


  export const Ib_client_linkingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_name: 'user_name',
    user_email: 'user_email',
    user_account_id: 'user_account_id',
    current_ib_id: 'current_ib_id',
    current_ib_name: 'current_ib_name',
    current_ib_code: 'current_ib_code',
    assigned_ib_id: 'assigned_ib_id',
    assigned_ib_name: 'assigned_ib_name',
    assigned_ib_code: 'assigned_ib_code',
    assigned_ib_email: 'assigned_ib_email',
    status: 'status',
    direct_volume_lots: 'direct_volume_lots',
    direct_commission: 'direct_commission',
    linked_at: 'linked_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by'
  };

  export type Ib_client_linkingScalarFieldEnum = (typeof Ib_client_linkingScalarFieldEnum)[keyof typeof Ib_client_linkingScalarFieldEnum]


  export const Ib_client_linking_historyScalarFieldEnum: {
    id: 'id',
    linking_id: 'linking_id',
    user_id: 'user_id',
    user_name: 'user_name',
    user_email: 'user_email',
    from_ib_id: 'from_ib_id',
    from_ib_name: 'from_ib_name',
    from_ib_code: 'from_ib_code',
    to_ib_id: 'to_ib_id',
    to_ib_name: 'to_ib_name',
    to_ib_code: 'to_ib_code',
    action: 'action',
    moved_by: 'moved_by',
    moved_by_name: 'moved_by_name',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type Ib_client_linking_historyScalarFieldEnum = (typeof Ib_client_linking_historyScalarFieldEnum)[keyof typeof Ib_client_linking_historyScalarFieldEnum]


  export const Ib_commissionScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    user_id: 'user_id',
    total_commission: 'total_commission',
    last_updated: 'last_updated',
    created_at: 'created_at',
    updated_at: 'updated_at',
    total_trades: 'total_trades',
    total_lots: 'total_lots',
    fixed_commission: 'fixed_commission',
    spread_commission: 'spread_commission'
  };

  export type Ib_commissionScalarFieldEnum = (typeof Ib_commissionScalarFieldEnum)[keyof typeof Ib_commissionScalarFieldEnum]


  export const Ib_level_up_historyScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    from_structure_id: 'from_structure_id',
    to_structure_id: 'to_structure_id',
    from_structure_name: 'from_structure_name',
    to_structure_name: 'to_structure_name',
    trading_volume_at_upgrade: 'trading_volume_at_upgrade',
    active_clients_at_upgrade: 'active_clients_at_upgrade',
    upgraded_at: 'upgraded_at',
    created_at: 'created_at'
  };

  export type Ib_level_up_historyScalarFieldEnum = (typeof Ib_level_up_historyScalarFieldEnum)[keyof typeof Ib_level_up_historyScalarFieldEnum]


  export const Ib_referralsScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    user_id: 'user_id',
    email: 'email',
    referral_code: 'referral_code',
    source: 'source',
    created_at: 'created_at'
  };

  export type Ib_referralsScalarFieldEnum = (typeof Ib_referralsScalarFieldEnum)[keyof typeof Ib_referralsScalarFieldEnum]


  export const Ib_reward_claimsScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    user_id: 'user_id',
    reward_id: 'reward_id',
    reward_value: 'reward_value',
    reward_description: 'reward_description',
    reward_type: 'reward_type',
    claimant_name: 'claimant_name',
    claimant_phone: 'claimant_phone',
    claimant_email: 'claimant_email',
    claimant_address_street: 'claimant_address_street',
    claimant_address_city: 'claimant_address_city',
    claimant_address_state: 'claimant_address_state',
    claimant_address_country: 'claimant_address_country',
    claimant_address_postal_code: 'claimant_address_postal_code',
    status: 'status',
    total_volume_mln: 'total_volume_mln',
    admin_notes: 'admin_notes',
    claimed_at: 'claimed_at',
    updated_at: 'updated_at',
    created_at: 'created_at'
  };

  export type Ib_reward_claimsScalarFieldEnum = (typeof Ib_reward_claimsScalarFieldEnum)[keyof typeof Ib_reward_claimsScalarFieldEnum]


  export const Ib_withdrawal_requestsScalarFieldEnum: {
    id: 'id',
    ib_request_id: 'ib_request_id',
    amount: 'amount',
    method: 'method',
    account_details: 'account_details',
    status: 'status',
    created_at: 'created_at',
    transaction_id: 'transaction_id',
    updated_at: 'updated_at'
  };

  export type Ib_withdrawal_requestsScalarFieldEnum = (typeof Ib_withdrawal_requestsScalarFieldEnum)[keyof typeof Ib_withdrawal_requestsScalarFieldEnum]


  export const Sent_emailsScalarFieldEnum: {
    id: 'id',
    recipient_email: 'recipient_email',
    recipient_name: 'recipient_name',
    subject: 'subject',
    content_body: 'content_body',
    is_html: 'is_html',
    recipient_type: 'recipient_type',
    status: 'status',
    error_message: 'error_message',
    sent_at: 'sent_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    admin_id: 'admin_id',
    attachments_count: 'attachments_count'
  };

  export type Sent_emailsScalarFieldEnum = (typeof Sent_emailsScalarFieldEnum)[keyof typeof Sent_emailsScalarFieldEnum]


  export const Symbols_with_categoriesScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    pair: 'pair',
    group_name: 'group_name',
    category: 'category',
    pip_per_lot: 'pip_per_lot',
    pip_value: 'pip_value',
    commission: 'commission',
    currency: 'currency',
    status: 'status',
    contract_size: 'contract_size',
    digits: 'digits',
    spread: 'spread',
    profit_mode: 'profit_mode',
    is_override: 'is_override',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Symbols_with_categoriesScalarFieldEnum = (typeof Symbols_with_categoriesScalarFieldEnum)[keyof typeof Symbols_with_categoriesScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    phoneCode: 'phoneCode',
    currency: 'currency',
    region: 'region',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const SuggestionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userEmail: 'userEmail',
    comment: 'comment',
    remarks: 'remarks',
    createdAt: 'createdAt'
  };

  export type SuggestionScalarFieldEnum = (typeof SuggestionScalarFieldEnum)[keyof typeof SuggestionScalarFieldEnum]


  export const PriceAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    symbol: 'symbol',
    targetPrice: 'targetPrice',
    condition: 'condition',
    isActive: 'isActive',
    isTriggered: 'isTriggered',
    triggeredAt: 'triggeredAt',
    createdAt: 'createdAt'
  };

  export type PriceAlertScalarFieldEnum = (typeof PriceAlertScalarFieldEnum)[keyof typeof PriceAlertScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    clientId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    DefaultMT5Account?: XOR<DefaultMT5AccountNullableScalarRelationFilter, DefaultMT5AccountWhereInput> | null
    deposits?: DepositListRelationFilter
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    mt5Accounts?: MT5AccountListRelationFilter
    notifications?: NotificationListRelationFilter
    RefreshToken?: RefreshTokenListRelationFilter
    terminalSettings?: XOR<TerminalSettingsNullableScalarRelationFilter, TerminalSettingsWhereInput> | null
    UserFavorite?: UserFavoriteListRelationFilter
    userLoginLogs?: UserLoginLogListRelationFilter
    suggestions?: SuggestionListRelationFilter
    priceAlerts?: PriceAlertListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    DefaultMT5Account?: DefaultMT5AccountOrderByWithRelationInput
    deposits?: DepositOrderByRelationAggregateInput
    kyc?: KYCOrderByWithRelationInput
    mt5Accounts?: MT5AccountOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    RefreshToken?: RefreshTokenOrderByRelationAggregateInput
    terminalSettings?: TerminalSettingsOrderByWithRelationInput
    UserFavorite?: UserFavoriteOrderByRelationAggregateInput
    userLoginLogs?: UserLoginLogOrderByRelationAggregateInput
    suggestions?: SuggestionOrderByRelationAggregateInput
    priceAlerts?: PriceAlertOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    DefaultMT5Account?: XOR<DefaultMT5AccountNullableScalarRelationFilter, DefaultMT5AccountWhereInput> | null
    deposits?: DepositListRelationFilter
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    mt5Accounts?: MT5AccountListRelationFilter
    notifications?: NotificationListRelationFilter
    RefreshToken?: RefreshTokenListRelationFilter
    terminalSettings?: XOR<TerminalSettingsNullableScalarRelationFilter, TerminalSettingsWhereInput> | null
    UserFavorite?: UserFavoriteListRelationFilter
    userLoginLogs?: UserLoginLogListRelationFilter
    suggestions?: SuggestionListRelationFilter
    priceAlerts?: PriceAlertListRelationFilter
  }, "id" | "clientId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    clientId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableListFilter<"User">
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type KYCWhereInput = {
    AND?: KYCWhereInput | KYCWhereInput[]
    OR?: KYCWhereInput[]
    NOT?: KYCWhereInput | KYCWhereInput[]
    id?: StringFilter<"KYC"> | string
    isDocumentVerified?: BoolFilter<"KYC"> | boolean
    isAddressVerified?: BoolFilter<"KYC"> | boolean
    verificationStatus?: StringFilter<"KYC"> | string
    documentReference?: StringNullableFilter<"KYC"> | string | null
    addressReference?: StringNullableFilter<"KYC"> | string | null
    amlReference?: StringNullableFilter<"KYC"> | string | null
    documentSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    addressSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    rejectionReason?: StringNullableFilter<"KYC"> | string | null
    createdAt?: DateTimeFilter<"KYC"> | Date | string
    updatedAt?: DateTimeFilter<"KYC"> | Date | string
    userId?: StringFilter<"KYC"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KYCOrderByWithRelationInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrderInput | SortOrder
    addressReference?: SortOrderInput | SortOrder
    amlReference?: SortOrderInput | SortOrder
    documentSubmittedAt?: SortOrderInput | SortOrder
    addressSubmittedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type KYCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: KYCWhereInput | KYCWhereInput[]
    OR?: KYCWhereInput[]
    NOT?: KYCWhereInput | KYCWhereInput[]
    isDocumentVerified?: BoolFilter<"KYC"> | boolean
    isAddressVerified?: BoolFilter<"KYC"> | boolean
    verificationStatus?: StringFilter<"KYC"> | string
    documentReference?: StringNullableFilter<"KYC"> | string | null
    addressReference?: StringNullableFilter<"KYC"> | string | null
    amlReference?: StringNullableFilter<"KYC"> | string | null
    documentSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    addressSubmittedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    rejectionReason?: StringNullableFilter<"KYC"> | string | null
    createdAt?: DateTimeFilter<"KYC"> | Date | string
    updatedAt?: DateTimeFilter<"KYC"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type KYCOrderByWithAggregationInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrderInput | SortOrder
    addressReference?: SortOrderInput | SortOrder
    amlReference?: SortOrderInput | SortOrder
    documentSubmittedAt?: SortOrderInput | SortOrder
    addressSubmittedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: KYCCountOrderByAggregateInput
    _max?: KYCMaxOrderByAggregateInput
    _min?: KYCMinOrderByAggregateInput
  }

  export type KYCScalarWhereWithAggregatesInput = {
    AND?: KYCScalarWhereWithAggregatesInput | KYCScalarWhereWithAggregatesInput[]
    OR?: KYCScalarWhereWithAggregatesInput[]
    NOT?: KYCScalarWhereWithAggregatesInput | KYCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYC"> | string
    isDocumentVerified?: BoolWithAggregatesFilter<"KYC"> | boolean
    isAddressVerified?: BoolWithAggregatesFilter<"KYC"> | boolean
    verificationStatus?: StringWithAggregatesFilter<"KYC"> | string
    documentReference?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    addressReference?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    amlReference?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    documentSubmittedAt?: DateTimeNullableWithAggregatesFilter<"KYC"> | Date | string | null
    addressSubmittedAt?: DateTimeNullableWithAggregatesFilter<"KYC"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KYC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KYC"> | Date | string
    userId?: StringWithAggregatesFilter<"KYC"> | string
  }

  export type MT5AccountWhereInput = {
    AND?: MT5AccountWhereInput | MT5AccountWhereInput[]
    OR?: MT5AccountWhereInput[]
    NOT?: MT5AccountWhereInput | MT5AccountWhereInput[]
    id?: StringFilter<"MT5Account"> | string
    accountId?: StringFilter<"MT5Account"> | string
    userId?: StringNullableFilter<"MT5Account"> | string | null
    accountType?: StringFilter<"MT5Account"> | string
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    leverage?: IntNullableFilter<"MT5Account"> | number | null
    nameOnAccount?: StringNullableFilter<"MT5Account"> | string | null
    package?: StringNullableFilter<"MT5Account"> | string | null
    group?: StringNullableFilter<"MT5Account"> | string | null
    balance?: FloatNullableFilter<"MT5Account"> | number | null
    credit?: FloatNullableFilter<"MT5Account"> | number | null
    currency?: StringNullableFilter<"MT5Account"> | string | null
    equity?: FloatNullableFilter<"MT5Account"> | number | null
    lastSyncedAt?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    margin?: FloatNullableFilter<"MT5Account"> | number | null
    marginFree?: FloatNullableFilter<"MT5Account"> | number | null
    marginLevel?: FloatNullableFilter<"MT5Account"> | number | null
    profit?: FloatNullableFilter<"MT5Account"> | number | null
    archived?: BoolFilter<"MT5Account"> | boolean
    archived_at?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountListRelationFilter
    deposits?: DepositListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mt5Transactions?: MT5TransactionListRelationFilter
    UserFavorite?: UserFavoriteListRelationFilter
  }

  export type MT5AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrderInput | SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    leverage?: SortOrderInput | SortOrder
    nameOnAccount?: SortOrderInput | SortOrder
    package?: SortOrderInput | SortOrder
    group?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    margin?: SortOrderInput | SortOrder
    marginFree?: SortOrderInput | SortOrder
    marginLevel?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    archived?: SortOrder
    archived_at?: SortOrderInput | SortOrder
    DefaultMT5Account?: DefaultMT5AccountOrderByRelationAggregateInput
    deposits?: DepositOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    mt5Transactions?: MT5TransactionOrderByRelationAggregateInput
    UserFavorite?: UserFavoriteOrderByRelationAggregateInput
  }

  export type MT5AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: MT5AccountWhereInput | MT5AccountWhereInput[]
    OR?: MT5AccountWhereInput[]
    NOT?: MT5AccountWhereInput | MT5AccountWhereInput[]
    userId?: StringNullableFilter<"MT5Account"> | string | null
    accountType?: StringFilter<"MT5Account"> | string
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    leverage?: IntNullableFilter<"MT5Account"> | number | null
    nameOnAccount?: StringNullableFilter<"MT5Account"> | string | null
    package?: StringNullableFilter<"MT5Account"> | string | null
    group?: StringNullableFilter<"MT5Account"> | string | null
    balance?: FloatNullableFilter<"MT5Account"> | number | null
    credit?: FloatNullableFilter<"MT5Account"> | number | null
    currency?: StringNullableFilter<"MT5Account"> | string | null
    equity?: FloatNullableFilter<"MT5Account"> | number | null
    lastSyncedAt?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    margin?: FloatNullableFilter<"MT5Account"> | number | null
    marginFree?: FloatNullableFilter<"MT5Account"> | number | null
    marginLevel?: FloatNullableFilter<"MT5Account"> | number | null
    profit?: FloatNullableFilter<"MT5Account"> | number | null
    archived?: BoolFilter<"MT5Account"> | boolean
    archived_at?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountListRelationFilter
    deposits?: DepositListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mt5Transactions?: MT5TransactionListRelationFilter
    UserFavorite?: UserFavoriteListRelationFilter
  }, "id" | "accountId">

  export type MT5AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrderInput | SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    leverage?: SortOrderInput | SortOrder
    nameOnAccount?: SortOrderInput | SortOrder
    package?: SortOrderInput | SortOrder
    group?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    equity?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    margin?: SortOrderInput | SortOrder
    marginFree?: SortOrderInput | SortOrder
    marginLevel?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    archived?: SortOrder
    archived_at?: SortOrderInput | SortOrder
    _count?: MT5AccountCountOrderByAggregateInput
    _avg?: MT5AccountAvgOrderByAggregateInput
    _max?: MT5AccountMaxOrderByAggregateInput
    _min?: MT5AccountMinOrderByAggregateInput
    _sum?: MT5AccountSumOrderByAggregateInput
  }

  export type MT5AccountScalarWhereWithAggregatesInput = {
    AND?: MT5AccountScalarWhereWithAggregatesInput | MT5AccountScalarWhereWithAggregatesInput[]
    OR?: MT5AccountScalarWhereWithAggregatesInput[]
    NOT?: MT5AccountScalarWhereWithAggregatesInput | MT5AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MT5Account"> | string
    accountId?: StringWithAggregatesFilter<"MT5Account"> | string
    userId?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    accountType?: StringWithAggregatesFilter<"MT5Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MT5Account"> | Date | string
    password?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    leverage?: IntNullableWithAggregatesFilter<"MT5Account"> | number | null
    nameOnAccount?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    package?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    group?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    balance?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    credit?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    currency?: StringNullableWithAggregatesFilter<"MT5Account"> | string | null
    equity?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"MT5Account"> | Date | string | null
    margin?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    marginFree?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    marginLevel?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    profit?: FloatNullableWithAggregatesFilter<"MT5Account"> | number | null
    archived?: BoolWithAggregatesFilter<"MT5Account"> | boolean
    archived_at?: DateTimeNullableWithAggregatesFilter<"MT5Account"> | Date | string | null
  }

  export type MT5TransactionWhereInput = {
    AND?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    OR?: MT5TransactionWhereInput[]
    NOT?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    id?: StringFilter<"MT5Transaction"> | string
    type?: StringFilter<"MT5Transaction"> | string
    amount?: FloatFilter<"MT5Transaction"> | number
    status?: StringNullableFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableFilter<"MT5Transaction"> | string | null
    comment?: StringNullableFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"MT5Transaction"> | string | null
    userId?: StringNullableFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
  }

  export type MT5TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    mt5Account?: MT5AccountOrderByWithRelationInput
  }

  export type MT5TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    OR?: MT5TransactionWhereInput[]
    NOT?: MT5TransactionWhereInput | MT5TransactionWhereInput[]
    type?: StringFilter<"MT5Transaction"> | string
    amount?: FloatFilter<"MT5Transaction"> | number
    status?: StringNullableFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableFilter<"MT5Transaction"> | string | null
    comment?: StringNullableFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"MT5Transaction"> | string | null
    userId?: StringNullableFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
  }, "id">

  export type MT5TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MT5TransactionCountOrderByAggregateInput
    _avg?: MT5TransactionAvgOrderByAggregateInput
    _max?: MT5TransactionMaxOrderByAggregateInput
    _min?: MT5TransactionMinOrderByAggregateInput
    _sum?: MT5TransactionSumOrderByAggregateInput
  }

  export type MT5TransactionScalarWhereWithAggregatesInput = {
    AND?: MT5TransactionScalarWhereWithAggregatesInput | MT5TransactionScalarWhereWithAggregatesInput[]
    OR?: MT5TransactionScalarWhereWithAggregatesInput[]
    NOT?: MT5TransactionScalarWhereWithAggregatesInput | MT5TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MT5Transaction"> | string
    type?: StringWithAggregatesFilter<"MT5Transaction"> | string
    amount?: FloatWithAggregatesFilter<"MT5Transaction"> | number
    status?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    comment?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringWithAggregatesFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    userId?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableWithAggregatesFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MT5Transaction"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountType?: StringFilter<"Account"> | string
    balance?: FloatFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountType?: StringFilter<"Account"> | string
    balance?: FloatFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountType?: StringWithAggregatesFilter<"Account"> | string
    balance?: FloatWithAggregatesFilter<"Account"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type DepositWhereInput = {
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    id?: StringFilter<"Deposit"> | string
    userId?: StringFilter<"Deposit"> | string
    mt5AccountId?: StringFilter<"Deposit"> | string
    amount?: FloatFilter<"Deposit"> | number
    currency?: StringFilter<"Deposit"> | string
    method?: StringFilter<"Deposit"> | string
    paymentMethod?: StringNullableFilter<"Deposit"> | string | null
    transactionHash?: StringNullableFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableFilter<"Deposit"> | string | null
    bankDetails?: StringNullableFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableFilter<"Deposit"> | string | null
    depositAddress?: StringNullableFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    rejectionReason?: StringNullableFilter<"Deposit"> | string | null
    approvedBy?: StringNullableFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cregisDeposit?: XOR<CregisDepositNullableScalarRelationFilter, CregisDepositWhereInput> | null
  }

  export type DepositOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    proofFileUrl?: SortOrderInput | SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    depositAddress?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mt5Account?: MT5AccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    cregisDeposit?: CregisDepositOrderByWithRelationInput
  }

  export type DepositWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepositWhereInput | DepositWhereInput[]
    OR?: DepositWhereInput[]
    NOT?: DepositWhereInput | DepositWhereInput[]
    userId?: StringFilter<"Deposit"> | string
    mt5AccountId?: StringFilter<"Deposit"> | string
    amount?: FloatFilter<"Deposit"> | number
    currency?: StringFilter<"Deposit"> | string
    method?: StringFilter<"Deposit"> | string
    paymentMethod?: StringNullableFilter<"Deposit"> | string | null
    transactionHash?: StringNullableFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableFilter<"Deposit"> | string | null
    bankDetails?: StringNullableFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableFilter<"Deposit"> | string | null
    depositAddress?: StringNullableFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    rejectionReason?: StringNullableFilter<"Deposit"> | string | null
    approvedBy?: StringNullableFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
    mt5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cregisDeposit?: XOR<CregisDepositNullableScalarRelationFilter, CregisDepositWhereInput> | null
  }, "id">

  export type DepositOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    proofFileUrl?: SortOrderInput | SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    depositAddress?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepositCountOrderByAggregateInput
    _avg?: DepositAvgOrderByAggregateInput
    _max?: DepositMaxOrderByAggregateInput
    _min?: DepositMinOrderByAggregateInput
    _sum?: DepositSumOrderByAggregateInput
  }

  export type DepositScalarWhereWithAggregatesInput = {
    AND?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    OR?: DepositScalarWhereWithAggregatesInput[]
    NOT?: DepositScalarWhereWithAggregatesInput | DepositScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deposit"> | string
    userId?: StringWithAggregatesFilter<"Deposit"> | string
    mt5AccountId?: StringWithAggregatesFilter<"Deposit"> | string
    amount?: FloatWithAggregatesFilter<"Deposit"> | number
    currency?: StringWithAggregatesFilter<"Deposit"> | string
    method?: StringWithAggregatesFilter<"Deposit"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    transactionHash?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    bankDetails?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    depositAddress?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    status?: StringWithAggregatesFilter<"Deposit"> | string
    rejectionReason?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deposit"> | Date | string
  }

  export type CregisDepositWhereInput = {
    AND?: CregisDepositWhereInput | CregisDepositWhereInput[]
    OR?: CregisDepositWhereInput[]
    NOT?: CregisDepositWhereInput | CregisDepositWhereInput[]
    id?: StringFilter<"CregisDeposit"> | string
    depositId?: StringFilter<"CregisDeposit"> | string
    cregisOrderId?: StringFilter<"CregisDeposit"> | string
    cregisStatus?: StringFilter<"CregisDeposit"> | string
    amount?: FloatFilter<"CregisDeposit"> | number
    currency?: StringFilter<"CregisDeposit"> | string
    paymentUrl?: StringNullableFilter<"CregisDeposit"> | string | null
    qrCodeUrl?: StringNullableFilter<"CregisDeposit"> | string | null
    expiresAt?: DateTimeNullableFilter<"CregisDeposit"> | Date | string | null
    webhookData?: JsonNullableFilter<"CregisDeposit">
    createdAt?: DateTimeFilter<"CregisDeposit"> | Date | string
    updatedAt?: DateTimeFilter<"CregisDeposit"> | Date | string
    deposit?: XOR<DepositScalarRelationFilter, DepositWhereInput>
  }

  export type CregisDepositOrderByWithRelationInput = {
    id?: SortOrder
    depositId?: SortOrder
    cregisOrderId?: SortOrder
    cregisStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentUrl?: SortOrderInput | SortOrder
    qrCodeUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    webhookData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deposit?: DepositOrderByWithRelationInput
  }

  export type CregisDepositWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    depositId?: string
    cregisOrderId?: string
    AND?: CregisDepositWhereInput | CregisDepositWhereInput[]
    OR?: CregisDepositWhereInput[]
    NOT?: CregisDepositWhereInput | CregisDepositWhereInput[]
    cregisStatus?: StringFilter<"CregisDeposit"> | string
    amount?: FloatFilter<"CregisDeposit"> | number
    currency?: StringFilter<"CregisDeposit"> | string
    paymentUrl?: StringNullableFilter<"CregisDeposit"> | string | null
    qrCodeUrl?: StringNullableFilter<"CregisDeposit"> | string | null
    expiresAt?: DateTimeNullableFilter<"CregisDeposit"> | Date | string | null
    webhookData?: JsonNullableFilter<"CregisDeposit">
    createdAt?: DateTimeFilter<"CregisDeposit"> | Date | string
    updatedAt?: DateTimeFilter<"CregisDeposit"> | Date | string
    deposit?: XOR<DepositScalarRelationFilter, DepositWhereInput>
  }, "id" | "depositId" | "cregisOrderId">

  export type CregisDepositOrderByWithAggregationInput = {
    id?: SortOrder
    depositId?: SortOrder
    cregisOrderId?: SortOrder
    cregisStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentUrl?: SortOrderInput | SortOrder
    qrCodeUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    webhookData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CregisDepositCountOrderByAggregateInput
    _avg?: CregisDepositAvgOrderByAggregateInput
    _max?: CregisDepositMaxOrderByAggregateInput
    _min?: CregisDepositMinOrderByAggregateInput
    _sum?: CregisDepositSumOrderByAggregateInput
  }

  export type CregisDepositScalarWhereWithAggregatesInput = {
    AND?: CregisDepositScalarWhereWithAggregatesInput | CregisDepositScalarWhereWithAggregatesInput[]
    OR?: CregisDepositScalarWhereWithAggregatesInput[]
    NOT?: CregisDepositScalarWhereWithAggregatesInput | CregisDepositScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CregisDeposit"> | string
    depositId?: StringWithAggregatesFilter<"CregisDeposit"> | string
    cregisOrderId?: StringWithAggregatesFilter<"CregisDeposit"> | string
    cregisStatus?: StringWithAggregatesFilter<"CregisDeposit"> | string
    amount?: FloatWithAggregatesFilter<"CregisDeposit"> | number
    currency?: StringWithAggregatesFilter<"CregisDeposit"> | string
    paymentUrl?: StringNullableWithAggregatesFilter<"CregisDeposit"> | string | null
    qrCodeUrl?: StringNullableWithAggregatesFilter<"CregisDeposit"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CregisDeposit"> | Date | string | null
    webhookData?: JsonNullableWithAggregatesFilter<"CregisDeposit">
    createdAt?: DateTimeWithAggregatesFilter<"CregisDeposit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CregisDeposit"> | Date | string
  }

  export type WithdrawalWhereInput = {
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    id?: StringFilter<"Withdrawal"> | string
    userId?: StringFilter<"Withdrawal"> | string
    amount?: FloatFilter<"Withdrawal"> | number
    method?: StringFilter<"Withdrawal"> | string
    bankDetails?: StringNullableFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableFilter<"Withdrawal"> | string | null
    status?: StringFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    currency?: StringFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableFilter<"Withdrawal"> | string | null
    walletId?: StringNullableFilter<"Withdrawal"> | string | null
    mt5AccountId?: StringNullableFilter<"Withdrawal"> | string | null
  }

  export type WithdrawalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    walletId?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrderInput | SortOrder
  }

  export type WithdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WithdrawalWhereInput | WithdrawalWhereInput[]
    OR?: WithdrawalWhereInput[]
    NOT?: WithdrawalWhereInput | WithdrawalWhereInput[]
    userId?: StringFilter<"Withdrawal"> | string
    amount?: FloatFilter<"Withdrawal"> | number
    method?: StringFilter<"Withdrawal"> | string
    bankDetails?: StringNullableFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableFilter<"Withdrawal"> | string | null
    status?: StringFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeFilter<"Withdrawal"> | Date | string
    currency?: StringFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableFilter<"Withdrawal"> | string | null
    walletId?: StringNullableFilter<"Withdrawal"> | string | null
    mt5AccountId?: StringNullableFilter<"Withdrawal"> | string | null
  }, "id">

  export type WithdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrderInput | SortOrder
    cryptoAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    walletId?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrderInput | SortOrder
    _count?: WithdrawalCountOrderByAggregateInput
    _avg?: WithdrawalAvgOrderByAggregateInput
    _max?: WithdrawalMaxOrderByAggregateInput
    _min?: WithdrawalMinOrderByAggregateInput
    _sum?: WithdrawalSumOrderByAggregateInput
  }

  export type WithdrawalScalarWhereWithAggregatesInput = {
    AND?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    OR?: WithdrawalScalarWhereWithAggregatesInput[]
    NOT?: WithdrawalScalarWhereWithAggregatesInput | WithdrawalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Withdrawal"> | string
    userId?: StringWithAggregatesFilter<"Withdrawal"> | string
    amount?: FloatWithAggregatesFilter<"Withdrawal"> | number
    method?: StringWithAggregatesFilter<"Withdrawal"> | string
    bankDetails?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    cryptoAddress?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    status?: StringWithAggregatesFilter<"Withdrawal"> | string
    rejectionReason?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Withdrawal"> | Date | string
    currency?: StringWithAggregatesFilter<"Withdrawal"> | string
    externalTransactionId?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Withdrawal"> | Date | string | null
    walletAddress?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    walletId?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
    mt5AccountId?: StringNullableWithAggregatesFilter<"Withdrawal"> | string | null
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    balance?: FloatFilter<"Wallet"> | number
    currency?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    walletNumber?: StringNullableFilter<"Wallet"> | string | null
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletNumber?: SortOrderInput | SortOrder
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: FloatFilter<"Wallet"> | number
    currency?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    walletNumber?: StringNullableFilter<"Wallet"> | string | null
  }, "id" | "userId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletNumber?: SortOrderInput | SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: FloatWithAggregatesFilter<"Wallet"> | number
    currency?: StringWithAggregatesFilter<"Wallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    walletNumber?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    userId?: StringFilter<"WalletTransaction"> | string
    type?: StringFilter<"WalletTransaction"> | string
    amount?: FloatFilter<"WalletTransaction"> | number
    status?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    mt5AccountId?: StringNullableFilter<"WalletTransaction"> | string | null
    withdrawalId?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    walletId?: StringFilter<"WalletTransaction"> | string
    userId?: StringFilter<"WalletTransaction"> | string
    type?: StringFilter<"WalletTransaction"> | string
    amount?: FloatFilter<"WalletTransaction"> | number
    status?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    mt5AccountId?: StringNullableFilter<"WalletTransaction"> | string | null
    withdrawalId?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }, "id">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    mt5AccountId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    userId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    type?: StringWithAggregatesFilter<"WalletTransaction"> | string
    amount?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    status?: StringWithAggregatesFilter<"WalletTransaction"> | string
    description?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    mt5AccountId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    withdrawalId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableFilter<"ActivityLog"> | string | null
    newValues?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableFilter<"ActivityLog"> | string | null
    newValues?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    adminId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    entity?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    newValues?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    category?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    permissions?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    permissions?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    permissions?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    userId?: StringFilter<"PaymentMethod"> | string
    address?: StringNullableFilter<"PaymentMethod"> | string | null
    currency?: StringFilter<"PaymentMethod"> | string
    network?: StringFilter<"PaymentMethod"> | string
    status?: StringFilter<"PaymentMethod"> | string
    submittedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    approvedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    rejectionReason?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    methodType?: StringFilter<"PaymentMethod"> | string
    bankName?: StringNullableFilter<"PaymentMethod"> | string | null
    accountName?: StringNullableFilter<"PaymentMethod"> | string | null
    accountNumber?: StringNullableFilter<"PaymentMethod"> | string | null
    ifscSwiftCode?: StringNullableFilter<"PaymentMethod"> | string | null
    accountType?: StringNullableFilter<"PaymentMethod"> | string | null
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrderInput | SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    methodType?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscSwiftCode?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    userId?: StringFilter<"PaymentMethod"> | string
    address?: StringNullableFilter<"PaymentMethod"> | string | null
    currency?: StringFilter<"PaymentMethod"> | string
    network?: StringFilter<"PaymentMethod"> | string
    status?: StringFilter<"PaymentMethod"> | string
    submittedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    approvedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    approvedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    rejectionReason?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    methodType?: StringFilter<"PaymentMethod"> | string
    bankName?: StringNullableFilter<"PaymentMethod"> | string | null
    accountName?: StringNullableFilter<"PaymentMethod"> | string | null
    accountNumber?: StringNullableFilter<"PaymentMethod"> | string | null
    ifscSwiftCode?: StringNullableFilter<"PaymentMethod"> | string | null
    accountType?: StringNullableFilter<"PaymentMethod"> | string | null
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrderInput | SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    methodType?: SortOrder
    bankName?: SortOrderInput | SortOrder
    accountName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscSwiftCode?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    userId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    address?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    currency?: StringWithAggregatesFilter<"PaymentMethod"> | string
    network?: StringWithAggregatesFilter<"PaymentMethod"> | string
    status?: StringWithAggregatesFilter<"PaymentMethod"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMethod"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    methodType?: StringWithAggregatesFilter<"PaymentMethod"> | string
    bankName?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    accountName?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    ifscSwiftCode?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    accountType?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringFilter<"UserRole"> | string
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: StringFilter<"UserRole"> | string
  }, "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    assignedBy?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type DefaultMT5AccountWhereInput = {
    AND?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    OR?: DefaultMT5AccountWhereInput[]
    NOT?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    id?: StringFilter<"DefaultMT5Account"> | string
    userId?: StringFilter<"DefaultMT5Account"> | string
    mt5AccountId?: StringFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    MT5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DefaultMT5AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    MT5Account?: MT5AccountOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DefaultMT5AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    OR?: DefaultMT5AccountWhereInput[]
    NOT?: DefaultMT5AccountWhereInput | DefaultMT5AccountWhereInput[]
    mt5AccountId?: StringFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    MT5Account?: XOR<MT5AccountScalarRelationFilter, MT5AccountWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DefaultMT5AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DefaultMT5AccountCountOrderByAggregateInput
    _max?: DefaultMT5AccountMaxOrderByAggregateInput
    _min?: DefaultMT5AccountMinOrderByAggregateInput
  }

  export type DefaultMT5AccountScalarWhereWithAggregatesInput = {
    AND?: DefaultMT5AccountScalarWhereWithAggregatesInput | DefaultMT5AccountScalarWhereWithAggregatesInput[]
    OR?: DefaultMT5AccountScalarWhereWithAggregatesInput[]
    NOT?: DefaultMT5AccountScalarWhereWithAggregatesInput | DefaultMT5AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DefaultMT5Account"> | string
    userId?: StringWithAggregatesFilter<"DefaultMT5Account"> | string
    mt5AccountId?: StringWithAggregatesFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DefaultMT5Account"> | Date | string
  }

  export type InstrumentWhereInput = {
    AND?: InstrumentWhereInput | InstrumentWhereInput[]
    OR?: InstrumentWhereInput[]
    NOT?: InstrumentWhereInput | InstrumentWhereInput[]
    id?: StringFilter<"Instrument"> | string
    symbol?: StringFilter<"Instrument"> | string
    name?: StringNullableFilter<"Instrument"> | string | null
    description?: StringNullableFilter<"Instrument"> | string | null
    category?: StringFilter<"Instrument"> | string
    group?: StringNullableFilter<"Instrument"> | string | null
    digits?: IntFilter<"Instrument"> | number
    contractSize?: FloatFilter<"Instrument"> | number
    minVolume?: FloatFilter<"Instrument"> | number
    maxVolume?: FloatFilter<"Instrument"> | number
    volumeStep?: FloatFilter<"Instrument"> | number
    spread?: FloatFilter<"Instrument"> | number
    isActive?: BoolFilter<"Instrument"> | boolean
    tradingHours?: StringNullableFilter<"Instrument"> | string | null
    lastUpdated?: DateTimeFilter<"Instrument"> | Date | string
    createdAt?: DateTimeFilter<"Instrument"> | Date | string
    updatedAt?: DateTimeFilter<"Instrument"> | Date | string
    path?: StringNullableFilter<"Instrument"> | string | null
    accountGroup?: StringNullableFilter<"Instrument"> | string | null
    isin?: StringNullableFilter<"Instrument"> | string | null
    sector?: IntNullableFilter<"Instrument"> | number | null
    industry?: IntNullableFilter<"Instrument"> | number | null
    country?: StringNullableFilter<"Instrument"> | string | null
    currency?: StringNullableFilter<"Instrument"> | string | null
    currencyProfit?: StringNullableFilter<"Instrument"> | string | null
    currencyMargin?: StringNullableFilter<"Instrument"> | string | null
    point?: FloatNullableFilter<"Instrument"> | number | null
    multiply?: IntNullableFilter<"Instrument"> | number | null
    tickSize?: FloatNullableFilter<"Instrument"> | number | null
    tickValue?: FloatNullableFilter<"Instrument"> | number | null
    volumeLimit?: FloatNullableFilter<"Instrument"> | number | null
    marginInitial?: FloatNullableFilter<"Instrument"> | number | null
    marginMaintenance?: FloatNullableFilter<"Instrument"> | number | null
    tradeMode?: IntNullableFilter<"Instrument"> | number | null
    tradeFlags?: IntNullableFilter<"Instrument"> | number | null
    calcMode?: IntNullableFilter<"Instrument"> | number | null
    execMode?: IntNullableFilter<"Instrument"> | number | null
    swapLong?: FloatNullableFilter<"Instrument"> | number | null
    swapShort?: FloatNullableFilter<"Instrument"> | number | null
    swapMode?: IntNullableFilter<"Instrument"> | number | null
    UserFavorite?: UserFavoriteListRelationFilter
  }

  export type InstrumentOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    group?: SortOrderInput | SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    path?: SortOrderInput | SortOrder
    accountGroup?: SortOrderInput | SortOrder
    isin?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    currencyProfit?: SortOrderInput | SortOrder
    currencyMargin?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    multiply?: SortOrderInput | SortOrder
    tickSize?: SortOrderInput | SortOrder
    tickValue?: SortOrderInput | SortOrder
    volumeLimit?: SortOrderInput | SortOrder
    marginInitial?: SortOrderInput | SortOrder
    marginMaintenance?: SortOrderInput | SortOrder
    tradeMode?: SortOrderInput | SortOrder
    tradeFlags?: SortOrderInput | SortOrder
    calcMode?: SortOrderInput | SortOrder
    execMode?: SortOrderInput | SortOrder
    swapLong?: SortOrderInput | SortOrder
    swapShort?: SortOrderInput | SortOrder
    swapMode?: SortOrderInput | SortOrder
    UserFavorite?: UserFavoriteOrderByRelationAggregateInput
  }

  export type InstrumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol?: string
    AND?: InstrumentWhereInput | InstrumentWhereInput[]
    OR?: InstrumentWhereInput[]
    NOT?: InstrumentWhereInput | InstrumentWhereInput[]
    name?: StringNullableFilter<"Instrument"> | string | null
    description?: StringNullableFilter<"Instrument"> | string | null
    category?: StringFilter<"Instrument"> | string
    group?: StringNullableFilter<"Instrument"> | string | null
    digits?: IntFilter<"Instrument"> | number
    contractSize?: FloatFilter<"Instrument"> | number
    minVolume?: FloatFilter<"Instrument"> | number
    maxVolume?: FloatFilter<"Instrument"> | number
    volumeStep?: FloatFilter<"Instrument"> | number
    spread?: FloatFilter<"Instrument"> | number
    isActive?: BoolFilter<"Instrument"> | boolean
    tradingHours?: StringNullableFilter<"Instrument"> | string | null
    lastUpdated?: DateTimeFilter<"Instrument"> | Date | string
    createdAt?: DateTimeFilter<"Instrument"> | Date | string
    updatedAt?: DateTimeFilter<"Instrument"> | Date | string
    path?: StringNullableFilter<"Instrument"> | string | null
    accountGroup?: StringNullableFilter<"Instrument"> | string | null
    isin?: StringNullableFilter<"Instrument"> | string | null
    sector?: IntNullableFilter<"Instrument"> | number | null
    industry?: IntNullableFilter<"Instrument"> | number | null
    country?: StringNullableFilter<"Instrument"> | string | null
    currency?: StringNullableFilter<"Instrument"> | string | null
    currencyProfit?: StringNullableFilter<"Instrument"> | string | null
    currencyMargin?: StringNullableFilter<"Instrument"> | string | null
    point?: FloatNullableFilter<"Instrument"> | number | null
    multiply?: IntNullableFilter<"Instrument"> | number | null
    tickSize?: FloatNullableFilter<"Instrument"> | number | null
    tickValue?: FloatNullableFilter<"Instrument"> | number | null
    volumeLimit?: FloatNullableFilter<"Instrument"> | number | null
    marginInitial?: FloatNullableFilter<"Instrument"> | number | null
    marginMaintenance?: FloatNullableFilter<"Instrument"> | number | null
    tradeMode?: IntNullableFilter<"Instrument"> | number | null
    tradeFlags?: IntNullableFilter<"Instrument"> | number | null
    calcMode?: IntNullableFilter<"Instrument"> | number | null
    execMode?: IntNullableFilter<"Instrument"> | number | null
    swapLong?: FloatNullableFilter<"Instrument"> | number | null
    swapShort?: FloatNullableFilter<"Instrument"> | number | null
    swapMode?: IntNullableFilter<"Instrument"> | number | null
    UserFavorite?: UserFavoriteListRelationFilter
  }, "id" | "symbol">

  export type InstrumentOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    group?: SortOrderInput | SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    path?: SortOrderInput | SortOrder
    accountGroup?: SortOrderInput | SortOrder
    isin?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    currencyProfit?: SortOrderInput | SortOrder
    currencyMargin?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    multiply?: SortOrderInput | SortOrder
    tickSize?: SortOrderInput | SortOrder
    tickValue?: SortOrderInput | SortOrder
    volumeLimit?: SortOrderInput | SortOrder
    marginInitial?: SortOrderInput | SortOrder
    marginMaintenance?: SortOrderInput | SortOrder
    tradeMode?: SortOrderInput | SortOrder
    tradeFlags?: SortOrderInput | SortOrder
    calcMode?: SortOrderInput | SortOrder
    execMode?: SortOrderInput | SortOrder
    swapLong?: SortOrderInput | SortOrder
    swapShort?: SortOrderInput | SortOrder
    swapMode?: SortOrderInput | SortOrder
    _count?: InstrumentCountOrderByAggregateInput
    _avg?: InstrumentAvgOrderByAggregateInput
    _max?: InstrumentMaxOrderByAggregateInput
    _min?: InstrumentMinOrderByAggregateInput
    _sum?: InstrumentSumOrderByAggregateInput
  }

  export type InstrumentScalarWhereWithAggregatesInput = {
    AND?: InstrumentScalarWhereWithAggregatesInput | InstrumentScalarWhereWithAggregatesInput[]
    OR?: InstrumentScalarWhereWithAggregatesInput[]
    NOT?: InstrumentScalarWhereWithAggregatesInput | InstrumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instrument"> | string
    symbol?: StringWithAggregatesFilter<"Instrument"> | string
    name?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    description?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    category?: StringWithAggregatesFilter<"Instrument"> | string
    group?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    digits?: IntWithAggregatesFilter<"Instrument"> | number
    contractSize?: FloatWithAggregatesFilter<"Instrument"> | number
    minVolume?: FloatWithAggregatesFilter<"Instrument"> | number
    maxVolume?: FloatWithAggregatesFilter<"Instrument"> | number
    volumeStep?: FloatWithAggregatesFilter<"Instrument"> | number
    spread?: FloatWithAggregatesFilter<"Instrument"> | number
    isActive?: BoolWithAggregatesFilter<"Instrument"> | boolean
    tradingHours?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"Instrument"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Instrument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instrument"> | Date | string
    path?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    accountGroup?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    isin?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    sector?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    industry?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    country?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    currency?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    currencyProfit?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    currencyMargin?: StringNullableWithAggregatesFilter<"Instrument"> | string | null
    point?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    multiply?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    tickSize?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    tickValue?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    volumeLimit?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    marginInitial?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    marginMaintenance?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    tradeMode?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    tradeFlags?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    calcMode?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    execMode?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
    swapLong?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    swapShort?: FloatNullableWithAggregatesFilter<"Instrument"> | number | null
    swapMode?: IntNullableWithAggregatesFilter<"Instrument"> | number | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableFilter<"RefreshToken"> | boolean | null
    deviceName?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    lastActivity?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    revoked?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableFilter<"RefreshToken"> | boolean | null
    deviceName?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    lastActivity?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    revoked?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableWithAggregatesFilter<"RefreshToken"> | boolean | null
    deviceName?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    lastActivity?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type UserFavoriteWhereInput = {
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    id?: StringFilter<"UserFavorite"> | string
    userId?: StringFilter<"UserFavorite"> | string
    instrumentId?: StringFilter<"UserFavorite"> | string
    mt5AccountId?: StringNullableFilter<"UserFavorite"> | string | null
    sortOrder?: IntFilter<"UserFavorite"> | number
    addedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    Instrument?: XOR<InstrumentScalarRelationFilter, InstrumentWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    MT5Account?: XOR<MT5AccountNullableScalarRelationFilter, MT5AccountWhereInput> | null
  }

  export type UserFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    mt5AccountId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
    Instrument?: InstrumentOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    MT5Account?: MT5AccountOrderByWithRelationInput
  }

  export type UserFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_instrumentId_mt5AccountId?: UserFavoriteUserIdInstrumentIdMt5AccountIdCompoundUniqueInput
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    instrumentId?: StringFilter<"UserFavorite"> | string
    mt5AccountId?: StringNullableFilter<"UserFavorite"> | string | null
    sortOrder?: IntFilter<"UserFavorite"> | number
    addedAt?: DateTimeFilter<"UserFavorite"> | Date | string
    Instrument?: XOR<InstrumentScalarRelationFilter, InstrumentWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    MT5Account?: XOR<MT5AccountNullableScalarRelationFilter, MT5AccountWhereInput> | null
  }, "id" | "userId_instrumentId_mt5AccountId">

  export type UserFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    mt5AccountId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
    _count?: UserFavoriteCountOrderByAggregateInput
    _avg?: UserFavoriteAvgOrderByAggregateInput
    _max?: UserFavoriteMaxOrderByAggregateInput
    _min?: UserFavoriteMinOrderByAggregateInput
    _sum?: UserFavoriteSumOrderByAggregateInput
  }

  export type UserFavoriteScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFavorite"> | string
    userId?: StringWithAggregatesFilter<"UserFavorite"> | string
    instrumentId?: StringWithAggregatesFilter<"UserFavorite"> | string
    mt5AccountId?: StringNullableWithAggregatesFilter<"UserFavorite"> | string | null
    sortOrder?: IntWithAggregatesFilter<"UserFavorite"> | number
    addedAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
  }

  export type UserLoginLogWhereInput = {
    AND?: UserLoginLogWhereInput | UserLoginLogWhereInput[]
    OR?: UserLoginLogWhereInput[]
    NOT?: UserLoginLogWhereInput | UserLoginLogWhereInput[]
    id?: StringFilter<"UserLoginLog"> | string
    userId?: StringFilter<"UserLoginLog"> | string
    user_agent?: StringNullableFilter<"UserLoginLog"> | string | null
    device?: StringNullableFilter<"UserLoginLog"> | string | null
    browser?: StringNullableFilter<"UserLoginLog"> | string | null
    success?: BoolFilter<"UserLoginLog"> | boolean
    failure_reason?: StringNullableFilter<"UserLoginLog"> | string | null
    createdAt?: DateTimeFilter<"UserLoginLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLoginLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    success?: SortOrder
    failure_reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLoginLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLoginLogWhereInput | UserLoginLogWhereInput[]
    OR?: UserLoginLogWhereInput[]
    NOT?: UserLoginLogWhereInput | UserLoginLogWhereInput[]
    userId?: StringFilter<"UserLoginLog"> | string
    user_agent?: StringNullableFilter<"UserLoginLog"> | string | null
    device?: StringNullableFilter<"UserLoginLog"> | string | null
    browser?: StringNullableFilter<"UserLoginLog"> | string | null
    success?: BoolFilter<"UserLoginLog"> | boolean
    failure_reason?: StringNullableFilter<"UserLoginLog"> | string | null
    createdAt?: DateTimeFilter<"UserLoginLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserLoginLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    success?: SortOrder
    failure_reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserLoginLogCountOrderByAggregateInput
    _max?: UserLoginLogMaxOrderByAggregateInput
    _min?: UserLoginLogMinOrderByAggregateInput
  }

  export type UserLoginLogScalarWhereWithAggregatesInput = {
    AND?: UserLoginLogScalarWhereWithAggregatesInput | UserLoginLogScalarWhereWithAggregatesInput[]
    OR?: UserLoginLogScalarWhereWithAggregatesInput[]
    NOT?: UserLoginLogScalarWhereWithAggregatesInput | UserLoginLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLoginLog"> | string
    userId?: StringWithAggregatesFilter<"UserLoginLog"> | string
    user_agent?: StringNullableWithAggregatesFilter<"UserLoginLog"> | string | null
    device?: StringNullableWithAggregatesFilter<"UserLoginLog"> | string | null
    browser?: StringNullableWithAggregatesFilter<"UserLoginLog"> | string | null
    success?: BoolWithAggregatesFilter<"UserLoginLog"> | boolean
    failure_reason?: StringNullableWithAggregatesFilter<"UserLoginLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserLoginLog"> | Date | string
  }

  export type TerminalSettingsWhereInput = {
    AND?: TerminalSettingsWhereInput | TerminalSettingsWhereInput[]
    OR?: TerminalSettingsWhereInput[]
    NOT?: TerminalSettingsWhereInput | TerminalSettingsWhereInput[]
    id?: StringFilter<"TerminalSettings"> | string
    userId?: StringFilter<"TerminalSettings"> | string
    showOnChart?: BoolFilter<"TerminalSettings"> | boolean
    showSignals?: BoolFilter<"TerminalSettings"> | boolean
    showHMR?: BoolFilter<"TerminalSettings"> | boolean
    showPriceAlerts?: BoolFilter<"TerminalSettings"> | boolean
    showOpenPositions?: BoolFilter<"TerminalSettings"> | boolean
    showTPSL?: BoolFilter<"TerminalSettings"> | boolean
    showEconomicCalendar?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarHighImpact?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarMiddleImpact?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarLowImpact?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarLowestImpact?: BoolFilter<"TerminalSettings"> | boolean
    priceAlertSound?: BoolFilter<"TerminalSettings"> | boolean
    closingSound?: BoolFilter<"TerminalSettings"> | boolean
    autoTPSL?: BoolFilter<"TerminalSettings"> | boolean
    openOrderMode?: StringFilter<"TerminalSettings"> | string
    priceSource?: StringFilter<"TerminalSettings"> | string
    appearance?: StringFilter<"TerminalSettings"> | string
    timezone?: StringFilter<"TerminalSettings"> | string
    createdAt?: DateTimeFilter<"TerminalSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TerminalSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TerminalSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    showOnChart?: SortOrder
    showSignals?: SortOrder
    showHMR?: SortOrder
    showPriceAlerts?: SortOrder
    showOpenPositions?: SortOrder
    showTPSL?: SortOrder
    showEconomicCalendar?: SortOrder
    economicCalendarHighImpact?: SortOrder
    economicCalendarMiddleImpact?: SortOrder
    economicCalendarLowImpact?: SortOrder
    economicCalendarLowestImpact?: SortOrder
    priceAlertSound?: SortOrder
    closingSound?: SortOrder
    autoTPSL?: SortOrder
    openOrderMode?: SortOrder
    priceSource?: SortOrder
    appearance?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TerminalSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TerminalSettingsWhereInput | TerminalSettingsWhereInput[]
    OR?: TerminalSettingsWhereInput[]
    NOT?: TerminalSettingsWhereInput | TerminalSettingsWhereInput[]
    showOnChart?: BoolFilter<"TerminalSettings"> | boolean
    showSignals?: BoolFilter<"TerminalSettings"> | boolean
    showHMR?: BoolFilter<"TerminalSettings"> | boolean
    showPriceAlerts?: BoolFilter<"TerminalSettings"> | boolean
    showOpenPositions?: BoolFilter<"TerminalSettings"> | boolean
    showTPSL?: BoolFilter<"TerminalSettings"> | boolean
    showEconomicCalendar?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarHighImpact?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarMiddleImpact?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarLowImpact?: BoolFilter<"TerminalSettings"> | boolean
    economicCalendarLowestImpact?: BoolFilter<"TerminalSettings"> | boolean
    priceAlertSound?: BoolFilter<"TerminalSettings"> | boolean
    closingSound?: BoolFilter<"TerminalSettings"> | boolean
    autoTPSL?: BoolFilter<"TerminalSettings"> | boolean
    openOrderMode?: StringFilter<"TerminalSettings"> | string
    priceSource?: StringFilter<"TerminalSettings"> | string
    appearance?: StringFilter<"TerminalSettings"> | string
    timezone?: StringFilter<"TerminalSettings"> | string
    createdAt?: DateTimeFilter<"TerminalSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TerminalSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TerminalSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    showOnChart?: SortOrder
    showSignals?: SortOrder
    showHMR?: SortOrder
    showPriceAlerts?: SortOrder
    showOpenPositions?: SortOrder
    showTPSL?: SortOrder
    showEconomicCalendar?: SortOrder
    economicCalendarHighImpact?: SortOrder
    economicCalendarMiddleImpact?: SortOrder
    economicCalendarLowImpact?: SortOrder
    economicCalendarLowestImpact?: SortOrder
    priceAlertSound?: SortOrder
    closingSound?: SortOrder
    autoTPSL?: SortOrder
    openOrderMode?: SortOrder
    priceSource?: SortOrder
    appearance?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TerminalSettingsCountOrderByAggregateInput
    _max?: TerminalSettingsMaxOrderByAggregateInput
    _min?: TerminalSettingsMinOrderByAggregateInput
  }

  export type TerminalSettingsScalarWhereWithAggregatesInput = {
    AND?: TerminalSettingsScalarWhereWithAggregatesInput | TerminalSettingsScalarWhereWithAggregatesInput[]
    OR?: TerminalSettingsScalarWhereWithAggregatesInput[]
    NOT?: TerminalSettingsScalarWhereWithAggregatesInput | TerminalSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TerminalSettings"> | string
    userId?: StringWithAggregatesFilter<"TerminalSettings"> | string
    showOnChart?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    showSignals?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    showHMR?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    showPriceAlerts?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    showOpenPositions?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    showTPSL?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    showEconomicCalendar?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    economicCalendarHighImpact?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    economicCalendarMiddleImpact?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    economicCalendarLowImpact?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    economicCalendarLowestImpact?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    priceAlertSound?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    closingSound?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    autoTPSL?: BoolWithAggregatesFilter<"TerminalSettings"> | boolean
    openOrderMode?: StringWithAggregatesFilter<"TerminalSettings"> | string
    priceSource?: StringWithAggregatesFilter<"TerminalSettings"> | string
    appearance?: StringWithAggregatesFilter<"TerminalSettings"> | string
    timezone?: StringWithAggregatesFilter<"TerminalSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TerminalSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TerminalSettings"> | Date | string
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    username?: StringFilter<"admin"> | string
    email?: StringFilter<"admin"> | string
    password_hash?: StringFilter<"admin"> | string
    admin_role?: StringNullableFilter<"admin"> | string | null
    is_active?: BoolNullableFilter<"admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"admin"> | number | null
    locked_until?: DateTimeNullableFilter<"admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    admin_login_log?: Admin_login_logListRelationFilter
    balance_operation_history?: Balance_operation_historyListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    admin_login_log?: admin_login_logOrderByRelationAggregateInput
    balance_operation_history?: balance_operation_historyOrderByRelationAggregateInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    password_hash?: StringFilter<"admin"> | string
    admin_role?: StringNullableFilter<"admin"> | string | null
    is_active?: BoolNullableFilter<"admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"admin"> | number | null
    locked_until?: DateTimeNullableFilter<"admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    admin_login_log?: Admin_login_logListRelationFilter
    balance_operation_history?: Balance_operation_historyListRelationFilter
  }, "id" | "username" | "email">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    username?: StringWithAggregatesFilter<"admin"> | string
    email?: StringWithAggregatesFilter<"admin"> | string
    password_hash?: StringWithAggregatesFilter<"admin"> | string
    admin_role?: StringNullableWithAggregatesFilter<"admin"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"admin"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    login_attempts?: IntNullableWithAggregatesFilter<"admin"> | number | null
    locked_until?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
  }

  export type admin_login_logWhereInput = {
    AND?: admin_login_logWhereInput | admin_login_logWhereInput[]
    OR?: admin_login_logWhereInput[]
    NOT?: admin_login_logWhereInput | admin_login_logWhereInput[]
    id?: IntFilter<"admin_login_log"> | number
    admin_id?: IntFilter<"admin_login_log"> | number
    ip_address?: StringFilter<"admin_login_log"> | string
    user_agent?: StringNullableFilter<"admin_login_log"> | string | null
    location?: StringNullableFilter<"admin_login_log"> | string | null
    device?: StringNullableFilter<"admin_login_log"> | string | null
    browser?: StringNullableFilter<"admin_login_log"> | string | null
    os?: StringNullableFilter<"admin_login_log"> | string | null
    success?: BoolFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableFilter<"admin_login_log"> | string | null
    created_at?: DateTimeFilter<"admin_login_log"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }

  export type admin_login_logOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    success?: SortOrder
    failure_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    admin?: adminOrderByWithRelationInput
  }

  export type admin_login_logWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: admin_login_logWhereInput | admin_login_logWhereInput[]
    OR?: admin_login_logWhereInput[]
    NOT?: admin_login_logWhereInput | admin_login_logWhereInput[]
    admin_id?: IntFilter<"admin_login_log"> | number
    ip_address?: StringFilter<"admin_login_log"> | string
    user_agent?: StringNullableFilter<"admin_login_log"> | string | null
    location?: StringNullableFilter<"admin_login_log"> | string | null
    device?: StringNullableFilter<"admin_login_log"> | string | null
    browser?: StringNullableFilter<"admin_login_log"> | string | null
    os?: StringNullableFilter<"admin_login_log"> | string | null
    success?: BoolFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableFilter<"admin_login_log"> | string | null
    created_at?: DateTimeFilter<"admin_login_log"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }, "id">

  export type admin_login_logOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    success?: SortOrder
    failure_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: admin_login_logCountOrderByAggregateInput
    _avg?: admin_login_logAvgOrderByAggregateInput
    _max?: admin_login_logMaxOrderByAggregateInput
    _min?: admin_login_logMinOrderByAggregateInput
    _sum?: admin_login_logSumOrderByAggregateInput
  }

  export type admin_login_logScalarWhereWithAggregatesInput = {
    AND?: admin_login_logScalarWhereWithAggregatesInput | admin_login_logScalarWhereWithAggregatesInput[]
    OR?: admin_login_logScalarWhereWithAggregatesInput[]
    NOT?: admin_login_logScalarWhereWithAggregatesInput | admin_login_logScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin_login_log"> | number
    admin_id?: IntWithAggregatesFilter<"admin_login_log"> | number
    ip_address?: StringWithAggregatesFilter<"admin_login_log"> | string
    user_agent?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    location?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    device?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    browser?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    os?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    success?: BoolWithAggregatesFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableWithAggregatesFilter<"admin_login_log"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"admin_login_log"> | Date | string
  }

  export type balance_operation_historyWhereInput = {
    AND?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    OR?: balance_operation_historyWhereInput[]
    NOT?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    id?: IntFilter<"balance_operation_history"> | number
    admin_id?: IntFilter<"balance_operation_history"> | number
    mt5_login?: StringFilter<"balance_operation_history"> | string
    operation_type?: StringFilter<"balance_operation_history"> | string
    amount?: FloatFilter<"balance_operation_history"> | number
    currency?: StringFilter<"balance_operation_history"> | string
    description?: StringNullableFilter<"balance_operation_history"> | string | null
    status?: StringFilter<"balance_operation_history"> | string
    error_message?: StringNullableFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeFilter<"balance_operation_history"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }

  export type balance_operation_historyOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    admin?: adminOrderByWithRelationInput
  }

  export type balance_operation_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    OR?: balance_operation_historyWhereInput[]
    NOT?: balance_operation_historyWhereInput | balance_operation_historyWhereInput[]
    admin_id?: IntFilter<"balance_operation_history"> | number
    mt5_login?: StringFilter<"balance_operation_history"> | string
    operation_type?: StringFilter<"balance_operation_history"> | string
    amount?: FloatFilter<"balance_operation_history"> | number
    currency?: StringFilter<"balance_operation_history"> | string
    description?: StringNullableFilter<"balance_operation_history"> | string | null
    status?: StringFilter<"balance_operation_history"> | string
    error_message?: StringNullableFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeFilter<"balance_operation_history"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, adminWhereInput>
  }, "id">

  export type balance_operation_historyOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: balance_operation_historyCountOrderByAggregateInput
    _avg?: balance_operation_historyAvgOrderByAggregateInput
    _max?: balance_operation_historyMaxOrderByAggregateInput
    _min?: balance_operation_historyMinOrderByAggregateInput
    _sum?: balance_operation_historySumOrderByAggregateInput
  }

  export type balance_operation_historyScalarWhereWithAggregatesInput = {
    AND?: balance_operation_historyScalarWhereWithAggregatesInput | balance_operation_historyScalarWhereWithAggregatesInput[]
    OR?: balance_operation_historyScalarWhereWithAggregatesInput[]
    NOT?: balance_operation_historyScalarWhereWithAggregatesInput | balance_operation_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"balance_operation_history"> | number
    admin_id?: IntWithAggregatesFilter<"balance_operation_history"> | number
    mt5_login?: StringWithAggregatesFilter<"balance_operation_history"> | string
    operation_type?: StringWithAggregatesFilter<"balance_operation_history"> | string
    amount?: FloatWithAggregatesFilter<"balance_operation_history"> | number
    currency?: StringWithAggregatesFilter<"balance_operation_history"> | string
    description?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    status?: StringWithAggregatesFilter<"balance_operation_history"> | string
    error_message?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"balance_operation_history"> | Date | string
  }

  export type chat_conversationsWhereInput = {
    AND?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    OR?: chat_conversationsWhereInput[]
    NOT?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    id?: IntFilter<"chat_conversations"> | number
    user_id?: StringFilter<"chat_conversations"> | string
    user_name?: StringFilter<"chat_conversations"> | string
    user_email?: StringFilter<"chat_conversations"> | string
    admin_id?: StringNullableFilter<"chat_conversations"> | string | null
    status?: StringNullableFilter<"chat_conversations"> | string | null
    priority?: StringNullableFilter<"chat_conversations"> | string | null
    subject?: StringNullableFilter<"chat_conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_by?: StringNullableFilter<"chat_conversations"> | string | null
    tags?: StringNullableListFilter<"chat_conversations">
    unread_count_admin?: IntNullableFilter<"chat_conversations"> | number | null
    unread_count_user?: IntNullableFilter<"chat_conversations"> | number | null
    chat_messages?: Chat_messagesListRelationFilter
    chat_participants?: Chat_participantsListRelationFilter
  }

  export type chat_conversationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    last_message_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
    tags?: SortOrder
    unread_count_admin?: SortOrderInput | SortOrder
    unread_count_user?: SortOrderInput | SortOrder
    chat_messages?: chat_messagesOrderByRelationAggregateInput
    chat_participants?: chat_participantsOrderByRelationAggregateInput
  }

  export type chat_conversationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    OR?: chat_conversationsWhereInput[]
    NOT?: chat_conversationsWhereInput | chat_conversationsWhereInput[]
    user_id?: StringFilter<"chat_conversations"> | string
    user_name?: StringFilter<"chat_conversations"> | string
    user_email?: StringFilter<"chat_conversations"> | string
    admin_id?: StringNullableFilter<"chat_conversations"> | string | null
    status?: StringNullableFilter<"chat_conversations"> | string | null
    priority?: StringNullableFilter<"chat_conversations"> | string | null
    subject?: StringNullableFilter<"chat_conversations"> | string | null
    last_message_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"chat_conversations"> | Date | string | null
    closed_by?: StringNullableFilter<"chat_conversations"> | string | null
    tags?: StringNullableListFilter<"chat_conversations">
    unread_count_admin?: IntNullableFilter<"chat_conversations"> | number | null
    unread_count_user?: IntNullableFilter<"chat_conversations"> | number | null
    chat_messages?: Chat_messagesListRelationFilter
    chat_participants?: Chat_participantsListRelationFilter
  }, "id">

  export type chat_conversationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    last_message_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
    tags?: SortOrder
    unread_count_admin?: SortOrderInput | SortOrder
    unread_count_user?: SortOrderInput | SortOrder
    _count?: chat_conversationsCountOrderByAggregateInput
    _avg?: chat_conversationsAvgOrderByAggregateInput
    _max?: chat_conversationsMaxOrderByAggregateInput
    _min?: chat_conversationsMinOrderByAggregateInput
    _sum?: chat_conversationsSumOrderByAggregateInput
  }

  export type chat_conversationsScalarWhereWithAggregatesInput = {
    AND?: chat_conversationsScalarWhereWithAggregatesInput | chat_conversationsScalarWhereWithAggregatesInput[]
    OR?: chat_conversationsScalarWhereWithAggregatesInput[]
    NOT?: chat_conversationsScalarWhereWithAggregatesInput | chat_conversationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_conversations"> | number
    user_id?: StringWithAggregatesFilter<"chat_conversations"> | string
    user_name?: StringWithAggregatesFilter<"chat_conversations"> | string
    user_email?: StringWithAggregatesFilter<"chat_conversations"> | string
    admin_id?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    status?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    priority?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    subject?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    last_message_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    closed_at?: DateTimeNullableWithAggregatesFilter<"chat_conversations"> | Date | string | null
    closed_by?: StringNullableWithAggregatesFilter<"chat_conversations"> | string | null
    tags?: StringNullableListFilter<"chat_conversations">
    unread_count_admin?: IntNullableWithAggregatesFilter<"chat_conversations"> | number | null
    unread_count_user?: IntNullableWithAggregatesFilter<"chat_conversations"> | number | null
  }

  export type chat_messagesWhereInput = {
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    id?: IntFilter<"chat_messages"> | number
    conversation_id?: IntNullableFilter<"chat_messages"> | number | null
    sender_id?: StringFilter<"chat_messages"> | string
    sender_name?: StringFilter<"chat_messages"> | string
    sender_type?: StringFilter<"chat_messages"> | string
    message_type?: StringNullableFilter<"chat_messages"> | string | null
    content?: StringFilter<"chat_messages"> | string
    metadata?: JsonNullableFilter<"chat_messages">
    is_read?: BoolNullableFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }

  export type chat_messagesOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    chat_conversations?: chat_conversationsOrderByWithRelationInput
  }

  export type chat_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chat_messagesWhereInput | chat_messagesWhereInput[]
    OR?: chat_messagesWhereInput[]
    NOT?: chat_messagesWhereInput | chat_messagesWhereInput[]
    conversation_id?: IntNullableFilter<"chat_messages"> | number | null
    sender_id?: StringFilter<"chat_messages"> | string
    sender_name?: StringFilter<"chat_messages"> | string
    sender_type?: StringFilter<"chat_messages"> | string
    message_type?: StringNullableFilter<"chat_messages"> | string | null
    content?: StringFilter<"chat_messages"> | string
    metadata?: JsonNullableFilter<"chat_messages">
    is_read?: BoolNullableFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }, "id">

  export type chat_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    is_read?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: chat_messagesCountOrderByAggregateInput
    _avg?: chat_messagesAvgOrderByAggregateInput
    _max?: chat_messagesMaxOrderByAggregateInput
    _min?: chat_messagesMinOrderByAggregateInput
    _sum?: chat_messagesSumOrderByAggregateInput
  }

  export type chat_messagesScalarWhereWithAggregatesInput = {
    AND?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    OR?: chat_messagesScalarWhereWithAggregatesInput[]
    NOT?: chat_messagesScalarWhereWithAggregatesInput | chat_messagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_messages"> | number
    conversation_id?: IntNullableWithAggregatesFilter<"chat_messages"> | number | null
    sender_id?: StringWithAggregatesFilter<"chat_messages"> | string
    sender_name?: StringWithAggregatesFilter<"chat_messages"> | string
    sender_type?: StringWithAggregatesFilter<"chat_messages"> | string
    message_type?: StringNullableWithAggregatesFilter<"chat_messages"> | string | null
    content?: StringWithAggregatesFilter<"chat_messages"> | string
    metadata?: JsonNullableWithAggregatesFilter<"chat_messages">
    is_read?: BoolNullableWithAggregatesFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableWithAggregatesFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"chat_messages"> | Date | string | null
  }

  export type chat_participantsWhereInput = {
    AND?: chat_participantsWhereInput | chat_participantsWhereInput[]
    OR?: chat_participantsWhereInput[]
    NOT?: chat_participantsWhereInput | chat_participantsWhereInput[]
    id?: IntFilter<"chat_participants"> | number
    conversation_id?: IntNullableFilter<"chat_participants"> | number | null
    user_id?: StringFilter<"chat_participants"> | string
    user_name?: StringFilter<"chat_participants"> | string
    user_type?: StringFilter<"chat_participants"> | string
    role?: StringNullableFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableFilter<"chat_participants"> | boolean | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }

  export type chat_participantsOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrderInput | SortOrder
    joined_at?: SortOrderInput | SortOrder
    left_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    chat_conversations?: chat_conversationsOrderByWithRelationInput
  }

  export type chat_participantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    conversation_id_user_id?: chat_participantsConversation_idUser_idCompoundUniqueInput
    AND?: chat_participantsWhereInput | chat_participantsWhereInput[]
    OR?: chat_participantsWhereInput[]
    NOT?: chat_participantsWhereInput | chat_participantsWhereInput[]
    conversation_id?: IntNullableFilter<"chat_participants"> | number | null
    user_id?: StringFilter<"chat_participants"> | string
    user_name?: StringFilter<"chat_participants"> | string
    user_type?: StringFilter<"chat_participants"> | string
    role?: StringNullableFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableFilter<"chat_participants"> | boolean | null
    chat_conversations?: XOR<Chat_conversationsNullableScalarRelationFilter, chat_conversationsWhereInput> | null
  }, "id" | "conversation_id_user_id">

  export type chat_participantsOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrderInput | SortOrder
    joined_at?: SortOrderInput | SortOrder
    left_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: chat_participantsCountOrderByAggregateInput
    _avg?: chat_participantsAvgOrderByAggregateInput
    _max?: chat_participantsMaxOrderByAggregateInput
    _min?: chat_participantsMinOrderByAggregateInput
    _sum?: chat_participantsSumOrderByAggregateInput
  }

  export type chat_participantsScalarWhereWithAggregatesInput = {
    AND?: chat_participantsScalarWhereWithAggregatesInput | chat_participantsScalarWhereWithAggregatesInput[]
    OR?: chat_participantsScalarWhereWithAggregatesInput[]
    NOT?: chat_participantsScalarWhereWithAggregatesInput | chat_participantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_participants"> | number
    conversation_id?: IntNullableWithAggregatesFilter<"chat_participants"> | number | null
    user_id?: StringWithAggregatesFilter<"chat_participants"> | string
    user_name?: StringWithAggregatesFilter<"chat_participants"> | string
    user_type?: StringWithAggregatesFilter<"chat_participants"> | string
    role?: StringNullableWithAggregatesFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableWithAggregatesFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableWithAggregatesFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"chat_participants"> | boolean | null
  }

  export type group_commission_structuresWhereInput = {
    AND?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    OR?: group_commission_structuresWhereInput[]
    NOT?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    id?: IntFilter<"group_commission_structures"> | number
    group_id?: StringFilter<"group_commission_structures"> | string
    structure_name?: StringFilter<"group_commission_structures"> | string
    usd_per_lot?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"group_commission_structures"> | boolean
    created_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
    level_order?: IntFilter<"group_commission_structures"> | number
    min_trading_volume?: DecimalNullableFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: DecimalNullableFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: IntNullableFilter<"group_commission_structures"> | number | null
  }

  export type group_commission_structuresOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrderInput | SortOrder
    max_trading_volume?: SortOrderInput | SortOrder
    min_active_clients?: SortOrderInput | SortOrder
  }

  export type group_commission_structuresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    group_id_structure_name?: group_commission_structuresGroup_idStructure_nameCompoundUniqueInput
    group_id_level_order?: group_commission_structuresGroup_idLevel_orderCompoundUniqueInput
    AND?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    OR?: group_commission_structuresWhereInput[]
    NOT?: group_commission_structuresWhereInput | group_commission_structuresWhereInput[]
    group_id?: StringFilter<"group_commission_structures"> | string
    structure_name?: StringFilter<"group_commission_structures"> | string
    usd_per_lot?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"group_commission_structures"> | boolean
    created_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"group_commission_structures"> | Date | string | null
    level_order?: IntFilter<"group_commission_structures"> | number
    min_trading_volume?: DecimalNullableFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: DecimalNullableFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: IntNullableFilter<"group_commission_structures"> | number | null
  }, "id" | "group_id_structure_name" | "group_id_level_order">

  export type group_commission_structuresOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrderInput | SortOrder
    max_trading_volume?: SortOrderInput | SortOrder
    min_active_clients?: SortOrderInput | SortOrder
    _count?: group_commission_structuresCountOrderByAggregateInput
    _avg?: group_commission_structuresAvgOrderByAggregateInput
    _max?: group_commission_structuresMaxOrderByAggregateInput
    _min?: group_commission_structuresMinOrderByAggregateInput
    _sum?: group_commission_structuresSumOrderByAggregateInput
  }

  export type group_commission_structuresScalarWhereWithAggregatesInput = {
    AND?: group_commission_structuresScalarWhereWithAggregatesInput | group_commission_structuresScalarWhereWithAggregatesInput[]
    OR?: group_commission_structuresScalarWhereWithAggregatesInput[]
    NOT?: group_commission_structuresScalarWhereWithAggregatesInput | group_commission_structuresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"group_commission_structures"> | number
    group_id?: StringWithAggregatesFilter<"group_commission_structures"> | string
    structure_name?: StringWithAggregatesFilter<"group_commission_structures"> | string
    usd_per_lot?: DecimalWithAggregatesFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalWithAggregatesFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolWithAggregatesFilter<"group_commission_structures"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"group_commission_structures"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"group_commission_structures"> | Date | string | null
    level_order?: IntWithAggregatesFilter<"group_commission_structures"> | number
    min_trading_volume?: DecimalNullableWithAggregatesFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: DecimalNullableWithAggregatesFilter<"group_commission_structures"> | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: IntNullableWithAggregatesFilter<"group_commission_structures"> | number | null
  }

  export type ib_adminWhereInput = {
    AND?: ib_adminWhereInput | ib_adminWhereInput[]
    OR?: ib_adminWhereInput[]
    NOT?: ib_adminWhereInput | ib_adminWhereInput[]
    id?: IntFilter<"ib_admin"> | number
    email?: StringFilter<"ib_admin"> | string
    password_hash?: StringFilter<"ib_admin"> | string
    role?: StringNullableFilter<"ib_admin"> | string | null
    is_active?: BoolNullableFilter<"ib_admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"ib_admin"> | number | null
    locked_until?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
  }

  export type ib_adminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type ib_adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ib_adminWhereInput | ib_adminWhereInput[]
    OR?: ib_adminWhereInput[]
    NOT?: ib_adminWhereInput | ib_adminWhereInput[]
    password_hash?: StringFilter<"ib_admin"> | string
    role?: StringNullableFilter<"ib_admin"> | string | null
    is_active?: BoolNullableFilter<"ib_admin"> | boolean | null
    last_login?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    login_attempts?: IntNullableFilter<"ib_admin"> | number | null
    locked_until?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_admin"> | Date | string | null
  }, "id" | "email">

  export type ib_adminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    login_attempts?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ib_adminCountOrderByAggregateInput
    _avg?: ib_adminAvgOrderByAggregateInput
    _max?: ib_adminMaxOrderByAggregateInput
    _min?: ib_adminMinOrderByAggregateInput
    _sum?: ib_adminSumOrderByAggregateInput
  }

  export type ib_adminScalarWhereWithAggregatesInput = {
    AND?: ib_adminScalarWhereWithAggregatesInput | ib_adminScalarWhereWithAggregatesInput[]
    OR?: ib_adminScalarWhereWithAggregatesInput[]
    NOT?: ib_adminScalarWhereWithAggregatesInput | ib_adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_admin"> | number
    email?: StringWithAggregatesFilter<"ib_admin"> | string
    password_hash?: StringWithAggregatesFilter<"ib_admin"> | string
    role?: StringNullableWithAggregatesFilter<"ib_admin"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"ib_admin"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
    login_attempts?: IntNullableWithAggregatesFilter<"ib_admin"> | number | null
    locked_until?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_admin"> | Date | string | null
  }

  export type ib_requestsWhereInput = {
    AND?: ib_requestsWhereInput | ib_requestsWhereInput[]
    OR?: ib_requestsWhereInput[]
    NOT?: ib_requestsWhereInput | ib_requestsWhereInput[]
    id?: IntFilter<"ib_requests"> | number
    full_name?: StringFilter<"ib_requests"> | string
    email?: StringFilter<"ib_requests"> | string
    password_hash?: StringFilter<"ib_requests"> | string
    status?: StringFilter<"ib_requests"> | string
    ib_type?: StringFilter<"ib_requests"> | string
    submitted_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    approved_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    usd_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    admin_comments?: StringNullableFilter<"ib_requests"> | string | null
    group_id?: StringNullableFilter<"ib_requests"> | string | null
    structure_id?: IntNullableFilter<"ib_requests"> | number | null
    created_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    referral_code?: StringNullableFilter<"ib_requests"> | string | null
    referred_by?: IntNullableFilter<"ib_requests"> | number | null
    country?: StringNullableFilter<"ib_requests"> | string | null
    ib_group_assignments?: Ib_group_assignmentsListRelationFilter
  }

  export type ib_requestsOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrderInput | SortOrder
    spread_percentage_per_lot?: SortOrderInput | SortOrder
    admin_comments?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    referral_code?: SortOrderInput | SortOrder
    referred_by?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    ib_group_assignments?: ib_group_assignmentsOrderByRelationAggregateInput
  }

  export type ib_requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    referral_code?: string
    AND?: ib_requestsWhereInput | ib_requestsWhereInput[]
    OR?: ib_requestsWhereInput[]
    NOT?: ib_requestsWhereInput | ib_requestsWhereInput[]
    full_name?: StringFilter<"ib_requests"> | string
    password_hash?: StringFilter<"ib_requests"> | string
    status?: StringFilter<"ib_requests"> | string
    ib_type?: StringFilter<"ib_requests"> | string
    submitted_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    approved_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    usd_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: DecimalNullableFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    admin_comments?: StringNullableFilter<"ib_requests"> | string | null
    group_id?: StringNullableFilter<"ib_requests"> | string | null
    structure_id?: IntNullableFilter<"ib_requests"> | number | null
    created_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_requests"> | Date | string | null
    referred_by?: IntNullableFilter<"ib_requests"> | number | null
    country?: StringNullableFilter<"ib_requests"> | string | null
    ib_group_assignments?: Ib_group_assignmentsListRelationFilter
  }, "id" | "email" | "referral_code">

  export type ib_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrderInput | SortOrder
    spread_percentage_per_lot?: SortOrderInput | SortOrder
    admin_comments?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    referral_code?: SortOrderInput | SortOrder
    referred_by?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    _count?: ib_requestsCountOrderByAggregateInput
    _avg?: ib_requestsAvgOrderByAggregateInput
    _max?: ib_requestsMaxOrderByAggregateInput
    _min?: ib_requestsMinOrderByAggregateInput
    _sum?: ib_requestsSumOrderByAggregateInput
  }

  export type ib_requestsScalarWhereWithAggregatesInput = {
    AND?: ib_requestsScalarWhereWithAggregatesInput | ib_requestsScalarWhereWithAggregatesInput[]
    OR?: ib_requestsScalarWhereWithAggregatesInput[]
    NOT?: ib_requestsScalarWhereWithAggregatesInput | ib_requestsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_requests"> | number
    full_name?: StringWithAggregatesFilter<"ib_requests"> | string
    email?: StringWithAggregatesFilter<"ib_requests"> | string
    password_hash?: StringWithAggregatesFilter<"ib_requests"> | string
    status?: StringWithAggregatesFilter<"ib_requests"> | string
    ib_type?: StringWithAggregatesFilter<"ib_requests"> | string
    submitted_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    approved_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    usd_per_lot?: DecimalNullableWithAggregatesFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: DecimalNullableWithAggregatesFilter<"ib_requests"> | Decimal | DecimalJsLike | number | string | null
    admin_comments?: StringNullableWithAggregatesFilter<"ib_requests"> | string | null
    group_id?: StringNullableWithAggregatesFilter<"ib_requests"> | string | null
    structure_id?: IntNullableWithAggregatesFilter<"ib_requests"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_requests"> | Date | string | null
    referral_code?: StringNullableWithAggregatesFilter<"ib_requests"> | string | null
    referred_by?: IntNullableWithAggregatesFilter<"ib_requests"> | number | null
    country?: StringNullableWithAggregatesFilter<"ib_requests"> | string | null
  }

  export type manual_gatewayWhereInput = {
    AND?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    OR?: manual_gatewayWhereInput[]
    NOT?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    id?: IntFilter<"manual_gateway"> | number
    type?: StringFilter<"manual_gateway"> | string
    name?: StringFilter<"manual_gateway"> | string
    details?: StringFilter<"manual_gateway"> | string
    icon_url?: StringNullableFilter<"manual_gateway"> | string | null
    qr_code_url?: StringNullableFilter<"manual_gateway"> | string | null
    is_active?: BoolFilter<"manual_gateway"> | boolean
    created_at?: DateTimeFilter<"manual_gateway"> | Date | string
    updated_at?: DateTimeFilter<"manual_gateway"> | Date | string
    vpa_address?: StringNullableFilter<"manual_gateway"> | string | null
    crypto_address?: StringNullableFilter<"manual_gateway"> | string | null
    bank_name?: StringNullableFilter<"manual_gateway"> | string | null
    account_name?: StringNullableFilter<"manual_gateway"> | string | null
    account_number?: StringNullableFilter<"manual_gateway"> | string | null
    ifsc_code?: StringNullableFilter<"manual_gateway"> | string | null
    swift_code?: StringNullableFilter<"manual_gateway"> | string | null
    account_type?: StringNullableFilter<"manual_gateway"> | string | null
    country_code?: StringNullableFilter<"manual_gateway"> | string | null
  }

  export type manual_gatewayOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrderInput | SortOrder
    qr_code_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vpa_address?: SortOrderInput | SortOrder
    crypto_address?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    ifsc_code?: SortOrderInput | SortOrder
    swift_code?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
  }

  export type manual_gatewayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    OR?: manual_gatewayWhereInput[]
    NOT?: manual_gatewayWhereInput | manual_gatewayWhereInput[]
    type?: StringFilter<"manual_gateway"> | string
    name?: StringFilter<"manual_gateway"> | string
    details?: StringFilter<"manual_gateway"> | string
    icon_url?: StringNullableFilter<"manual_gateway"> | string | null
    qr_code_url?: StringNullableFilter<"manual_gateway"> | string | null
    is_active?: BoolFilter<"manual_gateway"> | boolean
    created_at?: DateTimeFilter<"manual_gateway"> | Date | string
    updated_at?: DateTimeFilter<"manual_gateway"> | Date | string
    vpa_address?: StringNullableFilter<"manual_gateway"> | string | null
    crypto_address?: StringNullableFilter<"manual_gateway"> | string | null
    bank_name?: StringNullableFilter<"manual_gateway"> | string | null
    account_name?: StringNullableFilter<"manual_gateway"> | string | null
    account_number?: StringNullableFilter<"manual_gateway"> | string | null
    ifsc_code?: StringNullableFilter<"manual_gateway"> | string | null
    swift_code?: StringNullableFilter<"manual_gateway"> | string | null
    account_type?: StringNullableFilter<"manual_gateway"> | string | null
    country_code?: StringNullableFilter<"manual_gateway"> | string | null
  }, "id">

  export type manual_gatewayOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrderInput | SortOrder
    qr_code_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vpa_address?: SortOrderInput | SortOrder
    crypto_address?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    ifsc_code?: SortOrderInput | SortOrder
    swift_code?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    _count?: manual_gatewayCountOrderByAggregateInput
    _avg?: manual_gatewayAvgOrderByAggregateInput
    _max?: manual_gatewayMaxOrderByAggregateInput
    _min?: manual_gatewayMinOrderByAggregateInput
    _sum?: manual_gatewaySumOrderByAggregateInput
  }

  export type manual_gatewayScalarWhereWithAggregatesInput = {
    AND?: manual_gatewayScalarWhereWithAggregatesInput | manual_gatewayScalarWhereWithAggregatesInput[]
    OR?: manual_gatewayScalarWhereWithAggregatesInput[]
    NOT?: manual_gatewayScalarWhereWithAggregatesInput | manual_gatewayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"manual_gateway"> | number
    type?: StringWithAggregatesFilter<"manual_gateway"> | string
    name?: StringWithAggregatesFilter<"manual_gateway"> | string
    details?: StringWithAggregatesFilter<"manual_gateway"> | string
    icon_url?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    qr_code_url?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    is_active?: BoolWithAggregatesFilter<"manual_gateway"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"manual_gateway"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"manual_gateway"> | Date | string
    vpa_address?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    crypto_address?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    bank_name?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    account_name?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    account_number?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    ifsc_code?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    swift_code?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    account_type?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
    country_code?: StringNullableWithAggregatesFilter<"manual_gateway"> | string | null
  }

  export type mt5_groupsWhereInput = {
    AND?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    OR?: mt5_groupsWhereInput[]
    NOT?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    id?: IntFilter<"mt5_groups"> | number
    group_id?: StringFilter<"mt5_groups"> | string
    name?: StringFilter<"mt5_groups"> | string
    description?: StringNullableFilter<"mt5_groups"> | string | null
    synced_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    created_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
  }

  export type mt5_groupsOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type mt5_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    group_id?: string
    AND?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    OR?: mt5_groupsWhereInput[]
    NOT?: mt5_groupsWhereInput | mt5_groupsWhereInput[]
    name?: StringFilter<"mt5_groups"> | string
    description?: StringNullableFilter<"mt5_groups"> | string | null
    synced_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    created_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"mt5_groups"> | Date | string | null
  }, "id" | "group_id">

  export type mt5_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: mt5_groupsCountOrderByAggregateInput
    _avg?: mt5_groupsAvgOrderByAggregateInput
    _max?: mt5_groupsMaxOrderByAggregateInput
    _min?: mt5_groupsMinOrderByAggregateInput
    _sum?: mt5_groupsSumOrderByAggregateInput
  }

  export type mt5_groupsScalarWhereWithAggregatesInput = {
    AND?: mt5_groupsScalarWhereWithAggregatesInput | mt5_groupsScalarWhereWithAggregatesInput[]
    OR?: mt5_groupsScalarWhereWithAggregatesInput[]
    NOT?: mt5_groupsScalarWhereWithAggregatesInput | mt5_groupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mt5_groups"> | number
    group_id?: StringWithAggregatesFilter<"mt5_groups"> | string
    name?: StringWithAggregatesFilter<"mt5_groups"> | string
    description?: StringNullableWithAggregatesFilter<"mt5_groups"> | string | null
    synced_at?: DateTimeNullableWithAggregatesFilter<"mt5_groups"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"mt5_groups"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"mt5_groups"> | Date | string | null
  }

  export type payment_gatewayWhereInput = {
    AND?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    OR?: payment_gatewayWhereInput[]
    NOT?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    id?: IntFilter<"payment_gateway"> | number
    wallet_name?: StringFilter<"payment_gateway"> | string
    deposit_wallet_address?: StringFilter<"payment_gateway"> | string
    api_key?: StringFilter<"payment_gateway"> | string
    secret_key?: StringFilter<"payment_gateway"> | string
    gateway_type?: StringFilter<"payment_gateway"> | string
    is_active?: BoolFilter<"payment_gateway"> | boolean
    description?: StringNullableFilter<"payment_gateway"> | string | null
    created_at?: DateTimeFilter<"payment_gateway"> | Date | string
    updated_at?: DateTimeFilter<"payment_gateway"> | Date | string
  }

  export type payment_gatewayOrderByWithRelationInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    OR?: payment_gatewayWhereInput[]
    NOT?: payment_gatewayWhereInput | payment_gatewayWhereInput[]
    wallet_name?: StringFilter<"payment_gateway"> | string
    deposit_wallet_address?: StringFilter<"payment_gateway"> | string
    api_key?: StringFilter<"payment_gateway"> | string
    secret_key?: StringFilter<"payment_gateway"> | string
    gateway_type?: StringFilter<"payment_gateway"> | string
    is_active?: BoolFilter<"payment_gateway"> | boolean
    description?: StringNullableFilter<"payment_gateway"> | string | null
    created_at?: DateTimeFilter<"payment_gateway"> | Date | string
    updated_at?: DateTimeFilter<"payment_gateway"> | Date | string
  }, "id">

  export type payment_gatewayOrderByWithAggregationInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: payment_gatewayCountOrderByAggregateInput
    _avg?: payment_gatewayAvgOrderByAggregateInput
    _max?: payment_gatewayMaxOrderByAggregateInput
    _min?: payment_gatewayMinOrderByAggregateInput
    _sum?: payment_gatewaySumOrderByAggregateInput
  }

  export type payment_gatewayScalarWhereWithAggregatesInput = {
    AND?: payment_gatewayScalarWhereWithAggregatesInput | payment_gatewayScalarWhereWithAggregatesInput[]
    OR?: payment_gatewayScalarWhereWithAggregatesInput[]
    NOT?: payment_gatewayScalarWhereWithAggregatesInput | payment_gatewayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment_gateway"> | number
    wallet_name?: StringWithAggregatesFilter<"payment_gateway"> | string
    deposit_wallet_address?: StringWithAggregatesFilter<"payment_gateway"> | string
    api_key?: StringWithAggregatesFilter<"payment_gateway"> | string
    secret_key?: StringWithAggregatesFilter<"payment_gateway"> | string
    gateway_type?: StringWithAggregatesFilter<"payment_gateway"> | string
    is_active?: BoolWithAggregatesFilter<"payment_gateway"> | boolean
    description?: StringNullableWithAggregatesFilter<"payment_gateway"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"payment_gateway"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"payment_gateway"> | Date | string
  }

  export type symbolsWhereInput = {
    AND?: symbolsWhereInput | symbolsWhereInput[]
    OR?: symbolsWhereInput[]
    NOT?: symbolsWhereInput | symbolsWhereInput[]
    id?: IntFilter<"symbols"> | number
    symbol_name?: StringFilter<"symbols"> | string
    description?: StringNullableFilter<"symbols"> | string | null
    symbol_type?: StringNullableFilter<"symbols"> | string | null
    group_name?: StringNullableFilter<"symbols"> | string | null
    digits?: IntNullableFilter<"symbols"> | number | null
    spread?: FloatNullableFilter<"symbols"> | number | null
    contract_size?: IntNullableFilter<"symbols"> | number | null
    profit_mode?: StringNullableFilter<"symbols"> | string | null
    enable?: BoolNullableFilter<"symbols"> | boolean | null
    swap_mode?: StringNullableFilter<"symbols"> | string | null
    swap_long?: FloatNullableFilter<"symbols"> | number | null
    swap_short?: FloatNullableFilter<"symbols"> | number | null
    swap3_day?: StringNullableFilter<"symbols"> | string | null
    created_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
  }

  export type symbolsOrderByWithRelationInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrderInput | SortOrder
    symbol_type?: SortOrderInput | SortOrder
    group_name?: SortOrderInput | SortOrder
    digits?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    contract_size?: SortOrderInput | SortOrder
    profit_mode?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    swap_mode?: SortOrderInput | SortOrder
    swap_long?: SortOrderInput | SortOrder
    swap_short?: SortOrderInput | SortOrder
    swap3_day?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type symbolsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol_name?: string
    AND?: symbolsWhereInput | symbolsWhereInput[]
    OR?: symbolsWhereInput[]
    NOT?: symbolsWhereInput | symbolsWhereInput[]
    description?: StringNullableFilter<"symbols"> | string | null
    symbol_type?: StringNullableFilter<"symbols"> | string | null
    group_name?: StringNullableFilter<"symbols"> | string | null
    digits?: IntNullableFilter<"symbols"> | number | null
    spread?: FloatNullableFilter<"symbols"> | number | null
    contract_size?: IntNullableFilter<"symbols"> | number | null
    profit_mode?: StringNullableFilter<"symbols"> | string | null
    enable?: BoolNullableFilter<"symbols"> | boolean | null
    swap_mode?: StringNullableFilter<"symbols"> | string | null
    swap_long?: FloatNullableFilter<"symbols"> | number | null
    swap_short?: FloatNullableFilter<"symbols"> | number | null
    swap3_day?: StringNullableFilter<"symbols"> | string | null
    created_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"symbols"> | Date | string | null
  }, "id" | "symbol_name">

  export type symbolsOrderByWithAggregationInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrderInput | SortOrder
    symbol_type?: SortOrderInput | SortOrder
    group_name?: SortOrderInput | SortOrder
    digits?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    contract_size?: SortOrderInput | SortOrder
    profit_mode?: SortOrderInput | SortOrder
    enable?: SortOrderInput | SortOrder
    swap_mode?: SortOrderInput | SortOrder
    swap_long?: SortOrderInput | SortOrder
    swap_short?: SortOrderInput | SortOrder
    swap3_day?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: symbolsCountOrderByAggregateInput
    _avg?: symbolsAvgOrderByAggregateInput
    _max?: symbolsMaxOrderByAggregateInput
    _min?: symbolsMinOrderByAggregateInput
    _sum?: symbolsSumOrderByAggregateInput
  }

  export type symbolsScalarWhereWithAggregatesInput = {
    AND?: symbolsScalarWhereWithAggregatesInput | symbolsScalarWhereWithAggregatesInput[]
    OR?: symbolsScalarWhereWithAggregatesInput[]
    NOT?: symbolsScalarWhereWithAggregatesInput | symbolsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"symbols"> | number
    symbol_name?: StringWithAggregatesFilter<"symbols"> | string
    description?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    symbol_type?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    group_name?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    digits?: IntNullableWithAggregatesFilter<"symbols"> | number | null
    spread?: FloatNullableWithAggregatesFilter<"symbols"> | number | null
    contract_size?: IntNullableWithAggregatesFilter<"symbols"> | number | null
    profit_mode?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    enable?: BoolNullableWithAggregatesFilter<"symbols"> | boolean | null
    swap_mode?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    swap_long?: FloatNullableWithAggregatesFilter<"symbols"> | number | null
    swap_short?: FloatNullableWithAggregatesFilter<"symbols"> | number | null
    swap3_day?: StringNullableWithAggregatesFilter<"symbols"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"symbols"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"symbols"> | Date | string | null
  }

  export type ib_group_assignmentsWhereInput = {
    AND?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    OR?: ib_group_assignmentsWhereInput[]
    NOT?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    id?: IntFilter<"ib_group_assignments"> | number
    ib_request_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    group_id?: StringFilter<"ib_group_assignments"> | string
    group_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    ib_requests?: XOR<Ib_requestsNullableScalarRelationFilter, ib_requestsWhereInput> | null
  }

  export type ib_group_assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    group_id?: SortOrder
    group_name?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    structure_name?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    ib_requests?: ib_requestsOrderByWithRelationInput
  }

  export type ib_group_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    OR?: ib_group_assignmentsWhereInput[]
    NOT?: ib_group_assignmentsWhereInput | ib_group_assignmentsWhereInput[]
    ib_request_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    group_id?: StringFilter<"ib_group_assignments"> | string
    group_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    ib_requests?: XOR<Ib_requestsNullableScalarRelationFilter, ib_requestsWhereInput> | null
  }, "id">

  export type ib_group_assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    group_id?: SortOrder
    group_name?: SortOrderInput | SortOrder
    structure_id?: SortOrderInput | SortOrder
    structure_name?: SortOrderInput | SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ib_group_assignmentsCountOrderByAggregateInput
    _avg?: ib_group_assignmentsAvgOrderByAggregateInput
    _max?: ib_group_assignmentsMaxOrderByAggregateInput
    _min?: ib_group_assignmentsMinOrderByAggregateInput
    _sum?: ib_group_assignmentsSumOrderByAggregateInput
  }

  export type ib_group_assignmentsScalarWhereWithAggregatesInput = {
    AND?: ib_group_assignmentsScalarWhereWithAggregatesInput | ib_group_assignmentsScalarWhereWithAggregatesInput[]
    OR?: ib_group_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: ib_group_assignmentsScalarWhereWithAggregatesInput | ib_group_assignmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_group_assignments"> | number
    ib_request_id?: IntNullableWithAggregatesFilter<"ib_group_assignments"> | number | null
    group_id?: StringWithAggregatesFilter<"ib_group_assignments"> | string
    group_name?: StringNullableWithAggregatesFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableWithAggregatesFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableWithAggregatesFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalWithAggregatesFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalWithAggregatesFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_group_assignments"> | Date | string | null
  }

  export type ib_trade_historyWhereInput = {
    AND?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    OR?: ib_trade_historyWhereInput[]
    NOT?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    id?: StringFilter<"ib_trade_history"> | string
    order_id?: StringFilter<"ib_trade_history"> | string
    account_id?: StringFilter<"ib_trade_history"> | string
    user_id?: StringNullableFilter<"ib_trade_history"> | string | null
    ib_request_id?: IntNullableFilter<"ib_trade_history"> | number | null
    symbol?: StringFilter<"ib_trade_history"> | string
    order_type?: StringFilter<"ib_trade_history"> | string
    volume_lots?: DecimalFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string
    open_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    ib_commission?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    take_profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    stop_loss?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    synced_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    group_id?: StringNullableFilter<"ib_trade_history"> | string | null
  }

  export type ib_trade_historyOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrderInput | SortOrder
    close_price?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    ib_commission?: SortOrderInput | SortOrder
    take_profit?: SortOrderInput | SortOrder
    stop_loss?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
  }

  export type ib_trade_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    order_id?: string
    AND?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    OR?: ib_trade_historyWhereInput[]
    NOT?: ib_trade_historyWhereInput | ib_trade_historyWhereInput[]
    account_id?: StringFilter<"ib_trade_history"> | string
    user_id?: StringNullableFilter<"ib_trade_history"> | string | null
    ib_request_id?: IntNullableFilter<"ib_trade_history"> | number | null
    symbol?: StringFilter<"ib_trade_history"> | string
    order_type?: StringFilter<"ib_trade_history"> | string
    volume_lots?: DecimalFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string
    open_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    ib_commission?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    take_profit?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    stop_loss?: DecimalNullableFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    synced_at?: DateTimeNullableFilter<"ib_trade_history"> | Date | string | null
    group_id?: StringNullableFilter<"ib_trade_history"> | string | null
  }, "id" | "order_id">

  export type ib_trade_historyOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ib_request_id?: SortOrderInput | SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrderInput | SortOrder
    close_price?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    ib_commission?: SortOrderInput | SortOrder
    take_profit?: SortOrderInput | SortOrder
    stop_loss?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    group_id?: SortOrderInput | SortOrder
    _count?: ib_trade_historyCountOrderByAggregateInput
    _avg?: ib_trade_historyAvgOrderByAggregateInput
    _max?: ib_trade_historyMaxOrderByAggregateInput
    _min?: ib_trade_historyMinOrderByAggregateInput
    _sum?: ib_trade_historySumOrderByAggregateInput
  }

  export type ib_trade_historyScalarWhereWithAggregatesInput = {
    AND?: ib_trade_historyScalarWhereWithAggregatesInput | ib_trade_historyScalarWhereWithAggregatesInput[]
    OR?: ib_trade_historyScalarWhereWithAggregatesInput[]
    NOT?: ib_trade_historyScalarWhereWithAggregatesInput | ib_trade_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ib_trade_history"> | string
    order_id?: StringWithAggregatesFilter<"ib_trade_history"> | string
    account_id?: StringWithAggregatesFilter<"ib_trade_history"> | string
    user_id?: StringNullableWithAggregatesFilter<"ib_trade_history"> | string | null
    ib_request_id?: IntNullableWithAggregatesFilter<"ib_trade_history"> | number | null
    symbol?: StringWithAggregatesFilter<"ib_trade_history"> | string
    order_type?: StringWithAggregatesFilter<"ib_trade_history"> | string
    volume_lots?: DecimalWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string
    open_price?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    close_price?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    profit?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    ib_commission?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    take_profit?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    stop_loss?: DecimalNullableWithAggregatesFilter<"ib_trade_history"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_trade_history"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_trade_history"> | Date | string | null
    synced_at?: DateTimeNullableWithAggregatesFilter<"ib_trade_history"> | Date | string | null
    group_id?: StringNullableWithAggregatesFilter<"ib_trade_history"> | string | null
  }

  export type support_ticketsWhereInput = {
    AND?: support_ticketsWhereInput | support_ticketsWhereInput[]
    OR?: support_ticketsWhereInput[]
    NOT?: support_ticketsWhereInput | support_ticketsWhereInput[]
    id?: IntFilter<"support_tickets"> | number
    ticket_no?: StringFilter<"support_tickets"> | string
    parent_id?: StringFilter<"support_tickets"> | string
    title?: StringFilter<"support_tickets"> | string
    description?: StringNullableFilter<"support_tickets"> | string | null
    ticket_type?: StringNullableFilter<"support_tickets"> | string | null
    status?: StringFilter<"support_tickets"> | string
    priority?: StringFilter<"support_tickets"> | string
    assigned_to?: StringNullableFilter<"support_tickets"> | string | null
    account_number?: StringNullableFilter<"support_tickets"> | string | null
    tags?: StringNullableListFilter<"support_tickets">
    created_at?: DateTimeFilter<"support_tickets"> | Date | string
    updated_at?: DateTimeFilter<"support_tickets"> | Date | string
    last_reply_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_by?: StringNullableFilter<"support_tickets"> | string | null
  }

  export type support_ticketsOrderByWithRelationInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    ticket_type?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    tags?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
  }

  export type support_ticketsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ticket_no?: string
    AND?: support_ticketsWhereInput | support_ticketsWhereInput[]
    OR?: support_ticketsWhereInput[]
    NOT?: support_ticketsWhereInput | support_ticketsWhereInput[]
    parent_id?: StringFilter<"support_tickets"> | string
    title?: StringFilter<"support_tickets"> | string
    description?: StringNullableFilter<"support_tickets"> | string | null
    ticket_type?: StringNullableFilter<"support_tickets"> | string | null
    status?: StringFilter<"support_tickets"> | string
    priority?: StringFilter<"support_tickets"> | string
    assigned_to?: StringNullableFilter<"support_tickets"> | string | null
    account_number?: StringNullableFilter<"support_tickets"> | string | null
    tags?: StringNullableListFilter<"support_tickets">
    created_at?: DateTimeFilter<"support_tickets"> | Date | string
    updated_at?: DateTimeFilter<"support_tickets"> | Date | string
    last_reply_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"support_tickets"> | Date | string | null
    closed_by?: StringNullableFilter<"support_tickets"> | string | null
  }, "id" | "ticket_no">

  export type support_ticketsOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    ticket_type?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    tags?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    closed_by?: SortOrderInput | SortOrder
    _count?: support_ticketsCountOrderByAggregateInput
    _avg?: support_ticketsAvgOrderByAggregateInput
    _max?: support_ticketsMaxOrderByAggregateInput
    _min?: support_ticketsMinOrderByAggregateInput
    _sum?: support_ticketsSumOrderByAggregateInput
  }

  export type support_ticketsScalarWhereWithAggregatesInput = {
    AND?: support_ticketsScalarWhereWithAggregatesInput | support_ticketsScalarWhereWithAggregatesInput[]
    OR?: support_ticketsScalarWhereWithAggregatesInput[]
    NOT?: support_ticketsScalarWhereWithAggregatesInput | support_ticketsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_tickets"> | number
    ticket_no?: StringWithAggregatesFilter<"support_tickets"> | string
    parent_id?: StringWithAggregatesFilter<"support_tickets"> | string
    title?: StringWithAggregatesFilter<"support_tickets"> | string
    description?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    ticket_type?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    status?: StringWithAggregatesFilter<"support_tickets"> | string
    priority?: StringWithAggregatesFilter<"support_tickets"> | string
    assigned_to?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    account_number?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
    tags?: StringNullableListFilter<"support_tickets">
    created_at?: DateTimeWithAggregatesFilter<"support_tickets"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_tickets"> | Date | string
    last_reply_at?: DateTimeNullableWithAggregatesFilter<"support_tickets"> | Date | string | null
    closed_at?: DateTimeNullableWithAggregatesFilter<"support_tickets"> | Date | string | null
    closed_by?: StringNullableWithAggregatesFilter<"support_tickets"> | string | null
  }

  export type support_ticket_repliesWhereInput = {
    AND?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    OR?: support_ticket_repliesWhereInput[]
    NOT?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    id?: IntFilter<"support_ticket_replies"> | number
    ticket_id?: IntFilter<"support_ticket_replies"> | number
    reply_id?: IntNullableFilter<"support_ticket_replies"> | number | null
    sender_id?: StringFilter<"support_ticket_replies"> | string
    sender_name?: StringFilter<"support_ticket_replies"> | string
    sender_type?: StringFilter<"support_ticket_replies"> | string
    content?: StringFilter<"support_ticket_replies"> | string
    is_internal?: BoolFilter<"support_ticket_replies"> | boolean
    attachments?: StringNullableListFilter<"support_ticket_replies">
    created_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    is_read?: BoolFilter<"support_ticket_replies"> | boolean
  }

  export type support_ticket_repliesOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    OR?: support_ticket_repliesWhereInput[]
    NOT?: support_ticket_repliesWhereInput | support_ticket_repliesWhereInput[]
    ticket_id?: IntFilter<"support_ticket_replies"> | number
    reply_id?: IntNullableFilter<"support_ticket_replies"> | number | null
    sender_id?: StringFilter<"support_ticket_replies"> | string
    sender_name?: StringFilter<"support_ticket_replies"> | string
    sender_type?: StringFilter<"support_ticket_replies"> | string
    content?: StringFilter<"support_ticket_replies"> | string
    is_internal?: BoolFilter<"support_ticket_replies"> | boolean
    attachments?: StringNullableListFilter<"support_ticket_replies">
    created_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    updated_at?: DateTimeFilter<"support_ticket_replies"> | Date | string
    is_read?: BoolFilter<"support_ticket_replies"> | boolean
  }, "id">

  export type support_ticket_repliesOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrderInput | SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
    _count?: support_ticket_repliesCountOrderByAggregateInput
    _avg?: support_ticket_repliesAvgOrderByAggregateInput
    _max?: support_ticket_repliesMaxOrderByAggregateInput
    _min?: support_ticket_repliesMinOrderByAggregateInput
    _sum?: support_ticket_repliesSumOrderByAggregateInput
  }

  export type support_ticket_repliesScalarWhereWithAggregatesInput = {
    AND?: support_ticket_repliesScalarWhereWithAggregatesInput | support_ticket_repliesScalarWhereWithAggregatesInput[]
    OR?: support_ticket_repliesScalarWhereWithAggregatesInput[]
    NOT?: support_ticket_repliesScalarWhereWithAggregatesInput | support_ticket_repliesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_ticket_replies"> | number
    ticket_id?: IntWithAggregatesFilter<"support_ticket_replies"> | number
    reply_id?: IntNullableWithAggregatesFilter<"support_ticket_replies"> | number | null
    sender_id?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    sender_name?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    sender_type?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    content?: StringWithAggregatesFilter<"support_ticket_replies"> | string
    is_internal?: BoolWithAggregatesFilter<"support_ticket_replies"> | boolean
    attachments?: StringNullableListFilter<"support_ticket_replies">
    created_at?: DateTimeWithAggregatesFilter<"support_ticket_replies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_ticket_replies"> | Date | string
    is_read?: BoolWithAggregatesFilter<"support_ticket_replies"> | boolean
  }

  export type support_articlesWhereInput = {
    AND?: support_articlesWhereInput | support_articlesWhereInput[]
    OR?: support_articlesWhereInput[]
    NOT?: support_articlesWhereInput | support_articlesWhereInput[]
    id?: IntFilter<"support_articles"> | number
    title?: StringFilter<"support_articles"> | string
    slug?: StringFilter<"support_articles"> | string
    content?: StringFilter<"support_articles"> | string
    excerpt?: StringNullableFilter<"support_articles"> | string | null
    category?: StringFilter<"support_articles"> | string
    tags?: StringNullableListFilter<"support_articles">
    views?: IntFilter<"support_articles"> | number
    helpful_count?: IntFilter<"support_articles"> | number
    not_helpful_count?: IntFilter<"support_articles"> | number
    is_published?: BoolFilter<"support_articles"> | boolean
    author_id?: StringFilter<"support_articles"> | string
    created_at?: DateTimeFilter<"support_articles"> | Date | string
    updated_at?: DateTimeFilter<"support_articles"> | Date | string
    published_at?: DateTimeNullableFilter<"support_articles"> | Date | string | null
  }

  export type support_articlesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrderInput | SortOrder
  }

  export type support_articlesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: support_articlesWhereInput | support_articlesWhereInput[]
    OR?: support_articlesWhereInput[]
    NOT?: support_articlesWhereInput | support_articlesWhereInput[]
    title?: StringFilter<"support_articles"> | string
    content?: StringFilter<"support_articles"> | string
    excerpt?: StringNullableFilter<"support_articles"> | string | null
    category?: StringFilter<"support_articles"> | string
    tags?: StringNullableListFilter<"support_articles">
    views?: IntFilter<"support_articles"> | number
    helpful_count?: IntFilter<"support_articles"> | number
    not_helpful_count?: IntFilter<"support_articles"> | number
    is_published?: BoolFilter<"support_articles"> | boolean
    author_id?: StringFilter<"support_articles"> | string
    created_at?: DateTimeFilter<"support_articles"> | Date | string
    updated_at?: DateTimeFilter<"support_articles"> | Date | string
    published_at?: DateTimeNullableFilter<"support_articles"> | Date | string | null
  }, "id" | "slug">

  export type support_articlesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrderInput | SortOrder
    _count?: support_articlesCountOrderByAggregateInput
    _avg?: support_articlesAvgOrderByAggregateInput
    _max?: support_articlesMaxOrderByAggregateInput
    _min?: support_articlesMinOrderByAggregateInput
    _sum?: support_articlesSumOrderByAggregateInput
  }

  export type support_articlesScalarWhereWithAggregatesInput = {
    AND?: support_articlesScalarWhereWithAggregatesInput | support_articlesScalarWhereWithAggregatesInput[]
    OR?: support_articlesScalarWhereWithAggregatesInput[]
    NOT?: support_articlesScalarWhereWithAggregatesInput | support_articlesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_articles"> | number
    title?: StringWithAggregatesFilter<"support_articles"> | string
    slug?: StringWithAggregatesFilter<"support_articles"> | string
    content?: StringWithAggregatesFilter<"support_articles"> | string
    excerpt?: StringNullableWithAggregatesFilter<"support_articles"> | string | null
    category?: StringWithAggregatesFilter<"support_articles"> | string
    tags?: StringNullableListFilter<"support_articles">
    views?: IntWithAggregatesFilter<"support_articles"> | number
    helpful_count?: IntWithAggregatesFilter<"support_articles"> | number
    not_helpful_count?: IntWithAggregatesFilter<"support_articles"> | number
    is_published?: BoolWithAggregatesFilter<"support_articles"> | boolean
    author_id?: StringWithAggregatesFilter<"support_articles"> | string
    created_at?: DateTimeWithAggregatesFilter<"support_articles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_articles"> | Date | string
    published_at?: DateTimeNullableWithAggregatesFilter<"support_articles"> | Date | string | null
  }

  export type support_faqWhereInput = {
    AND?: support_faqWhereInput | support_faqWhereInput[]
    OR?: support_faqWhereInput[]
    NOT?: support_faqWhereInput | support_faqWhereInput[]
    id?: IntFilter<"support_faq"> | number
    question?: StringFilter<"support_faq"> | string
    answer?: StringFilter<"support_faq"> | string
    category?: StringFilter<"support_faq"> | string
    tags?: StringNullableListFilter<"support_faq">
    helpful_count?: IntFilter<"support_faq"> | number
    not_helpful_count?: IntFilter<"support_faq"> | number
    display_order?: IntFilter<"support_faq"> | number
    is_active?: BoolFilter<"support_faq"> | boolean
    created_at?: DateTimeFilter<"support_faq"> | Date | string
    updated_at?: DateTimeFilter<"support_faq"> | Date | string
  }

  export type support_faqOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: support_faqWhereInput | support_faqWhereInput[]
    OR?: support_faqWhereInput[]
    NOT?: support_faqWhereInput | support_faqWhereInput[]
    question?: StringFilter<"support_faq"> | string
    answer?: StringFilter<"support_faq"> | string
    category?: StringFilter<"support_faq"> | string
    tags?: StringNullableListFilter<"support_faq">
    helpful_count?: IntFilter<"support_faq"> | number
    not_helpful_count?: IntFilter<"support_faq"> | number
    display_order?: IntFilter<"support_faq"> | number
    is_active?: BoolFilter<"support_faq"> | boolean
    created_at?: DateTimeFilter<"support_faq"> | Date | string
    updated_at?: DateTimeFilter<"support_faq"> | Date | string
  }, "id">

  export type support_faqOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: support_faqCountOrderByAggregateInput
    _avg?: support_faqAvgOrderByAggregateInput
    _max?: support_faqMaxOrderByAggregateInput
    _min?: support_faqMinOrderByAggregateInput
    _sum?: support_faqSumOrderByAggregateInput
  }

  export type support_faqScalarWhereWithAggregatesInput = {
    AND?: support_faqScalarWhereWithAggregatesInput | support_faqScalarWhereWithAggregatesInput[]
    OR?: support_faqScalarWhereWithAggregatesInput[]
    NOT?: support_faqScalarWhereWithAggregatesInput | support_faqScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_faq"> | number
    question?: StringWithAggregatesFilter<"support_faq"> | string
    answer?: StringWithAggregatesFilter<"support_faq"> | string
    category?: StringWithAggregatesFilter<"support_faq"> | string
    tags?: StringNullableListFilter<"support_faq">
    helpful_count?: IntWithAggregatesFilter<"support_faq"> | number
    not_helpful_count?: IntWithAggregatesFilter<"support_faq"> | number
    display_order?: IntWithAggregatesFilter<"support_faq"> | number
    is_active?: BoolWithAggregatesFilter<"support_faq"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"support_faq"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_faq"> | Date | string
  }

  export type support_categoriesWhereInput = {
    AND?: support_categoriesWhereInput | support_categoriesWhereInput[]
    OR?: support_categoriesWhereInput[]
    NOT?: support_categoriesWhereInput | support_categoriesWhereInput[]
    id?: IntFilter<"support_categories"> | number
    name?: StringFilter<"support_categories"> | string
    slug?: StringFilter<"support_categories"> | string
    description?: StringNullableFilter<"support_categories"> | string | null
    icon?: StringNullableFilter<"support_categories"> | string | null
    display_order?: IntFilter<"support_categories"> | number
    is_active?: BoolFilter<"support_categories"> | boolean
    created_at?: DateTimeFilter<"support_categories"> | Date | string
    updated_at?: DateTimeFilter<"support_categories"> | Date | string
  }

  export type support_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: support_categoriesWhereInput | support_categoriesWhereInput[]
    OR?: support_categoriesWhereInput[]
    NOT?: support_categoriesWhereInput | support_categoriesWhereInput[]
    description?: StringNullableFilter<"support_categories"> | string | null
    icon?: StringNullableFilter<"support_categories"> | string | null
    display_order?: IntFilter<"support_categories"> | number
    is_active?: BoolFilter<"support_categories"> | boolean
    created_at?: DateTimeFilter<"support_categories"> | Date | string
    updated_at?: DateTimeFilter<"support_categories"> | Date | string
  }, "id" | "name" | "slug">

  export type support_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: support_categoriesCountOrderByAggregateInput
    _avg?: support_categoriesAvgOrderByAggregateInput
    _max?: support_categoriesMaxOrderByAggregateInput
    _min?: support_categoriesMinOrderByAggregateInput
    _sum?: support_categoriesSumOrderByAggregateInput
  }

  export type support_categoriesScalarWhereWithAggregatesInput = {
    AND?: support_categoriesScalarWhereWithAggregatesInput | support_categoriesScalarWhereWithAggregatesInput[]
    OR?: support_categoriesScalarWhereWithAggregatesInput[]
    NOT?: support_categoriesScalarWhereWithAggregatesInput | support_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_categories"> | number
    name?: StringWithAggregatesFilter<"support_categories"> | string
    slug?: StringWithAggregatesFilter<"support_categories"> | string
    description?: StringNullableWithAggregatesFilter<"support_categories"> | string | null
    icon?: StringNullableWithAggregatesFilter<"support_categories"> | string | null
    display_order?: IntWithAggregatesFilter<"support_categories"> | number
    is_active?: BoolWithAggregatesFilter<"support_categories"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"support_categories"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"support_categories"> | Date | string
  }

  export type support_repliesWhereInput = {
    AND?: support_repliesWhereInput | support_repliesWhereInput[]
    OR?: support_repliesWhereInput[]
    NOT?: support_repliesWhereInput | support_repliesWhereInput[]
    id?: IntFilter<"support_replies"> | number
    ticket_id?: IntFilter<"support_replies"> | number
    sender_id?: StringFilter<"support_replies"> | string
    sender_name?: StringFilter<"support_replies"> | string
    sender_type?: StringFilter<"support_replies"> | string
    content?: StringFilter<"support_replies"> | string
    is_internal?: BoolFilter<"support_replies"> | boolean
    created_at?: DateTimeFilter<"support_replies"> | Date | string
  }

  export type support_repliesOrderByWithRelationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: support_repliesWhereInput | support_repliesWhereInput[]
    OR?: support_repliesWhereInput[]
    NOT?: support_repliesWhereInput | support_repliesWhereInput[]
    ticket_id?: IntFilter<"support_replies"> | number
    sender_id?: StringFilter<"support_replies"> | string
    sender_name?: StringFilter<"support_replies"> | string
    sender_type?: StringFilter<"support_replies"> | string
    content?: StringFilter<"support_replies"> | string
    is_internal?: BoolFilter<"support_replies"> | boolean
    created_at?: DateTimeFilter<"support_replies"> | Date | string
  }, "id">

  export type support_repliesOrderByWithAggregationInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    _count?: support_repliesCountOrderByAggregateInput
    _avg?: support_repliesAvgOrderByAggregateInput
    _max?: support_repliesMaxOrderByAggregateInput
    _min?: support_repliesMinOrderByAggregateInput
    _sum?: support_repliesSumOrderByAggregateInput
  }

  export type support_repliesScalarWhereWithAggregatesInput = {
    AND?: support_repliesScalarWhereWithAggregatesInput | support_repliesScalarWhereWithAggregatesInput[]
    OR?: support_repliesScalarWhereWithAggregatesInput[]
    NOT?: support_repliesScalarWhereWithAggregatesInput | support_repliesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"support_replies"> | number
    ticket_id?: IntWithAggregatesFilter<"support_replies"> | number
    sender_id?: StringWithAggregatesFilter<"support_replies"> | string
    sender_name?: StringWithAggregatesFilter<"support_replies"> | string
    sender_type?: StringWithAggregatesFilter<"support_replies"> | string
    content?: StringWithAggregatesFilter<"support_replies"> | string
    is_internal?: BoolWithAggregatesFilter<"support_replies"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"support_replies"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type group_managementWhereInput = {
    AND?: group_managementWhereInput | group_managementWhereInput[]
    OR?: group_managementWhereInput[]
    NOT?: group_managementWhereInput | group_managementWhereInput[]
    id?: IntFilter<"group_management"> | number
    group?: StringFilter<"group_management"> | string
    server?: IntNullableFilter<"group_management"> | number | null
    auth_mode?: IntNullableFilter<"group_management"> | number | null
    auth_password_min?: IntNullableFilter<"group_management"> | number | null
    currency?: StringNullableFilter<"group_management"> | string | null
    is_active?: BoolNullableFilter<"group_management"> | boolean | null
    synced_at?: DateTimeNullableFilter<"group_management"> | Date | string | null
    created_at?: DateTimeNullableFilter<"group_management"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"group_management"> | Date | string | null
    dedicated_name?: StringNullableFilter<"group_management"> | string | null
    account_type?: StringNullableFilter<"group_management"> | string | null
    leverage?: IntNullableFilter<"group_management"> | number | null
    min_deposit?: DecimalNullableFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
    spread?: DecimalNullableFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementOrderByWithRelationInput = {
    id?: SortOrder
    group?: SortOrder
    server?: SortOrderInput | SortOrder
    auth_mode?: SortOrderInput | SortOrder
    auth_password_min?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    dedicated_name?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    leverage?: SortOrderInput | SortOrder
    min_deposit?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
  }

  export type group_managementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    group?: string
    AND?: group_managementWhereInput | group_managementWhereInput[]
    OR?: group_managementWhereInput[]
    NOT?: group_managementWhereInput | group_managementWhereInput[]
    server?: IntNullableFilter<"group_management"> | number | null
    auth_mode?: IntNullableFilter<"group_management"> | number | null
    auth_password_min?: IntNullableFilter<"group_management"> | number | null
    currency?: StringNullableFilter<"group_management"> | string | null
    is_active?: BoolNullableFilter<"group_management"> | boolean | null
    synced_at?: DateTimeNullableFilter<"group_management"> | Date | string | null
    created_at?: DateTimeNullableFilter<"group_management"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"group_management"> | Date | string | null
    dedicated_name?: StringNullableFilter<"group_management"> | string | null
    account_type?: StringNullableFilter<"group_management"> | string | null
    leverage?: IntNullableFilter<"group_management"> | number | null
    min_deposit?: DecimalNullableFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
    spread?: DecimalNullableFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
  }, "id" | "group">

  export type group_managementOrderByWithAggregationInput = {
    id?: SortOrder
    group?: SortOrder
    server?: SortOrderInput | SortOrder
    auth_mode?: SortOrderInput | SortOrder
    auth_password_min?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    synced_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    dedicated_name?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    leverage?: SortOrderInput | SortOrder
    min_deposit?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    _count?: group_managementCountOrderByAggregateInput
    _avg?: group_managementAvgOrderByAggregateInput
    _max?: group_managementMaxOrderByAggregateInput
    _min?: group_managementMinOrderByAggregateInput
    _sum?: group_managementSumOrderByAggregateInput
  }

  export type group_managementScalarWhereWithAggregatesInput = {
    AND?: group_managementScalarWhereWithAggregatesInput | group_managementScalarWhereWithAggregatesInput[]
    OR?: group_managementScalarWhereWithAggregatesInput[]
    NOT?: group_managementScalarWhereWithAggregatesInput | group_managementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"group_management"> | number
    group?: StringWithAggregatesFilter<"group_management"> | string
    server?: IntNullableWithAggregatesFilter<"group_management"> | number | null
    auth_mode?: IntNullableWithAggregatesFilter<"group_management"> | number | null
    auth_password_min?: IntNullableWithAggregatesFilter<"group_management"> | number | null
    currency?: StringNullableWithAggregatesFilter<"group_management"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"group_management"> | boolean | null
    synced_at?: DateTimeNullableWithAggregatesFilter<"group_management"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"group_management"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"group_management"> | Date | string | null
    dedicated_name?: StringNullableWithAggregatesFilter<"group_management"> | string | null
    account_type?: StringNullableWithAggregatesFilter<"group_management"> | string | null
    leverage?: IntNullableWithAggregatesFilter<"group_management"> | number | null
    min_deposit?: DecimalNullableWithAggregatesFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
    spread?: DecimalNullableWithAggregatesFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableWithAggregatesFilter<"group_management"> | Decimal | DecimalJsLike | number | string | null
  }

  export type SymbolGroupAccessWhereInput = {
    AND?: SymbolGroupAccessWhereInput | SymbolGroupAccessWhereInput[]
    OR?: SymbolGroupAccessWhereInput[]
    NOT?: SymbolGroupAccessWhereInput | SymbolGroupAccessWhereInput[]
    id?: IntFilter<"SymbolGroupAccess"> | number
    symbol?: StringFilter<"SymbolGroupAccess"> | string
    group_name?: StringFilter<"SymbolGroupAccess"> | string
    is_allowed?: BoolFilter<"SymbolGroupAccess"> | boolean
    created_at?: DateTimeFilter<"SymbolGroupAccess"> | Date | string
    updated_at?: DateTimeFilter<"SymbolGroupAccess"> | Date | string
  }

  export type SymbolGroupAccessOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    group_name?: SortOrder
    is_allowed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SymbolGroupAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol_group_name?: SymbolGroupAccessSymbolGroup_nameCompoundUniqueInput
    AND?: SymbolGroupAccessWhereInput | SymbolGroupAccessWhereInput[]
    OR?: SymbolGroupAccessWhereInput[]
    NOT?: SymbolGroupAccessWhereInput | SymbolGroupAccessWhereInput[]
    symbol?: StringFilter<"SymbolGroupAccess"> | string
    group_name?: StringFilter<"SymbolGroupAccess"> | string
    is_allowed?: BoolFilter<"SymbolGroupAccess"> | boolean
    created_at?: DateTimeFilter<"SymbolGroupAccess"> | Date | string
    updated_at?: DateTimeFilter<"SymbolGroupAccess"> | Date | string
  }, "id" | "symbol_group_name">

  export type SymbolGroupAccessOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    group_name?: SortOrder
    is_allowed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SymbolGroupAccessCountOrderByAggregateInput
    _avg?: SymbolGroupAccessAvgOrderByAggregateInput
    _max?: SymbolGroupAccessMaxOrderByAggregateInput
    _min?: SymbolGroupAccessMinOrderByAggregateInput
    _sum?: SymbolGroupAccessSumOrderByAggregateInput
  }

  export type SymbolGroupAccessScalarWhereWithAggregatesInput = {
    AND?: SymbolGroupAccessScalarWhereWithAggregatesInput | SymbolGroupAccessScalarWhereWithAggregatesInput[]
    OR?: SymbolGroupAccessScalarWhereWithAggregatesInput[]
    NOT?: SymbolGroupAccessScalarWhereWithAggregatesInput | SymbolGroupAccessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SymbolGroupAccess"> | number
    symbol?: StringWithAggregatesFilter<"SymbolGroupAccess"> | string
    group_name?: StringWithAggregatesFilter<"SymbolGroupAccess"> | string
    is_allowed?: BoolWithAggregatesFilter<"SymbolGroupAccess"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"SymbolGroupAccess"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SymbolGroupAccess"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    currency?: StringFilter<"Transaction"> | string
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    depositId?: StringNullableFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"Transaction"> | string | null
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    currency?: StringFilter<"Transaction"> | string
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    transactionId?: StringNullableFilter<"Transaction"> | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    depositId?: StringNullableFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"Transaction"> | string | null
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    depositId?: SortOrderInput | SortOrder
    withdrawalId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    status?: StringWithAggregatesFilter<"Transaction"> | string
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    depositId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    withdrawalId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type admin_transactionsWhereInput = {
    AND?: admin_transactionsWhereInput | admin_transactionsWhereInput[]
    OR?: admin_transactionsWhereInput[]
    NOT?: admin_transactionsWhereInput | admin_transactionsWhereInput[]
    id?: BigIntFilter<"admin_transactions"> | bigint | number
    admin_id?: IntFilter<"admin_transactions"> | number
    user_id?: StringNullableFilter<"admin_transactions"> | string | null
    mt5_account_id?: StringNullableFilter<"admin_transactions"> | string | null
    mt5_login?: StringFilter<"admin_transactions"> | string
    operation_type?: StringFilter<"admin_transactions"> | string
    amount?: DecimalFilter<"admin_transactions"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"admin_transactions"> | string
    status?: StringFilter<"admin_transactions"> | string
    comment?: StringNullableFilter<"admin_transactions"> | string | null
    external_transaction_id?: StringNullableFilter<"admin_transactions"> | string | null
    ip_address?: StringNullableFilter<"admin_transactions"> | string | null
    user_agent?: StringNullableFilter<"admin_transactions"> | string | null
    error_message?: StringNullableFilter<"admin_transactions"> | string | null
    created_at?: DateTimeFilter<"admin_transactions"> | Date | string
    updated_at?: DateTimeFilter<"admin_transactions"> | Date | string
  }

  export type admin_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    mt5_account_id?: SortOrderInput | SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    external_transaction_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type admin_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: admin_transactionsWhereInput | admin_transactionsWhereInput[]
    OR?: admin_transactionsWhereInput[]
    NOT?: admin_transactionsWhereInput | admin_transactionsWhereInput[]
    admin_id?: IntFilter<"admin_transactions"> | number
    user_id?: StringNullableFilter<"admin_transactions"> | string | null
    mt5_account_id?: StringNullableFilter<"admin_transactions"> | string | null
    mt5_login?: StringFilter<"admin_transactions"> | string
    operation_type?: StringFilter<"admin_transactions"> | string
    amount?: DecimalFilter<"admin_transactions"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"admin_transactions"> | string
    status?: StringFilter<"admin_transactions"> | string
    comment?: StringNullableFilter<"admin_transactions"> | string | null
    external_transaction_id?: StringNullableFilter<"admin_transactions"> | string | null
    ip_address?: StringNullableFilter<"admin_transactions"> | string | null
    user_agent?: StringNullableFilter<"admin_transactions"> | string | null
    error_message?: StringNullableFilter<"admin_transactions"> | string | null
    created_at?: DateTimeFilter<"admin_transactions"> | Date | string
    updated_at?: DateTimeFilter<"admin_transactions"> | Date | string
  }, "id">

  export type admin_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    mt5_account_id?: SortOrderInput | SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    external_transaction_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: admin_transactionsCountOrderByAggregateInput
    _avg?: admin_transactionsAvgOrderByAggregateInput
    _max?: admin_transactionsMaxOrderByAggregateInput
    _min?: admin_transactionsMinOrderByAggregateInput
    _sum?: admin_transactionsSumOrderByAggregateInput
  }

  export type admin_transactionsScalarWhereWithAggregatesInput = {
    AND?: admin_transactionsScalarWhereWithAggregatesInput | admin_transactionsScalarWhereWithAggregatesInput[]
    OR?: admin_transactionsScalarWhereWithAggregatesInput[]
    NOT?: admin_transactionsScalarWhereWithAggregatesInput | admin_transactionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"admin_transactions"> | bigint | number
    admin_id?: IntWithAggregatesFilter<"admin_transactions"> | number
    user_id?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    mt5_account_id?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    mt5_login?: StringWithAggregatesFilter<"admin_transactions"> | string
    operation_type?: StringWithAggregatesFilter<"admin_transactions"> | string
    amount?: DecimalWithAggregatesFilter<"admin_transactions"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"admin_transactions"> | string
    status?: StringWithAggregatesFilter<"admin_transactions"> | string
    comment?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    external_transaction_id?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    error_message?: StringNullableWithAggregatesFilter<"admin_transactions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"admin_transactions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"admin_transactions"> | Date | string
  }

  export type countriesWhereInput = {
    AND?: countriesWhereInput | countriesWhereInput[]
    OR?: countriesWhereInput[]
    NOT?: countriesWhereInput | countriesWhereInput[]
    code?: StringFilter<"countries"> | string
    country?: StringNullableFilter<"countries"> | string | null
    country_code?: StringNullableFilter<"countries"> | string | null
  }

  export type countriesOrderByWithRelationInput = {
    code?: SortOrder
    country?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
  }

  export type countriesWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: countriesWhereInput | countriesWhereInput[]
    OR?: countriesWhereInput[]
    NOT?: countriesWhereInput | countriesWhereInput[]
    country?: StringNullableFilter<"countries"> | string | null
    country_code?: StringNullableFilter<"countries"> | string | null
  }, "code">

  export type countriesOrderByWithAggregationInput = {
    code?: SortOrder
    country?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    _count?: countriesCountOrderByAggregateInput
    _max?: countriesMaxOrderByAggregateInput
    _min?: countriesMinOrderByAggregateInput
  }

  export type countriesScalarWhereWithAggregatesInput = {
    AND?: countriesScalarWhereWithAggregatesInput | countriesScalarWhereWithAggregatesInput[]
    OR?: countriesScalarWhereWithAggregatesInput[]
    NOT?: countriesScalarWhereWithAggregatesInput | countriesScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"countries"> | string
    country?: StringNullableWithAggregatesFilter<"countries"> | string | null
    country_code?: StringNullableWithAggregatesFilter<"countries"> | string | null
  }

  export type country_adminsWhereInput = {
    AND?: country_adminsWhereInput | country_adminsWhereInput[]
    OR?: country_adminsWhereInput[]
    NOT?: country_adminsWhereInput | country_adminsWhereInput[]
    id?: IntFilter<"country_admins"> | number
    name?: StringFilter<"country_admins"> | string
    email?: StringFilter<"country_admins"> | string
    status?: StringNullableFilter<"country_admins"> | string | null
    country_code?: StringNullableFilter<"country_admins"> | string | null
    features?: StringNullableFilter<"country_admins"> | string | null
    created_at?: DateTimeNullableFilter<"country_admins"> | Date | string | null
  }

  export type country_adminsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type country_adminsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: country_adminsWhereInput | country_adminsWhereInput[]
    OR?: country_adminsWhereInput[]
    NOT?: country_adminsWhereInput | country_adminsWhereInput[]
    name?: StringFilter<"country_admins"> | string
    status?: StringNullableFilter<"country_admins"> | string | null
    country_code?: StringNullableFilter<"country_admins"> | string | null
    features?: StringNullableFilter<"country_admins"> | string | null
    created_at?: DateTimeNullableFilter<"country_admins"> | Date | string | null
  }, "id" | "email">

  export type country_adminsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrderInput | SortOrder
    country_code?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: country_adminsCountOrderByAggregateInput
    _avg?: country_adminsAvgOrderByAggregateInput
    _max?: country_adminsMaxOrderByAggregateInput
    _min?: country_adminsMinOrderByAggregateInput
    _sum?: country_adminsSumOrderByAggregateInput
  }

  export type country_adminsScalarWhereWithAggregatesInput = {
    AND?: country_adminsScalarWhereWithAggregatesInput | country_adminsScalarWhereWithAggregatesInput[]
    OR?: country_adminsScalarWhereWithAggregatesInput[]
    NOT?: country_adminsScalarWhereWithAggregatesInput | country_adminsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"country_admins"> | number
    name?: StringWithAggregatesFilter<"country_admins"> | string
    email?: StringWithAggregatesFilter<"country_admins"> | string
    status?: StringNullableWithAggregatesFilter<"country_admins"> | string | null
    country_code?: StringNullableWithAggregatesFilter<"country_admins"> | string | null
    features?: StringNullableWithAggregatesFilter<"country_admins"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"country_admins"> | Date | string | null
  }

  export type email_templatesWhereInput = {
    AND?: email_templatesWhereInput | email_templatesWhereInput[]
    OR?: email_templatesWhereInput[]
    NOT?: email_templatesWhereInput | email_templatesWhereInput[]
    id?: IntFilter<"email_templates"> | number
    name?: StringFilter<"email_templates"> | string
    description?: StringNullableFilter<"email_templates"> | string | null
    html_code?: StringFilter<"email_templates"> | string
    variables?: StringNullableListFilter<"email_templates">
    is_default?: BoolNullableFilter<"email_templates"> | boolean | null
    preview_image_url?: StringNullableFilter<"email_templates"> | string | null
    created_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    created_by?: StringNullableFilter<"email_templates"> | string | null
  }

  export type email_templatesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    html_code?: SortOrder
    variables?: SortOrder
    is_default?: SortOrderInput | SortOrder
    preview_image_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
  }

  export type email_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: email_templatesWhereInput | email_templatesWhereInput[]
    OR?: email_templatesWhereInput[]
    NOT?: email_templatesWhereInput | email_templatesWhereInput[]
    description?: StringNullableFilter<"email_templates"> | string | null
    html_code?: StringFilter<"email_templates"> | string
    variables?: StringNullableListFilter<"email_templates">
    is_default?: BoolNullableFilter<"email_templates"> | boolean | null
    preview_image_url?: StringNullableFilter<"email_templates"> | string | null
    created_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"email_templates"> | Date | string | null
    created_by?: StringNullableFilter<"email_templates"> | string | null
  }, "id" | "name">

  export type email_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    html_code?: SortOrder
    variables?: SortOrder
    is_default?: SortOrderInput | SortOrder
    preview_image_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: email_templatesCountOrderByAggregateInput
    _avg?: email_templatesAvgOrderByAggregateInput
    _max?: email_templatesMaxOrderByAggregateInput
    _min?: email_templatesMinOrderByAggregateInput
    _sum?: email_templatesSumOrderByAggregateInput
  }

  export type email_templatesScalarWhereWithAggregatesInput = {
    AND?: email_templatesScalarWhereWithAggregatesInput | email_templatesScalarWhereWithAggregatesInput[]
    OR?: email_templatesScalarWhereWithAggregatesInput[]
    NOT?: email_templatesScalarWhereWithAggregatesInput | email_templatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"email_templates"> | number
    name?: StringWithAggregatesFilter<"email_templates"> | string
    description?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    html_code?: StringWithAggregatesFilter<"email_templates"> | string
    variables?: StringNullableListFilter<"email_templates">
    is_default?: BoolNullableWithAggregatesFilter<"email_templates"> | boolean | null
    preview_image_url?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"email_templates"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"email_templates"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"email_templates"> | string | null
  }

  export type ib_client_linkingWhereInput = {
    AND?: ib_client_linkingWhereInput | ib_client_linkingWhereInput[]
    OR?: ib_client_linkingWhereInput[]
    NOT?: ib_client_linkingWhereInput | ib_client_linkingWhereInput[]
    id?: IntFilter<"ib_client_linking"> | number
    user_id?: StringFilter<"ib_client_linking"> | string
    user_name?: StringFilter<"ib_client_linking"> | string
    user_email?: StringFilter<"ib_client_linking"> | string
    user_account_id?: StringNullableFilter<"ib_client_linking"> | string | null
    current_ib_id?: IntNullableFilter<"ib_client_linking"> | number | null
    current_ib_name?: StringNullableFilter<"ib_client_linking"> | string | null
    current_ib_code?: StringNullableFilter<"ib_client_linking"> | string | null
    assigned_ib_id?: IntFilter<"ib_client_linking"> | number
    assigned_ib_name?: StringFilter<"ib_client_linking"> | string
    assigned_ib_code?: StringNullableFilter<"ib_client_linking"> | string | null
    assigned_ib_email?: StringNullableFilter<"ib_client_linking"> | string | null
    status?: StringNullableFilter<"ib_client_linking"> | string | null
    direct_volume_lots?: DecimalNullableFilter<"ib_client_linking"> | Decimal | DecimalJsLike | number | string | null
    direct_commission?: DecimalNullableFilter<"ib_client_linking"> | Decimal | DecimalJsLike | number | string | null
    linked_at?: DateTimeNullableFilter<"ib_client_linking"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_client_linking"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_client_linking"> | Date | string | null
    created_by?: IntNullableFilter<"ib_client_linking"> | number | null
  }

  export type ib_client_linkingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    user_account_id?: SortOrderInput | SortOrder
    current_ib_id?: SortOrderInput | SortOrder
    current_ib_name?: SortOrderInput | SortOrder
    current_ib_code?: SortOrderInput | SortOrder
    assigned_ib_id?: SortOrder
    assigned_ib_name?: SortOrder
    assigned_ib_code?: SortOrderInput | SortOrder
    assigned_ib_email?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    direct_volume_lots?: SortOrderInput | SortOrder
    direct_commission?: SortOrderInput | SortOrder
    linked_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
  }

  export type ib_client_linkingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_assigned_ib_id_status?: ib_client_linkingUser_idAssigned_ib_idStatusCompoundUniqueInput
    AND?: ib_client_linkingWhereInput | ib_client_linkingWhereInput[]
    OR?: ib_client_linkingWhereInput[]
    NOT?: ib_client_linkingWhereInput | ib_client_linkingWhereInput[]
    user_id?: StringFilter<"ib_client_linking"> | string
    user_name?: StringFilter<"ib_client_linking"> | string
    user_email?: StringFilter<"ib_client_linking"> | string
    user_account_id?: StringNullableFilter<"ib_client_linking"> | string | null
    current_ib_id?: IntNullableFilter<"ib_client_linking"> | number | null
    current_ib_name?: StringNullableFilter<"ib_client_linking"> | string | null
    current_ib_code?: StringNullableFilter<"ib_client_linking"> | string | null
    assigned_ib_id?: IntFilter<"ib_client_linking"> | number
    assigned_ib_name?: StringFilter<"ib_client_linking"> | string
    assigned_ib_code?: StringNullableFilter<"ib_client_linking"> | string | null
    assigned_ib_email?: StringNullableFilter<"ib_client_linking"> | string | null
    status?: StringNullableFilter<"ib_client_linking"> | string | null
    direct_volume_lots?: DecimalNullableFilter<"ib_client_linking"> | Decimal | DecimalJsLike | number | string | null
    direct_commission?: DecimalNullableFilter<"ib_client_linking"> | Decimal | DecimalJsLike | number | string | null
    linked_at?: DateTimeNullableFilter<"ib_client_linking"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_client_linking"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_client_linking"> | Date | string | null
    created_by?: IntNullableFilter<"ib_client_linking"> | number | null
  }, "id" | "user_id_assigned_ib_id_status">

  export type ib_client_linkingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    user_account_id?: SortOrderInput | SortOrder
    current_ib_id?: SortOrderInput | SortOrder
    current_ib_name?: SortOrderInput | SortOrder
    current_ib_code?: SortOrderInput | SortOrder
    assigned_ib_id?: SortOrder
    assigned_ib_name?: SortOrder
    assigned_ib_code?: SortOrderInput | SortOrder
    assigned_ib_email?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    direct_volume_lots?: SortOrderInput | SortOrder
    direct_commission?: SortOrderInput | SortOrder
    linked_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: ib_client_linkingCountOrderByAggregateInput
    _avg?: ib_client_linkingAvgOrderByAggregateInput
    _max?: ib_client_linkingMaxOrderByAggregateInput
    _min?: ib_client_linkingMinOrderByAggregateInput
    _sum?: ib_client_linkingSumOrderByAggregateInput
  }

  export type ib_client_linkingScalarWhereWithAggregatesInput = {
    AND?: ib_client_linkingScalarWhereWithAggregatesInput | ib_client_linkingScalarWhereWithAggregatesInput[]
    OR?: ib_client_linkingScalarWhereWithAggregatesInput[]
    NOT?: ib_client_linkingScalarWhereWithAggregatesInput | ib_client_linkingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_client_linking"> | number
    user_id?: StringWithAggregatesFilter<"ib_client_linking"> | string
    user_name?: StringWithAggregatesFilter<"ib_client_linking"> | string
    user_email?: StringWithAggregatesFilter<"ib_client_linking"> | string
    user_account_id?: StringNullableWithAggregatesFilter<"ib_client_linking"> | string | null
    current_ib_id?: IntNullableWithAggregatesFilter<"ib_client_linking"> | number | null
    current_ib_name?: StringNullableWithAggregatesFilter<"ib_client_linking"> | string | null
    current_ib_code?: StringNullableWithAggregatesFilter<"ib_client_linking"> | string | null
    assigned_ib_id?: IntWithAggregatesFilter<"ib_client_linking"> | number
    assigned_ib_name?: StringWithAggregatesFilter<"ib_client_linking"> | string
    assigned_ib_code?: StringNullableWithAggregatesFilter<"ib_client_linking"> | string | null
    assigned_ib_email?: StringNullableWithAggregatesFilter<"ib_client_linking"> | string | null
    status?: StringNullableWithAggregatesFilter<"ib_client_linking"> | string | null
    direct_volume_lots?: DecimalNullableWithAggregatesFilter<"ib_client_linking"> | Decimal | DecimalJsLike | number | string | null
    direct_commission?: DecimalNullableWithAggregatesFilter<"ib_client_linking"> | Decimal | DecimalJsLike | number | string | null
    linked_at?: DateTimeNullableWithAggregatesFilter<"ib_client_linking"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_client_linking"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_client_linking"> | Date | string | null
    created_by?: IntNullableWithAggregatesFilter<"ib_client_linking"> | number | null
  }

  export type ib_client_linking_historyWhereInput = {
    AND?: ib_client_linking_historyWhereInput | ib_client_linking_historyWhereInput[]
    OR?: ib_client_linking_historyWhereInput[]
    NOT?: ib_client_linking_historyWhereInput | ib_client_linking_historyWhereInput[]
    id?: IntFilter<"ib_client_linking_history"> | number
    linking_id?: IntNullableFilter<"ib_client_linking_history"> | number | null
    user_id?: StringFilter<"ib_client_linking_history"> | string
    user_name?: StringFilter<"ib_client_linking_history"> | string
    user_email?: StringFilter<"ib_client_linking_history"> | string
    from_ib_id?: IntNullableFilter<"ib_client_linking_history"> | number | null
    from_ib_name?: StringNullableFilter<"ib_client_linking_history"> | string | null
    from_ib_code?: StringNullableFilter<"ib_client_linking_history"> | string | null
    to_ib_id?: IntFilter<"ib_client_linking_history"> | number
    to_ib_name?: StringFilter<"ib_client_linking_history"> | string
    to_ib_code?: StringNullableFilter<"ib_client_linking_history"> | string | null
    action?: StringFilter<"ib_client_linking_history"> | string
    moved_by?: IntNullableFilter<"ib_client_linking_history"> | number | null
    moved_by_name?: StringNullableFilter<"ib_client_linking_history"> | string | null
    notes?: StringNullableFilter<"ib_client_linking_history"> | string | null
    created_at?: DateTimeNullableFilter<"ib_client_linking_history"> | Date | string | null
  }

  export type ib_client_linking_historyOrderByWithRelationInput = {
    id?: SortOrder
    linking_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    from_ib_id?: SortOrderInput | SortOrder
    from_ib_name?: SortOrderInput | SortOrder
    from_ib_code?: SortOrderInput | SortOrder
    to_ib_id?: SortOrder
    to_ib_name?: SortOrder
    to_ib_code?: SortOrderInput | SortOrder
    action?: SortOrder
    moved_by?: SortOrderInput | SortOrder
    moved_by_name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type ib_client_linking_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ib_client_linking_historyWhereInput | ib_client_linking_historyWhereInput[]
    OR?: ib_client_linking_historyWhereInput[]
    NOT?: ib_client_linking_historyWhereInput | ib_client_linking_historyWhereInput[]
    linking_id?: IntNullableFilter<"ib_client_linking_history"> | number | null
    user_id?: StringFilter<"ib_client_linking_history"> | string
    user_name?: StringFilter<"ib_client_linking_history"> | string
    user_email?: StringFilter<"ib_client_linking_history"> | string
    from_ib_id?: IntNullableFilter<"ib_client_linking_history"> | number | null
    from_ib_name?: StringNullableFilter<"ib_client_linking_history"> | string | null
    from_ib_code?: StringNullableFilter<"ib_client_linking_history"> | string | null
    to_ib_id?: IntFilter<"ib_client_linking_history"> | number
    to_ib_name?: StringFilter<"ib_client_linking_history"> | string
    to_ib_code?: StringNullableFilter<"ib_client_linking_history"> | string | null
    action?: StringFilter<"ib_client_linking_history"> | string
    moved_by?: IntNullableFilter<"ib_client_linking_history"> | number | null
    moved_by_name?: StringNullableFilter<"ib_client_linking_history"> | string | null
    notes?: StringNullableFilter<"ib_client_linking_history"> | string | null
    created_at?: DateTimeNullableFilter<"ib_client_linking_history"> | Date | string | null
  }, "id">

  export type ib_client_linking_historyOrderByWithAggregationInput = {
    id?: SortOrder
    linking_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    from_ib_id?: SortOrderInput | SortOrder
    from_ib_name?: SortOrderInput | SortOrder
    from_ib_code?: SortOrderInput | SortOrder
    to_ib_id?: SortOrder
    to_ib_name?: SortOrder
    to_ib_code?: SortOrderInput | SortOrder
    action?: SortOrder
    moved_by?: SortOrderInput | SortOrder
    moved_by_name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ib_client_linking_historyCountOrderByAggregateInput
    _avg?: ib_client_linking_historyAvgOrderByAggregateInput
    _max?: ib_client_linking_historyMaxOrderByAggregateInput
    _min?: ib_client_linking_historyMinOrderByAggregateInput
    _sum?: ib_client_linking_historySumOrderByAggregateInput
  }

  export type ib_client_linking_historyScalarWhereWithAggregatesInput = {
    AND?: ib_client_linking_historyScalarWhereWithAggregatesInput | ib_client_linking_historyScalarWhereWithAggregatesInput[]
    OR?: ib_client_linking_historyScalarWhereWithAggregatesInput[]
    NOT?: ib_client_linking_historyScalarWhereWithAggregatesInput | ib_client_linking_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_client_linking_history"> | number
    linking_id?: IntNullableWithAggregatesFilter<"ib_client_linking_history"> | number | null
    user_id?: StringWithAggregatesFilter<"ib_client_linking_history"> | string
    user_name?: StringWithAggregatesFilter<"ib_client_linking_history"> | string
    user_email?: StringWithAggregatesFilter<"ib_client_linking_history"> | string
    from_ib_id?: IntNullableWithAggregatesFilter<"ib_client_linking_history"> | number | null
    from_ib_name?: StringNullableWithAggregatesFilter<"ib_client_linking_history"> | string | null
    from_ib_code?: StringNullableWithAggregatesFilter<"ib_client_linking_history"> | string | null
    to_ib_id?: IntWithAggregatesFilter<"ib_client_linking_history"> | number
    to_ib_name?: StringWithAggregatesFilter<"ib_client_linking_history"> | string
    to_ib_code?: StringNullableWithAggregatesFilter<"ib_client_linking_history"> | string | null
    action?: StringWithAggregatesFilter<"ib_client_linking_history"> | string
    moved_by?: IntNullableWithAggregatesFilter<"ib_client_linking_history"> | number | null
    moved_by_name?: StringNullableWithAggregatesFilter<"ib_client_linking_history"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ib_client_linking_history"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_client_linking_history"> | Date | string | null
  }

  export type ib_commissionWhereInput = {
    AND?: ib_commissionWhereInput | ib_commissionWhereInput[]
    OR?: ib_commissionWhereInput[]
    NOT?: ib_commissionWhereInput | ib_commissionWhereInput[]
    id?: IntFilter<"ib_commission"> | number
    ib_request_id?: IntFilter<"ib_commission"> | number
    user_id?: StringFilter<"ib_commission"> | string
    total_commission?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    last_updated?: DateTimeNullableFilter<"ib_commission"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_commission"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_commission"> | Date | string | null
    total_trades?: IntNullableFilter<"ib_commission"> | number | null
    total_lots?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    spread_commission?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    total_commission?: SortOrderInput | SortOrder
    last_updated?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    total_trades?: SortOrderInput | SortOrder
    total_lots?: SortOrderInput | SortOrder
    fixed_commission?: SortOrderInput | SortOrder
    spread_commission?: SortOrderInput | SortOrder
  }

  export type ib_commissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ib_request_id_user_id?: ib_commissionIb_request_idUser_idCompoundUniqueInput
    AND?: ib_commissionWhereInput | ib_commissionWhereInput[]
    OR?: ib_commissionWhereInput[]
    NOT?: ib_commissionWhereInput | ib_commissionWhereInput[]
    ib_request_id?: IntFilter<"ib_commission"> | number
    user_id?: StringFilter<"ib_commission"> | string
    total_commission?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    last_updated?: DateTimeNullableFilter<"ib_commission"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_commission"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_commission"> | Date | string | null
    total_trades?: IntNullableFilter<"ib_commission"> | number | null
    total_lots?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    spread_commission?: DecimalNullableFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
  }, "id" | "ib_request_id_user_id">

  export type ib_commissionOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    total_commission?: SortOrderInput | SortOrder
    last_updated?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    total_trades?: SortOrderInput | SortOrder
    total_lots?: SortOrderInput | SortOrder
    fixed_commission?: SortOrderInput | SortOrder
    spread_commission?: SortOrderInput | SortOrder
    _count?: ib_commissionCountOrderByAggregateInput
    _avg?: ib_commissionAvgOrderByAggregateInput
    _max?: ib_commissionMaxOrderByAggregateInput
    _min?: ib_commissionMinOrderByAggregateInput
    _sum?: ib_commissionSumOrderByAggregateInput
  }

  export type ib_commissionScalarWhereWithAggregatesInput = {
    AND?: ib_commissionScalarWhereWithAggregatesInput | ib_commissionScalarWhereWithAggregatesInput[]
    OR?: ib_commissionScalarWhereWithAggregatesInput[]
    NOT?: ib_commissionScalarWhereWithAggregatesInput | ib_commissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_commission"> | number
    ib_request_id?: IntWithAggregatesFilter<"ib_commission"> | number
    user_id?: StringWithAggregatesFilter<"ib_commission"> | string
    total_commission?: DecimalNullableWithAggregatesFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    last_updated?: DateTimeNullableWithAggregatesFilter<"ib_commission"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_commission"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_commission"> | Date | string | null
    total_trades?: IntNullableWithAggregatesFilter<"ib_commission"> | number | null
    total_lots?: DecimalNullableWithAggregatesFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: DecimalNullableWithAggregatesFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
    spread_commission?: DecimalNullableWithAggregatesFilter<"ib_commission"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ib_level_up_historyWhereInput = {
    AND?: ib_level_up_historyWhereInput | ib_level_up_historyWhereInput[]
    OR?: ib_level_up_historyWhereInput[]
    NOT?: ib_level_up_historyWhereInput | ib_level_up_historyWhereInput[]
    id?: IntFilter<"ib_level_up_history"> | number
    ib_request_id?: IntFilter<"ib_level_up_history"> | number
    from_structure_id?: IntNullableFilter<"ib_level_up_history"> | number | null
    to_structure_id?: IntFilter<"ib_level_up_history"> | number
    from_structure_name?: StringNullableFilter<"ib_level_up_history"> | string | null
    to_structure_name?: StringNullableFilter<"ib_level_up_history"> | string | null
    trading_volume_at_upgrade?: DecimalNullableFilter<"ib_level_up_history"> | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: IntNullableFilter<"ib_level_up_history"> | number | null
    upgraded_at?: DateTimeNullableFilter<"ib_level_up_history"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_level_up_history"> | Date | string | null
  }

  export type ib_level_up_historyOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrderInput | SortOrder
    to_structure_id?: SortOrder
    from_structure_name?: SortOrderInput | SortOrder
    to_structure_name?: SortOrderInput | SortOrder
    trading_volume_at_upgrade?: SortOrderInput | SortOrder
    active_clients_at_upgrade?: SortOrderInput | SortOrder
    upgraded_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type ib_level_up_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ib_level_up_historyWhereInput | ib_level_up_historyWhereInput[]
    OR?: ib_level_up_historyWhereInput[]
    NOT?: ib_level_up_historyWhereInput | ib_level_up_historyWhereInput[]
    ib_request_id?: IntFilter<"ib_level_up_history"> | number
    from_structure_id?: IntNullableFilter<"ib_level_up_history"> | number | null
    to_structure_id?: IntFilter<"ib_level_up_history"> | number
    from_structure_name?: StringNullableFilter<"ib_level_up_history"> | string | null
    to_structure_name?: StringNullableFilter<"ib_level_up_history"> | string | null
    trading_volume_at_upgrade?: DecimalNullableFilter<"ib_level_up_history"> | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: IntNullableFilter<"ib_level_up_history"> | number | null
    upgraded_at?: DateTimeNullableFilter<"ib_level_up_history"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_level_up_history"> | Date | string | null
  }, "id">

  export type ib_level_up_historyOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrderInput | SortOrder
    to_structure_id?: SortOrder
    from_structure_name?: SortOrderInput | SortOrder
    to_structure_name?: SortOrderInput | SortOrder
    trading_volume_at_upgrade?: SortOrderInput | SortOrder
    active_clients_at_upgrade?: SortOrderInput | SortOrder
    upgraded_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ib_level_up_historyCountOrderByAggregateInput
    _avg?: ib_level_up_historyAvgOrderByAggregateInput
    _max?: ib_level_up_historyMaxOrderByAggregateInput
    _min?: ib_level_up_historyMinOrderByAggregateInput
    _sum?: ib_level_up_historySumOrderByAggregateInput
  }

  export type ib_level_up_historyScalarWhereWithAggregatesInput = {
    AND?: ib_level_up_historyScalarWhereWithAggregatesInput | ib_level_up_historyScalarWhereWithAggregatesInput[]
    OR?: ib_level_up_historyScalarWhereWithAggregatesInput[]
    NOT?: ib_level_up_historyScalarWhereWithAggregatesInput | ib_level_up_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_level_up_history"> | number
    ib_request_id?: IntWithAggregatesFilter<"ib_level_up_history"> | number
    from_structure_id?: IntNullableWithAggregatesFilter<"ib_level_up_history"> | number | null
    to_structure_id?: IntWithAggregatesFilter<"ib_level_up_history"> | number
    from_structure_name?: StringNullableWithAggregatesFilter<"ib_level_up_history"> | string | null
    to_structure_name?: StringNullableWithAggregatesFilter<"ib_level_up_history"> | string | null
    trading_volume_at_upgrade?: DecimalNullableWithAggregatesFilter<"ib_level_up_history"> | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: IntNullableWithAggregatesFilter<"ib_level_up_history"> | number | null
    upgraded_at?: DateTimeNullableWithAggregatesFilter<"ib_level_up_history"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_level_up_history"> | Date | string | null
  }

  export type ib_referralsWhereInput = {
    AND?: ib_referralsWhereInput | ib_referralsWhereInput[]
    OR?: ib_referralsWhereInput[]
    NOT?: ib_referralsWhereInput | ib_referralsWhereInput[]
    id?: IntFilter<"ib_referrals"> | number
    ib_request_id?: IntFilter<"ib_referrals"> | number
    user_id?: StringNullableFilter<"ib_referrals"> | string | null
    email?: StringFilter<"ib_referrals"> | string
    referral_code?: StringFilter<"ib_referrals"> | string
    source?: StringNullableFilter<"ib_referrals"> | string | null
    created_at?: DateTimeNullableFilter<"ib_referrals"> | Date | string | null
  }

  export type ib_referralsOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    email?: SortOrder
    referral_code?: SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type ib_referralsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ib_referralsWhereInput | ib_referralsWhereInput[]
    OR?: ib_referralsWhereInput[]
    NOT?: ib_referralsWhereInput | ib_referralsWhereInput[]
    ib_request_id?: IntFilter<"ib_referrals"> | number
    user_id?: StringNullableFilter<"ib_referrals"> | string | null
    email?: StringFilter<"ib_referrals"> | string
    referral_code?: StringFilter<"ib_referrals"> | string
    source?: StringNullableFilter<"ib_referrals"> | string | null
    created_at?: DateTimeNullableFilter<"ib_referrals"> | Date | string | null
  }, "id">

  export type ib_referralsOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    email?: SortOrder
    referral_code?: SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ib_referralsCountOrderByAggregateInput
    _avg?: ib_referralsAvgOrderByAggregateInput
    _max?: ib_referralsMaxOrderByAggregateInput
    _min?: ib_referralsMinOrderByAggregateInput
    _sum?: ib_referralsSumOrderByAggregateInput
  }

  export type ib_referralsScalarWhereWithAggregatesInput = {
    AND?: ib_referralsScalarWhereWithAggregatesInput | ib_referralsScalarWhereWithAggregatesInput[]
    OR?: ib_referralsScalarWhereWithAggregatesInput[]
    NOT?: ib_referralsScalarWhereWithAggregatesInput | ib_referralsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_referrals"> | number
    ib_request_id?: IntWithAggregatesFilter<"ib_referrals"> | number
    user_id?: StringNullableWithAggregatesFilter<"ib_referrals"> | string | null
    email?: StringWithAggregatesFilter<"ib_referrals"> | string
    referral_code?: StringWithAggregatesFilter<"ib_referrals"> | string
    source?: StringNullableWithAggregatesFilter<"ib_referrals"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_referrals"> | Date | string | null
  }

  export type ib_reward_claimsWhereInput = {
    AND?: ib_reward_claimsWhereInput | ib_reward_claimsWhereInput[]
    OR?: ib_reward_claimsWhereInput[]
    NOT?: ib_reward_claimsWhereInput | ib_reward_claimsWhereInput[]
    id?: IntFilter<"ib_reward_claims"> | number
    ib_request_id?: IntFilter<"ib_reward_claims"> | number
    user_id?: StringFilter<"ib_reward_claims"> | string
    reward_id?: IntFilter<"ib_reward_claims"> | number
    reward_value?: StringFilter<"ib_reward_claims"> | string
    reward_description?: StringFilter<"ib_reward_claims"> | string
    reward_type?: StringFilter<"ib_reward_claims"> | string
    claimant_name?: StringFilter<"ib_reward_claims"> | string
    claimant_phone?: StringFilter<"ib_reward_claims"> | string
    claimant_email?: StringFilter<"ib_reward_claims"> | string
    claimant_address_street?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_city?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_state?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_country?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_postal_code?: StringNullableFilter<"ib_reward_claims"> | string | null
    status?: StringFilter<"ib_reward_claims"> | string
    total_volume_mln?: DecimalFilter<"ib_reward_claims"> | Decimal | DecimalJsLike | number | string
    admin_notes?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimed_at?: DateTimeNullableFilter<"ib_reward_claims"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_reward_claims"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_reward_claims"> | Date | string | null
  }

  export type ib_reward_claimsOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    reward_value?: SortOrder
    reward_description?: SortOrder
    reward_type?: SortOrder
    claimant_name?: SortOrder
    claimant_phone?: SortOrder
    claimant_email?: SortOrder
    claimant_address_street?: SortOrderInput | SortOrder
    claimant_address_city?: SortOrderInput | SortOrder
    claimant_address_state?: SortOrderInput | SortOrder
    claimant_address_country?: SortOrderInput | SortOrder
    claimant_address_postal_code?: SortOrderInput | SortOrder
    status?: SortOrder
    total_volume_mln?: SortOrder
    admin_notes?: SortOrderInput | SortOrder
    claimed_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type ib_reward_claimsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ib_request_id_reward_id?: ib_reward_claimsIb_request_idReward_idCompoundUniqueInput
    AND?: ib_reward_claimsWhereInput | ib_reward_claimsWhereInput[]
    OR?: ib_reward_claimsWhereInput[]
    NOT?: ib_reward_claimsWhereInput | ib_reward_claimsWhereInput[]
    ib_request_id?: IntFilter<"ib_reward_claims"> | number
    user_id?: StringFilter<"ib_reward_claims"> | string
    reward_id?: IntFilter<"ib_reward_claims"> | number
    reward_value?: StringFilter<"ib_reward_claims"> | string
    reward_description?: StringFilter<"ib_reward_claims"> | string
    reward_type?: StringFilter<"ib_reward_claims"> | string
    claimant_name?: StringFilter<"ib_reward_claims"> | string
    claimant_phone?: StringFilter<"ib_reward_claims"> | string
    claimant_email?: StringFilter<"ib_reward_claims"> | string
    claimant_address_street?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_city?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_state?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_country?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimant_address_postal_code?: StringNullableFilter<"ib_reward_claims"> | string | null
    status?: StringFilter<"ib_reward_claims"> | string
    total_volume_mln?: DecimalFilter<"ib_reward_claims"> | Decimal | DecimalJsLike | number | string
    admin_notes?: StringNullableFilter<"ib_reward_claims"> | string | null
    claimed_at?: DateTimeNullableFilter<"ib_reward_claims"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_reward_claims"> | Date | string | null
    created_at?: DateTimeNullableFilter<"ib_reward_claims"> | Date | string | null
  }, "id" | "ib_request_id_reward_id">

  export type ib_reward_claimsOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    reward_value?: SortOrder
    reward_description?: SortOrder
    reward_type?: SortOrder
    claimant_name?: SortOrder
    claimant_phone?: SortOrder
    claimant_email?: SortOrder
    claimant_address_street?: SortOrderInput | SortOrder
    claimant_address_city?: SortOrderInput | SortOrder
    claimant_address_state?: SortOrderInput | SortOrder
    claimant_address_country?: SortOrderInput | SortOrder
    claimant_address_postal_code?: SortOrderInput | SortOrder
    status?: SortOrder
    total_volume_mln?: SortOrder
    admin_notes?: SortOrderInput | SortOrder
    claimed_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ib_reward_claimsCountOrderByAggregateInput
    _avg?: ib_reward_claimsAvgOrderByAggregateInput
    _max?: ib_reward_claimsMaxOrderByAggregateInput
    _min?: ib_reward_claimsMinOrderByAggregateInput
    _sum?: ib_reward_claimsSumOrderByAggregateInput
  }

  export type ib_reward_claimsScalarWhereWithAggregatesInput = {
    AND?: ib_reward_claimsScalarWhereWithAggregatesInput | ib_reward_claimsScalarWhereWithAggregatesInput[]
    OR?: ib_reward_claimsScalarWhereWithAggregatesInput[]
    NOT?: ib_reward_claimsScalarWhereWithAggregatesInput | ib_reward_claimsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_reward_claims"> | number
    ib_request_id?: IntWithAggregatesFilter<"ib_reward_claims"> | number
    user_id?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    reward_id?: IntWithAggregatesFilter<"ib_reward_claims"> | number
    reward_value?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    reward_description?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    reward_type?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    claimant_name?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    claimant_phone?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    claimant_email?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    claimant_address_street?: StringNullableWithAggregatesFilter<"ib_reward_claims"> | string | null
    claimant_address_city?: StringNullableWithAggregatesFilter<"ib_reward_claims"> | string | null
    claimant_address_state?: StringNullableWithAggregatesFilter<"ib_reward_claims"> | string | null
    claimant_address_country?: StringNullableWithAggregatesFilter<"ib_reward_claims"> | string | null
    claimant_address_postal_code?: StringNullableWithAggregatesFilter<"ib_reward_claims"> | string | null
    status?: StringWithAggregatesFilter<"ib_reward_claims"> | string
    total_volume_mln?: DecimalWithAggregatesFilter<"ib_reward_claims"> | Decimal | DecimalJsLike | number | string
    admin_notes?: StringNullableWithAggregatesFilter<"ib_reward_claims"> | string | null
    claimed_at?: DateTimeNullableWithAggregatesFilter<"ib_reward_claims"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_reward_claims"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_reward_claims"> | Date | string | null
  }

  export type ib_withdrawal_requestsWhereInput = {
    AND?: ib_withdrawal_requestsWhereInput | ib_withdrawal_requestsWhereInput[]
    OR?: ib_withdrawal_requestsWhereInput[]
    NOT?: ib_withdrawal_requestsWhereInput | ib_withdrawal_requestsWhereInput[]
    id?: IntFilter<"ib_withdrawal_requests"> | number
    ib_request_id?: IntFilter<"ib_withdrawal_requests"> | number
    amount?: DecimalFilter<"ib_withdrawal_requests"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"ib_withdrawal_requests"> | string
    account_details?: StringNullableFilter<"ib_withdrawal_requests"> | string | null
    status?: StringFilter<"ib_withdrawal_requests"> | string
    created_at?: DateTimeNullableFilter<"ib_withdrawal_requests"> | Date | string | null
    transaction_id?: StringNullableFilter<"ib_withdrawal_requests"> | string | null
    updated_at?: DateTimeNullableFilter<"ib_withdrawal_requests"> | Date | string | null
  }

  export type ib_withdrawal_requestsOrderByWithRelationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    account_details?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type ib_withdrawal_requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ib_withdrawal_requestsWhereInput | ib_withdrawal_requestsWhereInput[]
    OR?: ib_withdrawal_requestsWhereInput[]
    NOT?: ib_withdrawal_requestsWhereInput | ib_withdrawal_requestsWhereInput[]
    ib_request_id?: IntFilter<"ib_withdrawal_requests"> | number
    amount?: DecimalFilter<"ib_withdrawal_requests"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"ib_withdrawal_requests"> | string
    account_details?: StringNullableFilter<"ib_withdrawal_requests"> | string | null
    status?: StringFilter<"ib_withdrawal_requests"> | string
    created_at?: DateTimeNullableFilter<"ib_withdrawal_requests"> | Date | string | null
    transaction_id?: StringNullableFilter<"ib_withdrawal_requests"> | string | null
    updated_at?: DateTimeNullableFilter<"ib_withdrawal_requests"> | Date | string | null
  }, "id">

  export type ib_withdrawal_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    account_details?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ib_withdrawal_requestsCountOrderByAggregateInput
    _avg?: ib_withdrawal_requestsAvgOrderByAggregateInput
    _max?: ib_withdrawal_requestsMaxOrderByAggregateInput
    _min?: ib_withdrawal_requestsMinOrderByAggregateInput
    _sum?: ib_withdrawal_requestsSumOrderByAggregateInput
  }

  export type ib_withdrawal_requestsScalarWhereWithAggregatesInput = {
    AND?: ib_withdrawal_requestsScalarWhereWithAggregatesInput | ib_withdrawal_requestsScalarWhereWithAggregatesInput[]
    OR?: ib_withdrawal_requestsScalarWhereWithAggregatesInput[]
    NOT?: ib_withdrawal_requestsScalarWhereWithAggregatesInput | ib_withdrawal_requestsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ib_withdrawal_requests"> | number
    ib_request_id?: IntWithAggregatesFilter<"ib_withdrawal_requests"> | number
    amount?: DecimalWithAggregatesFilter<"ib_withdrawal_requests"> | Decimal | DecimalJsLike | number | string
    method?: StringWithAggregatesFilter<"ib_withdrawal_requests"> | string
    account_details?: StringNullableWithAggregatesFilter<"ib_withdrawal_requests"> | string | null
    status?: StringWithAggregatesFilter<"ib_withdrawal_requests"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"ib_withdrawal_requests"> | Date | string | null
    transaction_id?: StringNullableWithAggregatesFilter<"ib_withdrawal_requests"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ib_withdrawal_requests"> | Date | string | null
  }

  export type sent_emailsWhereInput = {
    AND?: sent_emailsWhereInput | sent_emailsWhereInput[]
    OR?: sent_emailsWhereInput[]
    NOT?: sent_emailsWhereInput | sent_emailsWhereInput[]
    id?: IntFilter<"sent_emails"> | number
    recipient_email?: StringFilter<"sent_emails"> | string
    recipient_name?: StringNullableFilter<"sent_emails"> | string | null
    subject?: StringFilter<"sent_emails"> | string
    content_body?: StringFilter<"sent_emails"> | string
    is_html?: BoolNullableFilter<"sent_emails"> | boolean | null
    recipient_type?: StringNullableFilter<"sent_emails"> | string | null
    status?: StringNullableFilter<"sent_emails"> | string | null
    error_message?: StringNullableFilter<"sent_emails"> | string | null
    sent_at?: DateTimeNullableFilter<"sent_emails"> | Date | string | null
    created_at?: DateTimeNullableFilter<"sent_emails"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sent_emails"> | Date | string | null
    admin_id?: StringNullableFilter<"sent_emails"> | string | null
    attachments_count?: IntNullableFilter<"sent_emails"> | number | null
  }

  export type sent_emailsOrderByWithRelationInput = {
    id?: SortOrder
    recipient_email?: SortOrder
    recipient_name?: SortOrderInput | SortOrder
    subject?: SortOrder
    content_body?: SortOrder
    is_html?: SortOrderInput | SortOrder
    recipient_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    sent_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    admin_id?: SortOrderInput | SortOrder
    attachments_count?: SortOrderInput | SortOrder
  }

  export type sent_emailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sent_emailsWhereInput | sent_emailsWhereInput[]
    OR?: sent_emailsWhereInput[]
    NOT?: sent_emailsWhereInput | sent_emailsWhereInput[]
    recipient_email?: StringFilter<"sent_emails"> | string
    recipient_name?: StringNullableFilter<"sent_emails"> | string | null
    subject?: StringFilter<"sent_emails"> | string
    content_body?: StringFilter<"sent_emails"> | string
    is_html?: BoolNullableFilter<"sent_emails"> | boolean | null
    recipient_type?: StringNullableFilter<"sent_emails"> | string | null
    status?: StringNullableFilter<"sent_emails"> | string | null
    error_message?: StringNullableFilter<"sent_emails"> | string | null
    sent_at?: DateTimeNullableFilter<"sent_emails"> | Date | string | null
    created_at?: DateTimeNullableFilter<"sent_emails"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"sent_emails"> | Date | string | null
    admin_id?: StringNullableFilter<"sent_emails"> | string | null
    attachments_count?: IntNullableFilter<"sent_emails"> | number | null
  }, "id">

  export type sent_emailsOrderByWithAggregationInput = {
    id?: SortOrder
    recipient_email?: SortOrder
    recipient_name?: SortOrderInput | SortOrder
    subject?: SortOrder
    content_body?: SortOrder
    is_html?: SortOrderInput | SortOrder
    recipient_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    sent_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    admin_id?: SortOrderInput | SortOrder
    attachments_count?: SortOrderInput | SortOrder
    _count?: sent_emailsCountOrderByAggregateInput
    _avg?: sent_emailsAvgOrderByAggregateInput
    _max?: sent_emailsMaxOrderByAggregateInput
    _min?: sent_emailsMinOrderByAggregateInput
    _sum?: sent_emailsSumOrderByAggregateInput
  }

  export type sent_emailsScalarWhereWithAggregatesInput = {
    AND?: sent_emailsScalarWhereWithAggregatesInput | sent_emailsScalarWhereWithAggregatesInput[]
    OR?: sent_emailsScalarWhereWithAggregatesInput[]
    NOT?: sent_emailsScalarWhereWithAggregatesInput | sent_emailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sent_emails"> | number
    recipient_email?: StringWithAggregatesFilter<"sent_emails"> | string
    recipient_name?: StringNullableWithAggregatesFilter<"sent_emails"> | string | null
    subject?: StringWithAggregatesFilter<"sent_emails"> | string
    content_body?: StringWithAggregatesFilter<"sent_emails"> | string
    is_html?: BoolNullableWithAggregatesFilter<"sent_emails"> | boolean | null
    recipient_type?: StringNullableWithAggregatesFilter<"sent_emails"> | string | null
    status?: StringNullableWithAggregatesFilter<"sent_emails"> | string | null
    error_message?: StringNullableWithAggregatesFilter<"sent_emails"> | string | null
    sent_at?: DateTimeNullableWithAggregatesFilter<"sent_emails"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"sent_emails"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"sent_emails"> | Date | string | null
    admin_id?: StringNullableWithAggregatesFilter<"sent_emails"> | string | null
    attachments_count?: IntNullableWithAggregatesFilter<"sent_emails"> | number | null
  }

  export type symbols_with_categoriesWhereInput = {
    AND?: symbols_with_categoriesWhereInput | symbols_with_categoriesWhereInput[]
    OR?: symbols_with_categoriesWhereInput[]
    NOT?: symbols_with_categoriesWhereInput | symbols_with_categoriesWhereInput[]
    id?: IntFilter<"symbols_with_categories"> | number
    symbol?: StringFilter<"symbols_with_categories"> | string
    pair?: StringNullableFilter<"symbols_with_categories"> | string | null
    group_name?: StringNullableFilter<"symbols_with_categories"> | string | null
    category?: StringNullableFilter<"symbols_with_categories"> | string | null
    pip_per_lot?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    pip_value?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"symbols_with_categories"> | string | null
    status?: StringNullableFilter<"symbols_with_categories"> | string | null
    contract_size?: IntNullableFilter<"symbols_with_categories"> | number | null
    digits?: IntNullableFilter<"symbols_with_categories"> | number | null
    spread?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    profit_mode?: StringNullableFilter<"symbols_with_categories"> | string | null
    is_override?: BoolNullableFilter<"symbols_with_categories"> | boolean | null
    created_at?: DateTimeNullableFilter<"symbols_with_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"symbols_with_categories"> | Date | string | null
  }

  export type symbols_with_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    pair?: SortOrderInput | SortOrder
    group_name?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    pip_per_lot?: SortOrderInput | SortOrder
    pip_value?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    contract_size?: SortOrderInput | SortOrder
    digits?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    profit_mode?: SortOrderInput | SortOrder
    is_override?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type symbols_with_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    symbol?: string
    AND?: symbols_with_categoriesWhereInput | symbols_with_categoriesWhereInput[]
    OR?: symbols_with_categoriesWhereInput[]
    NOT?: symbols_with_categoriesWhereInput | symbols_with_categoriesWhereInput[]
    pair?: StringNullableFilter<"symbols_with_categories"> | string | null
    group_name?: StringNullableFilter<"symbols_with_categories"> | string | null
    category?: StringNullableFilter<"symbols_with_categories"> | string | null
    pip_per_lot?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    pip_value?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"symbols_with_categories"> | string | null
    status?: StringNullableFilter<"symbols_with_categories"> | string | null
    contract_size?: IntNullableFilter<"symbols_with_categories"> | number | null
    digits?: IntNullableFilter<"symbols_with_categories"> | number | null
    spread?: DecimalNullableFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    profit_mode?: StringNullableFilter<"symbols_with_categories"> | string | null
    is_override?: BoolNullableFilter<"symbols_with_categories"> | boolean | null
    created_at?: DateTimeNullableFilter<"symbols_with_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"symbols_with_categories"> | Date | string | null
  }, "id" | "symbol">

  export type symbols_with_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    pair?: SortOrderInput | SortOrder
    group_name?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    pip_per_lot?: SortOrderInput | SortOrder
    pip_value?: SortOrderInput | SortOrder
    commission?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    contract_size?: SortOrderInput | SortOrder
    digits?: SortOrderInput | SortOrder
    spread?: SortOrderInput | SortOrder
    profit_mode?: SortOrderInput | SortOrder
    is_override?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: symbols_with_categoriesCountOrderByAggregateInput
    _avg?: symbols_with_categoriesAvgOrderByAggregateInput
    _max?: symbols_with_categoriesMaxOrderByAggregateInput
    _min?: symbols_with_categoriesMinOrderByAggregateInput
    _sum?: symbols_with_categoriesSumOrderByAggregateInput
  }

  export type symbols_with_categoriesScalarWhereWithAggregatesInput = {
    AND?: symbols_with_categoriesScalarWhereWithAggregatesInput | symbols_with_categoriesScalarWhereWithAggregatesInput[]
    OR?: symbols_with_categoriesScalarWhereWithAggregatesInput[]
    NOT?: symbols_with_categoriesScalarWhereWithAggregatesInput | symbols_with_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"symbols_with_categories"> | number
    symbol?: StringWithAggregatesFilter<"symbols_with_categories"> | string
    pair?: StringNullableWithAggregatesFilter<"symbols_with_categories"> | string | null
    group_name?: StringNullableWithAggregatesFilter<"symbols_with_categories"> | string | null
    category?: StringNullableWithAggregatesFilter<"symbols_with_categories"> | string | null
    pip_per_lot?: DecimalNullableWithAggregatesFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    pip_value?: DecimalNullableWithAggregatesFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableWithAggregatesFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"symbols_with_categories"> | string | null
    status?: StringNullableWithAggregatesFilter<"symbols_with_categories"> | string | null
    contract_size?: IntNullableWithAggregatesFilter<"symbols_with_categories"> | number | null
    digits?: IntNullableWithAggregatesFilter<"symbols_with_categories"> | number | null
    spread?: DecimalNullableWithAggregatesFilter<"symbols_with_categories"> | Decimal | DecimalJsLike | number | string | null
    profit_mode?: StringNullableWithAggregatesFilter<"symbols_with_categories"> | string | null
    is_override?: BoolNullableWithAggregatesFilter<"symbols_with_categories"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"symbols_with_categories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"symbols_with_categories"> | Date | string | null
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    code?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    phoneCode?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    region?: StringNullableFilter<"Country"> | string | null
    isActive?: BoolNullableFilter<"Country"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phoneCode?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    phoneCode?: StringNullableFilter<"Country"> | string | null
    currency?: StringNullableFilter<"Country"> | string | null
    region?: StringNullableFilter<"Country"> | string | null
    isActive?: BoolNullableFilter<"Country"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
  }, "id" | "code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phoneCode?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    code?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    phoneCode?: StringNullableWithAggregatesFilter<"Country"> | string | null
    currency?: StringNullableWithAggregatesFilter<"Country"> | string | null
    region?: StringNullableWithAggregatesFilter<"Country"> | string | null
    isActive?: BoolNullableWithAggregatesFilter<"Country"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Country"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Country"> | Date | string | null
  }

  export type SuggestionWhereInput = {
    AND?: SuggestionWhereInput | SuggestionWhereInput[]
    OR?: SuggestionWhereInput[]
    NOT?: SuggestionWhereInput | SuggestionWhereInput[]
    id?: StringFilter<"Suggestion"> | string
    userId?: StringFilter<"Suggestion"> | string
    userName?: StringNullableFilter<"Suggestion"> | string | null
    userEmail?: StringNullableFilter<"Suggestion"> | string | null
    comment?: StringFilter<"Suggestion"> | string
    remarks?: StringNullableFilter<"Suggestion"> | string | null
    createdAt?: DateTimeFilter<"Suggestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SuggestionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    comment?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SuggestionWhereInput | SuggestionWhereInput[]
    OR?: SuggestionWhereInput[]
    NOT?: SuggestionWhereInput | SuggestionWhereInput[]
    userId?: StringFilter<"Suggestion"> | string
    userName?: StringNullableFilter<"Suggestion"> | string | null
    userEmail?: StringNullableFilter<"Suggestion"> | string | null
    comment?: StringFilter<"Suggestion"> | string
    remarks?: StringNullableFilter<"Suggestion"> | string | null
    createdAt?: DateTimeFilter<"Suggestion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    comment?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SuggestionCountOrderByAggregateInput
    _max?: SuggestionMaxOrderByAggregateInput
    _min?: SuggestionMinOrderByAggregateInput
  }

  export type SuggestionScalarWhereWithAggregatesInput = {
    AND?: SuggestionScalarWhereWithAggregatesInput | SuggestionScalarWhereWithAggregatesInput[]
    OR?: SuggestionScalarWhereWithAggregatesInput[]
    NOT?: SuggestionScalarWhereWithAggregatesInput | SuggestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Suggestion"> | string
    userId?: StringWithAggregatesFilter<"Suggestion"> | string
    userName?: StringNullableWithAggregatesFilter<"Suggestion"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"Suggestion"> | string | null
    comment?: StringWithAggregatesFilter<"Suggestion"> | string
    remarks?: StringNullableWithAggregatesFilter<"Suggestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Suggestion"> | Date | string
  }

  export type PriceAlertWhereInput = {
    AND?: PriceAlertWhereInput | PriceAlertWhereInput[]
    OR?: PriceAlertWhereInput[]
    NOT?: PriceAlertWhereInput | PriceAlertWhereInput[]
    id?: StringFilter<"PriceAlert"> | string
    userId?: StringFilter<"PriceAlert"> | string
    symbol?: StringFilter<"PriceAlert"> | string
    targetPrice?: FloatFilter<"PriceAlert"> | number
    condition?: StringFilter<"PriceAlert"> | string
    isActive?: BoolFilter<"PriceAlert"> | boolean
    isTriggered?: BoolFilter<"PriceAlert"> | boolean
    triggeredAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"PriceAlert"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PriceAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    targetPrice?: SortOrder
    condition?: SortOrder
    isActive?: SortOrder
    isTriggered?: SortOrder
    triggeredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PriceAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceAlertWhereInput | PriceAlertWhereInput[]
    OR?: PriceAlertWhereInput[]
    NOT?: PriceAlertWhereInput | PriceAlertWhereInput[]
    userId?: StringFilter<"PriceAlert"> | string
    symbol?: StringFilter<"PriceAlert"> | string
    targetPrice?: FloatFilter<"PriceAlert"> | number
    condition?: StringFilter<"PriceAlert"> | string
    isActive?: BoolFilter<"PriceAlert"> | boolean
    isTriggered?: BoolFilter<"PriceAlert"> | boolean
    triggeredAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"PriceAlert"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PriceAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    targetPrice?: SortOrder
    condition?: SortOrder
    isActive?: SortOrder
    isTriggered?: SortOrder
    triggeredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PriceAlertCountOrderByAggregateInput
    _avg?: PriceAlertAvgOrderByAggregateInput
    _max?: PriceAlertMaxOrderByAggregateInput
    _min?: PriceAlertMinOrderByAggregateInput
    _sum?: PriceAlertSumOrderByAggregateInput
  }

  export type PriceAlertScalarWhereWithAggregatesInput = {
    AND?: PriceAlertScalarWhereWithAggregatesInput | PriceAlertScalarWhereWithAggregatesInput[]
    OR?: PriceAlertScalarWhereWithAggregatesInput[]
    NOT?: PriceAlertScalarWhereWithAggregatesInput | PriceAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceAlert"> | string
    userId?: StringWithAggregatesFilter<"PriceAlert"> | string
    symbol?: StringWithAggregatesFilter<"PriceAlert"> | string
    targetPrice?: FloatWithAggregatesFilter<"PriceAlert"> | number
    condition?: StringWithAggregatesFilter<"PriceAlert"> | string
    isActive?: BoolWithAggregatesFilter<"PriceAlert"> | boolean
    isTriggered?: BoolWithAggregatesFilter<"PriceAlert"> | boolean
    triggeredAt?: DateTimeNullableWithAggregatesFilter<"PriceAlert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PriceAlert"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KYCCreateInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycInput
  }

  export type KYCUncheckedCreateInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type KYCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycNestedInput
  }

  export type KYCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type KYCCreateManyInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type KYCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MT5AccountCreateInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountCreateManyInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
  }

  export type MT5AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionCreateInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
    mt5Account: MT5AccountCreateNestedOneWithoutMt5TransactionsInput
  }

  export type MT5TransactionUncheckedCreateInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    mt5AccountId: string
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mt5Account?: MT5AccountUpdateOneRequiredWithoutMt5TransactionsNestedInput
  }

  export type MT5TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionCreateManyInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    mt5AccountId: string
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositCreateInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutDepositsInput
    user: UserCreateNestedOneWithoutDepositsInput
    cregisDeposit?: CregisDepositCreateNestedOneWithoutDepositInput
  }

  export type DepositUncheckedCreateInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cregisDeposit?: CregisDepositUncheckedCreateNestedOneWithoutDepositInput
  }

  export type DepositUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutDepositsNestedInput
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
    cregisDeposit?: CregisDepositUpdateOneWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cregisDeposit?: CregisDepositUncheckedUpdateOneWithoutDepositNestedInput
  }

  export type DepositCreateManyInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CregisDepositCreateInput = {
    id?: string
    cregisOrderId: string
    cregisStatus?: string
    amount: number
    currency?: string
    paymentUrl?: string | null
    qrCodeUrl?: string | null
    expiresAt?: Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deposit: DepositCreateNestedOneWithoutCregisDepositInput
  }

  export type CregisDepositUncheckedCreateInput = {
    id?: string
    depositId: string
    cregisOrderId: string
    cregisStatus?: string
    amount: number
    currency?: string
    paymentUrl?: string | null
    qrCodeUrl?: string | null
    expiresAt?: Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CregisDepositUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cregisOrderId?: StringFieldUpdateOperationsInput | string
    cregisStatus?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deposit?: DepositUpdateOneRequiredWithoutCregisDepositNestedInput
  }

  export type CregisDepositUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    depositId?: StringFieldUpdateOperationsInput | string
    cregisOrderId?: StringFieldUpdateOperationsInput | string
    cregisStatus?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CregisDepositCreateManyInput = {
    id?: string
    depositId: string
    cregisOrderId: string
    cregisStatus?: string
    amount: number
    currency?: string
    paymentUrl?: string | null
    qrCodeUrl?: string | null
    expiresAt?: Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CregisDepositUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cregisOrderId?: StringFieldUpdateOperationsInput | string
    cregisStatus?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CregisDepositUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    depositId?: StringFieldUpdateOperationsInput | string
    cregisOrderId?: StringFieldUpdateOperationsInput | string
    cregisStatus?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WithdrawalCreateInput = {
    id?: string
    userId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    walletId?: string | null
    mt5AccountId?: string | null
  }

  export type WithdrawalUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    walletId?: string | null
    mt5AccountId?: string | null
  }

  export type WithdrawalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WithdrawalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WithdrawalCreateManyInput = {
    id?: string
    userId: string
    amount: number
    method: string
    bankDetails?: string | null
    cryptoAddress?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    externalTransactionId?: string | null
    paymentMethod?: string | null
    processedAt?: Date | string | null
    walletAddress?: string | null
    walletId?: string | null
    mt5AccountId?: string | null
  }

  export type WithdrawalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WithdrawalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletCreateInput = {
    id?: string
    userId: string
    balance?: number
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletNumber?: string | null
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    balance?: number
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletNumber?: string | null
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    balance?: number
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walletNumber?: string | null
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walletNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletTransactionCreateInput = {
    id?: string
    walletId: string
    userId: string
    type: string
    amount: number
    status?: string
    description?: string | null
    mt5AccountId?: string | null
    withdrawalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    userId: string
    type: string
    amount: number
    status?: string
    description?: string | null
    mt5AccountId?: string | null
    withdrawalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    walletId: string
    userId: string
    type: string
    amount: number
    status?: string
    description?: string | null
    mt5AccountId?: string | null
    withdrawalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    adminId: string
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId?: string | null
    adminId: string
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    permissions: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    permissions: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    permissions: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    userId: string
    address?: string | null
    currency?: string
    network?: string
    status?: string
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    methodType?: string
    bankName?: string | null
    accountName?: string | null
    accountNumber?: string | null
    ifscSwiftCode?: string | null
    accountType?: string | null
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    userId: string
    address?: string | null
    currency?: string
    network?: string
    status?: string
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    methodType?: string
    bankName?: string | null
    accountName?: string | null
    accountNumber?: string | null
    ifscSwiftCode?: string | null
    accountType?: string | null
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodType?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscSwiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodType?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscSwiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    userId: string
    address?: string | null
    currency?: string
    network?: string
    status?: string
    submittedAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    methodType?: string
    bankName?: string | null
    accountName?: string | null
    accountNumber?: string | null
    ifscSwiftCode?: string | null
    accountType?: string | null
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodType?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscSwiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodType?: StringFieldUpdateOperationsInput | string
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscSwiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy: string
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy: string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy: string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DefaultMT5AccountCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MT5Account: MT5AccountCreateNestedOneWithoutDefaultMT5AccountInput
    User: UserCreateNestedOneWithoutDefaultMT5AccountInput
  }

  export type DefaultMT5AccountUncheckedCreateInput = {
    id?: string
    userId: string
    mt5AccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultMT5AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MT5Account?: MT5AccountUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
    User?: UserUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
  }

  export type DefaultMT5AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountCreateManyInput = {
    id?: string
    userId: string
    mt5AccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultMT5AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstrumentCreateInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    path?: string | null
    accountGroup?: string | null
    isin?: string | null
    sector?: number | null
    industry?: number | null
    country?: string | null
    currency?: string | null
    currencyProfit?: string | null
    currencyMargin?: string | null
    point?: number | null
    multiply?: number | null
    tickSize?: number | null
    tickValue?: number | null
    volumeLimit?: number | null
    marginInitial?: number | null
    marginMaintenance?: number | null
    tradeMode?: number | null
    tradeFlags?: number | null
    calcMode?: number | null
    execMode?: number | null
    swapLong?: number | null
    swapShort?: number | null
    swapMode?: number | null
    UserFavorite?: UserFavoriteCreateNestedManyWithoutInstrumentInput
  }

  export type InstrumentUncheckedCreateInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    path?: string | null
    accountGroup?: string | null
    isin?: string | null
    sector?: number | null
    industry?: number | null
    country?: string | null
    currency?: string | null
    currencyProfit?: string | null
    currencyMargin?: string | null
    point?: number | null
    multiply?: number | null
    tickSize?: number | null
    tickValue?: number | null
    volumeLimit?: number | null
    marginInitial?: number | null
    marginMaintenance?: number | null
    tradeMode?: number | null
    tradeFlags?: number | null
    calcMode?: number | null
    execMode?: number | null
    swapLong?: number | null
    swapShort?: number | null
    swapMode?: number | null
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutInstrumentInput
  }

  export type InstrumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: NullableStringFieldUpdateOperationsInput | string | null
    accountGroup?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencyProfit?: NullableStringFieldUpdateOperationsInput | string | null
    currencyMargin?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    multiply?: NullableIntFieldUpdateOperationsInput | number | null
    tickSize?: NullableFloatFieldUpdateOperationsInput | number | null
    tickValue?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    marginInitial?: NullableFloatFieldUpdateOperationsInput | number | null
    marginMaintenance?: NullableFloatFieldUpdateOperationsInput | number | null
    tradeMode?: NullableIntFieldUpdateOperationsInput | number | null
    tradeFlags?: NullableIntFieldUpdateOperationsInput | number | null
    calcMode?: NullableIntFieldUpdateOperationsInput | number | null
    execMode?: NullableIntFieldUpdateOperationsInput | number | null
    swapLong?: NullableFloatFieldUpdateOperationsInput | number | null
    swapShort?: NullableFloatFieldUpdateOperationsInput | number | null
    swapMode?: NullableIntFieldUpdateOperationsInput | number | null
    UserFavorite?: UserFavoriteUpdateManyWithoutInstrumentNestedInput
  }

  export type InstrumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: NullableStringFieldUpdateOperationsInput | string | null
    accountGroup?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencyProfit?: NullableStringFieldUpdateOperationsInput | string | null
    currencyMargin?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    multiply?: NullableIntFieldUpdateOperationsInput | number | null
    tickSize?: NullableFloatFieldUpdateOperationsInput | number | null
    tickValue?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    marginInitial?: NullableFloatFieldUpdateOperationsInput | number | null
    marginMaintenance?: NullableFloatFieldUpdateOperationsInput | number | null
    tradeMode?: NullableIntFieldUpdateOperationsInput | number | null
    tradeFlags?: NullableIntFieldUpdateOperationsInput | number | null
    calcMode?: NullableIntFieldUpdateOperationsInput | number | null
    execMode?: NullableIntFieldUpdateOperationsInput | number | null
    swapLong?: NullableFloatFieldUpdateOperationsInput | number | null
    swapShort?: NullableFloatFieldUpdateOperationsInput | number | null
    swapMode?: NullableIntFieldUpdateOperationsInput | number | null
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutInstrumentNestedInput
  }

  export type InstrumentCreateManyInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    path?: string | null
    accountGroup?: string | null
    isin?: string | null
    sector?: number | null
    industry?: number | null
    country?: string | null
    currency?: string | null
    currencyProfit?: string | null
    currencyMargin?: string | null
    point?: number | null
    multiply?: number | null
    tickSize?: number | null
    tickValue?: number | null
    volumeLimit?: number | null
    marginInitial?: number | null
    marginMaintenance?: number | null
    tradeMode?: number | null
    tradeFlags?: number | null
    calcMode?: number | null
    execMode?: number | null
    swapLong?: number | null
    swapShort?: number | null
    swapMode?: number | null
  }

  export type InstrumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: NullableStringFieldUpdateOperationsInput | string | null
    accountGroup?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencyProfit?: NullableStringFieldUpdateOperationsInput | string | null
    currencyMargin?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    multiply?: NullableIntFieldUpdateOperationsInput | number | null
    tickSize?: NullableFloatFieldUpdateOperationsInput | number | null
    tickValue?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    marginInitial?: NullableFloatFieldUpdateOperationsInput | number | null
    marginMaintenance?: NullableFloatFieldUpdateOperationsInput | number | null
    tradeMode?: NullableIntFieldUpdateOperationsInput | number | null
    tradeFlags?: NullableIntFieldUpdateOperationsInput | number | null
    calcMode?: NullableIntFieldUpdateOperationsInput | number | null
    execMode?: NullableIntFieldUpdateOperationsInput | number | null
    swapLong?: NullableFloatFieldUpdateOperationsInput | number | null
    swapShort?: NullableFloatFieldUpdateOperationsInput | number | null
    swapMode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstrumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: NullableStringFieldUpdateOperationsInput | string | null
    accountGroup?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencyProfit?: NullableStringFieldUpdateOperationsInput | string | null
    currencyMargin?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    multiply?: NullableIntFieldUpdateOperationsInput | number | null
    tickSize?: NullableFloatFieldUpdateOperationsInput | number | null
    tickValue?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    marginInitial?: NullableFloatFieldUpdateOperationsInput | number | null
    marginMaintenance?: NullableFloatFieldUpdateOperationsInput | number | null
    tradeMode?: NullableIntFieldUpdateOperationsInput | number | null
    tradeFlags?: NullableIntFieldUpdateOperationsInput | number | null
    calcMode?: NullableIntFieldUpdateOperationsInput | number | null
    execMode?: NullableIntFieldUpdateOperationsInput | number | null
    swapLong?: NullableFloatFieldUpdateOperationsInput | number | null
    swapShort?: NullableFloatFieldUpdateOperationsInput | number | null
    swapMode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefreshTokenCreateInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    deviceName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastActivity?: Date | string | null
    User: UserCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    deviceName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastActivity?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    deviceName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastActivity?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFavoriteCreateInput = {
    id?: string
    sortOrder?: number
    addedAt?: Date | string
    Instrument: InstrumentCreateNestedOneWithoutUserFavoriteInput
    User: UserCreateNestedOneWithoutUserFavoriteInput
    MT5Account?: MT5AccountCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    instrumentId: string
    mt5AccountId?: string | null
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instrument?: InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput
    User?: UserUpdateOneRequiredWithoutUserFavoriteNestedInput
    MT5Account?: MT5AccountUpdateOneWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInput = {
    id?: string
    userId: string
    instrumentId: string
    mt5AccountId?: string | null
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginLogCreateInput = {
    id?: string
    user_agent?: string | null
    device?: string | null
    browser?: string | null
    success?: boolean
    failure_reason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserLoginLogsInput
  }

  export type UserLoginLogUncheckedCreateInput = {
    id?: string
    userId: string
    user_agent?: string | null
    device?: string | null
    browser?: string | null
    success?: boolean
    failure_reason?: string | null
    createdAt?: Date | string
  }

  export type UserLoginLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserLoginLogsNestedInput
  }

  export type UserLoginLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginLogCreateManyInput = {
    id?: string
    userId: string
    user_agent?: string | null
    device?: string | null
    browser?: string | null
    success?: boolean
    failure_reason?: string | null
    createdAt?: Date | string
  }

  export type UserLoginLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalSettingsCreateInput = {
    id?: string
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: string
    priceSource?: string
    appearance?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTerminalSettingsInput
  }

  export type TerminalSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: string
    priceSource?: string
    appearance?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminalSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    showOnChart?: BoolFieldUpdateOperationsInput | boolean
    showSignals?: BoolFieldUpdateOperationsInput | boolean
    showHMR?: BoolFieldUpdateOperationsInput | boolean
    showPriceAlerts?: BoolFieldUpdateOperationsInput | boolean
    showOpenPositions?: BoolFieldUpdateOperationsInput | boolean
    showTPSL?: BoolFieldUpdateOperationsInput | boolean
    showEconomicCalendar?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarHighImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarMiddleImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowestImpact?: BoolFieldUpdateOperationsInput | boolean
    priceAlertSound?: BoolFieldUpdateOperationsInput | boolean
    closingSound?: BoolFieldUpdateOperationsInput | boolean
    autoTPSL?: BoolFieldUpdateOperationsInput | boolean
    openOrderMode?: StringFieldUpdateOperationsInput | string
    priceSource?: StringFieldUpdateOperationsInput | string
    appearance?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTerminalSettingsNestedInput
  }

  export type TerminalSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    showOnChart?: BoolFieldUpdateOperationsInput | boolean
    showSignals?: BoolFieldUpdateOperationsInput | boolean
    showHMR?: BoolFieldUpdateOperationsInput | boolean
    showPriceAlerts?: BoolFieldUpdateOperationsInput | boolean
    showOpenPositions?: BoolFieldUpdateOperationsInput | boolean
    showTPSL?: BoolFieldUpdateOperationsInput | boolean
    showEconomicCalendar?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarHighImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarMiddleImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowestImpact?: BoolFieldUpdateOperationsInput | boolean
    priceAlertSound?: BoolFieldUpdateOperationsInput | boolean
    closingSound?: BoolFieldUpdateOperationsInput | boolean
    autoTPSL?: BoolFieldUpdateOperationsInput | boolean
    openOrderMode?: StringFieldUpdateOperationsInput | string
    priceSource?: StringFieldUpdateOperationsInput | string
    appearance?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalSettingsCreateManyInput = {
    id?: string
    userId: string
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: string
    priceSource?: string
    appearance?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminalSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    showOnChart?: BoolFieldUpdateOperationsInput | boolean
    showSignals?: BoolFieldUpdateOperationsInput | boolean
    showHMR?: BoolFieldUpdateOperationsInput | boolean
    showPriceAlerts?: BoolFieldUpdateOperationsInput | boolean
    showOpenPositions?: BoolFieldUpdateOperationsInput | boolean
    showTPSL?: BoolFieldUpdateOperationsInput | boolean
    showEconomicCalendar?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarHighImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarMiddleImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowestImpact?: BoolFieldUpdateOperationsInput | boolean
    priceAlertSound?: BoolFieldUpdateOperationsInput | boolean
    closingSound?: BoolFieldUpdateOperationsInput | boolean
    autoTPSL?: BoolFieldUpdateOperationsInput | boolean
    openOrderMode?: StringFieldUpdateOperationsInput | string
    priceSource?: StringFieldUpdateOperationsInput | string
    appearance?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    showOnChart?: BoolFieldUpdateOperationsInput | boolean
    showSignals?: BoolFieldUpdateOperationsInput | boolean
    showHMR?: BoolFieldUpdateOperationsInput | boolean
    showPriceAlerts?: BoolFieldUpdateOperationsInput | boolean
    showOpenPositions?: BoolFieldUpdateOperationsInput | boolean
    showTPSL?: BoolFieldUpdateOperationsInput | boolean
    showEconomicCalendar?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarHighImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarMiddleImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowestImpact?: BoolFieldUpdateOperationsInput | boolean
    priceAlertSound?: BoolFieldUpdateOperationsInput | boolean
    closingSound?: BoolFieldUpdateOperationsInput | boolean
    autoTPSL?: BoolFieldUpdateOperationsInput | boolean
    openOrderMode?: StringFieldUpdateOperationsInput | string
    priceSource?: StringFieldUpdateOperationsInput | string
    appearance?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminCreateInput = {
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logCreateNestedManyWithoutAdminInput
    balance_operation_history?: balance_operation_historyCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logUncheckedCreateNestedManyWithoutAdminInput
    balance_operation_history?: balance_operation_historyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUpdateManyWithoutAdminNestedInput
    balance_operation_history?: balance_operation_historyUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUncheckedUpdateManyWithoutAdminNestedInput
    balance_operation_history?: balance_operation_historyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateManyInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type adminUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type admin_login_logCreateInput = {
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
    admin: adminCreateNestedOneWithoutAdmin_login_logInput
  }

  export type admin_login_logUncheckedCreateInput = {
    id?: number
    admin_id: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUpdateInput = {
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutAdmin_login_logNestedInput
  }

  export type admin_login_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logCreateManyInput = {
    id?: number
    admin_id: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUpdateManyMutationInput = {
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyCreateInput = {
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    admin: adminCreateNestedOneWithoutBalance_operation_historyInput
  }

  export type balance_operation_historyUncheckedCreateInput = {
    id?: number
    admin_id: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyUpdateInput = {
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutBalance_operation_historyNestedInput
  }

  export type balance_operation_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyCreateManyInput = {
    id?: number
    admin_id: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyUpdateManyMutationInput = {
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    admin_id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_conversationsCreateInput = {
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesCreateNestedManyWithoutChat_conversationsInput
    chat_participants?: chat_participantsCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUncheckedCreateInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutChat_conversationsInput
    chat_participants?: chat_participantsUncheckedCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUpdateManyWithoutChat_conversationsNestedInput
    chat_participants?: chat_participantsUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutChat_conversationsNestedInput
    chat_participants?: chat_participantsUncheckedUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsCreateManyInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
  }

  export type chat_conversationsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chat_conversationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chat_messagesCreateInput = {
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    chat_conversations?: chat_conversationsCreateNestedOneWithoutChat_messagesInput
  }

  export type chat_messagesUncheckedCreateInput = {
    id?: number
    conversation_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesUpdateInput = {
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat_conversations?: chat_conversationsUpdateOneWithoutChat_messagesNestedInput
  }

  export type chat_messagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesCreateManyInput = {
    id?: number
    conversation_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesUpdateManyMutationInput = {
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_participantsCreateInput = {
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
    chat_conversations?: chat_conversationsCreateNestedOneWithoutChat_participantsInput
  }

  export type chat_participantsUncheckedCreateInput = {
    id?: number
    conversation_id?: number | null
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_conversations?: chat_conversationsUpdateOneWithoutChat_participantsNestedInput
  }

  export type chat_participantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsCreateManyInput = {
    id?: number
    conversation_id?: number | null
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type group_commission_structuresCreateInput = {
    group_id: string
    structure_name: string
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    level_order?: number
    min_trading_volume?: Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: Decimal | DecimalJsLike | number | string | null
    min_active_clients?: number | null
  }

  export type group_commission_structuresUncheckedCreateInput = {
    id?: number
    group_id: string
    structure_name: string
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    level_order?: number
    min_trading_volume?: Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: Decimal | DecimalJsLike | number | string | null
    min_active_clients?: number | null
  }

  export type group_commission_structuresUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level_order?: IntFieldUpdateOperationsInput | number
    min_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type group_commission_structuresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level_order?: IntFieldUpdateOperationsInput | number
    min_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type group_commission_structuresCreateManyInput = {
    id?: number
    group_id: string
    structure_name: string
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    level_order?: number
    min_trading_volume?: Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: Decimal | DecimalJsLike | number | string | null
    min_active_clients?: number | null
  }

  export type group_commission_structuresUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level_order?: IntFieldUpdateOperationsInput | number
    min_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type group_commission_structuresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    structure_name?: StringFieldUpdateOperationsInput | string
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    level_order?: IntFieldUpdateOperationsInput | number
    min_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_trading_volume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_active_clients?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ib_adminCreateInput = {
    email: string
    password_hash: string
    role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_adminUncheckedCreateInput = {
    id?: number
    email: string
    password_hash: string
    role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_adminUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminCreateManyInput = {
    id?: number
    email: string
    password_hash: string
    role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_adminUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_requestsCreateInput = {
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    referral_code?: string | null
    referred_by?: number | null
    country?: string | null
    ib_group_assignments?: ib_group_assignmentsCreateNestedManyWithoutIb_requestsInput
  }

  export type ib_requestsUncheckedCreateInput = {
    id?: number
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    referral_code?: string | null
    referred_by?: number | null
    country?: string | null
    ib_group_assignments?: ib_group_assignmentsUncheckedCreateNestedManyWithoutIb_requestsInput
  }

  export type ib_requestsUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    ib_group_assignments?: ib_group_assignmentsUpdateManyWithoutIb_requestsNestedInput
  }

  export type ib_requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    ib_group_assignments?: ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsNestedInput
  }

  export type ib_requestsCreateManyInput = {
    id?: number
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    referral_code?: string | null
    referred_by?: number | null
    country?: string | null
  }

  export type ib_requestsUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type manual_gatewayCreateInput = {
    type: string
    name: string
    details: string
    icon_url?: string | null
    qr_code_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    vpa_address?: string | null
    crypto_address?: string | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    ifsc_code?: string | null
    swift_code?: string | null
    account_type?: string | null
    country_code?: string | null
  }

  export type manual_gatewayUncheckedCreateInput = {
    id?: number
    type: string
    name: string
    details: string
    icon_url?: string | null
    qr_code_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    vpa_address?: string | null
    crypto_address?: string | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    ifsc_code?: string | null
    swift_code?: string | null
    account_type?: string | null
    country_code?: string | null
  }

  export type manual_gatewayUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vpa_address?: NullableStringFieldUpdateOperationsInput | string | null
    crypto_address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    swift_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type manual_gatewayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vpa_address?: NullableStringFieldUpdateOperationsInput | string | null
    crypto_address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    swift_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type manual_gatewayCreateManyInput = {
    id?: number
    type: string
    name: string
    details: string
    icon_url?: string | null
    qr_code_url?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    vpa_address?: string | null
    crypto_address?: string | null
    bank_name?: string | null
    account_name?: string | null
    account_number?: string | null
    ifsc_code?: string | null
    swift_code?: string | null
    account_type?: string | null
    country_code?: string | null
  }

  export type manual_gatewayUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vpa_address?: NullableStringFieldUpdateOperationsInput | string | null
    crypto_address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    swift_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type manual_gatewayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    icon_url?: NullableStringFieldUpdateOperationsInput | string | null
    qr_code_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vpa_address?: NullableStringFieldUpdateOperationsInput | string | null
    crypto_address?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    ifsc_code?: NullableStringFieldUpdateOperationsInput | string | null
    swift_code?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mt5_groupsCreateInput = {
    group_id: string
    name: string
    description?: string | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mt5_groupsUncheckedCreateInput = {
    id?: number
    group_id: string
    name: string
    description?: string | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mt5_groupsUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mt5_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mt5_groupsCreateManyInput = {
    id?: number
    group_id: string
    name: string
    description?: string | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mt5_groupsUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mt5_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payment_gatewayCreateInput = {
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type payment_gatewayUncheckedCreateInput = {
    id?: number
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type payment_gatewayUpdateInput = {
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_gatewayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_gatewayCreateManyInput = {
    id?: number
    wallet_name: string
    deposit_wallet_address: string
    api_key: string
    secret_key: string
    gateway_type: string
    is_active?: boolean
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type payment_gatewayUpdateManyMutationInput = {
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_gatewayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_name?: StringFieldUpdateOperationsInput | string
    deposit_wallet_address?: StringFieldUpdateOperationsInput | string
    api_key?: StringFieldUpdateOperationsInput | string
    secret_key?: StringFieldUpdateOperationsInput | string
    gateway_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type symbolsCreateInput = {
    symbol_name: string
    description?: string | null
    symbol_type?: string | null
    group_name?: string | null
    digits?: number | null
    spread?: number | null
    contract_size?: number | null
    profit_mode?: string | null
    enable?: boolean | null
    swap_mode?: string | null
    swap_long?: number | null
    swap_short?: number | null
    swap3_day?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbolsUncheckedCreateInput = {
    id?: number
    symbol_name: string
    description?: string | null
    symbol_type?: string | null
    group_name?: string | null
    digits?: number | null
    spread?: number | null
    contract_size?: number | null
    profit_mode?: string | null
    enable?: boolean | null
    swap_mode?: string | null
    swap_long?: number | null
    swap_short?: number | null
    swap3_day?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbolsUpdateInput = {
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbolsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbolsCreateManyInput = {
    id?: number
    symbol_name: string
    description?: string | null
    symbol_type?: string | null
    group_name?: string | null
    digits?: number | null
    spread?: number | null
    contract_size?: number | null
    profit_mode?: string | null
    enable?: boolean | null
    swap_mode?: string | null
    swap_long?: number | null
    swap_short?: number | null
    swap3_day?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbolsUpdateManyMutationInput = {
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbolsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol_type?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableFloatFieldUpdateOperationsInput | number | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    enable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    swap_mode?: NullableStringFieldUpdateOperationsInput | string | null
    swap_long?: NullableFloatFieldUpdateOperationsInput | number | null
    swap_short?: NullableFloatFieldUpdateOperationsInput | number | null
    swap3_day?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsCreateInput = {
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    ib_requests?: ib_requestsCreateNestedOneWithoutIb_group_assignmentsInput
  }

  export type ib_group_assignmentsUncheckedCreateInput = {
    id?: number
    ib_request_id?: number | null
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUpdateInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ib_requests?: ib_requestsUpdateOneWithoutIb_group_assignmentsNestedInput
  }

  export type ib_group_assignmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsCreateManyInput = {
    id?: number
    ib_request_id?: number | null
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUpdateManyMutationInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_trade_historyCreateInput = {
    id: string
    order_id: string
    account_id: string
    user_id?: string | null
    ib_request_id?: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal | DecimalJsLike | number | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    close_price?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    ib_commission?: Decimal | DecimalJsLike | number | string | null
    take_profit?: Decimal | DecimalJsLike | number | string | null
    stop_loss?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    synced_at?: Date | string | null
    group_id?: string | null
  }

  export type ib_trade_historyUncheckedCreateInput = {
    id: string
    order_id: string
    account_id: string
    user_id?: string | null
    ib_request_id?: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal | DecimalJsLike | number | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    close_price?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    ib_commission?: Decimal | DecimalJsLike | number | string | null
    take_profit?: Decimal | DecimalJsLike | number | string | null
    stop_loss?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    synced_at?: Date | string | null
    group_id?: string | null
  }

  export type ib_trade_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_trade_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_trade_historyCreateManyInput = {
    id: string
    order_id: string
    account_id: string
    user_id?: string | null
    ib_request_id?: number | null
    symbol: string
    order_type: string
    volume_lots: Decimal | DecimalJsLike | number | string
    open_price?: Decimal | DecimalJsLike | number | string | null
    close_price?: Decimal | DecimalJsLike | number | string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    ib_commission?: Decimal | DecimalJsLike | number | string | null
    take_profit?: Decimal | DecimalJsLike | number | string | null
    stop_loss?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    synced_at?: Date | string | null
    group_id?: string | null
  }

  export type ib_trade_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_trade_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    ib_request_id?: NullableIntFieldUpdateOperationsInput | number | null
    symbol?: StringFieldUpdateOperationsInput | string
    order_type?: StringFieldUpdateOperationsInput | string
    volume_lots?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    open_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ib_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    take_profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stop_loss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsCreateInput = {
    ticket_no: string
    parent_id: string
    title: string
    description?: string | null
    ticket_type?: string | null
    status?: string
    priority?: string
    assigned_to?: string | null
    account_number?: string | null
    tags?: support_ticketsCreatetagsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    last_reply_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
  }

  export type support_ticketsUncheckedCreateInput = {
    id?: number
    ticket_no: string
    parent_id: string
    title: string
    description?: string | null
    ticket_type?: string | null
    status?: string
    priority?: string
    assigned_to?: string | null
    account_number?: string | null
    tags?: support_ticketsCreatetagsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    last_reply_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
  }

  export type support_ticketsUpdateInput = {
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsCreateManyInput = {
    id?: number
    ticket_no: string
    parent_id: string
    title: string
    description?: string | null
    ticket_type?: string | null
    status?: string
    priority?: string
    assigned_to?: string | null
    account_number?: string | null
    tags?: support_ticketsCreatetagsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    last_reply_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
  }

  export type support_ticketsUpdateManyMutationInput = {
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_no?: StringFieldUpdateOperationsInput | string
    parent_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ticket_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assigned_to?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: support_ticketsUpdatetagsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_reply_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type support_ticket_repliesCreateInput = {
    ticket_id: number
    reply_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    attachments?: support_ticket_repliesCreateattachmentsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
  }

  export type support_ticket_repliesUncheckedCreateInput = {
    id?: number
    ticket_id: number
    reply_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    attachments?: support_ticket_repliesCreateattachmentsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
  }

  export type support_ticket_repliesUpdateInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_ticket_repliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_ticket_repliesCreateManyInput = {
    id?: number
    ticket_id: number
    reply_id?: number | null
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    attachments?: support_ticket_repliesCreateattachmentsInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
  }

  export type support_ticket_repliesUpdateManyMutationInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_ticket_repliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    reply_id?: NullableIntFieldUpdateOperationsInput | number | null
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    attachments?: support_ticket_repliesUpdateattachmentsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type support_articlesCreateInput = {
    title: string
    slug: string
    content: string
    excerpt?: string | null
    category: string
    tags?: support_articlesCreatetagsInput | string[]
    views?: number
    helpful_count?: number
    not_helpful_count?: number
    is_published?: boolean
    author_id: string
    created_at?: Date | string
    updated_at?: Date | string
    published_at?: Date | string | null
  }

  export type support_articlesUncheckedCreateInput = {
    id?: number
    title: string
    slug: string
    content: string
    excerpt?: string | null
    category: string
    tags?: support_articlesCreatetagsInput | string[]
    views?: number
    helpful_count?: number
    not_helpful_count?: number
    is_published?: boolean
    author_id: string
    created_at?: Date | string
    updated_at?: Date | string
    published_at?: Date | string | null
  }

  export type support_articlesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_articlesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_articlesCreateManyInput = {
    id?: number
    title: string
    slug: string
    content: string
    excerpt?: string | null
    category: string
    tags?: support_articlesCreatetagsInput | string[]
    views?: number
    helpful_count?: number
    not_helpful_count?: number
    is_published?: boolean
    author_id: string
    created_at?: Date | string
    updated_at?: Date | string
    published_at?: Date | string | null
  }

  export type support_articlesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_articlesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_articlesUpdatetagsInput | string[]
    views?: IntFieldUpdateOperationsInput | number
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    is_published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type support_faqCreateInput = {
    question: string
    answer: string
    category: string
    tags?: support_faqCreatetagsInput | string[]
    helpful_count?: number
    not_helpful_count?: number
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_faqUncheckedCreateInput = {
    id?: number
    question: string
    answer: string
    category: string
    tags?: support_faqCreatetagsInput | string[]
    helpful_count?: number
    not_helpful_count?: number
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_faqUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_faqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_faqCreateManyInput = {
    id?: number
    question: string
    answer: string
    category: string
    tags?: support_faqCreatetagsInput | string[]
    helpful_count?: number
    not_helpful_count?: number
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_faqUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_faqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: support_faqUpdatetagsInput | string[]
    helpful_count?: IntFieldUpdateOperationsInput | number
    not_helpful_count?: IntFieldUpdateOperationsInput | number
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesCreateInput = {
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_categoriesUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    display_order?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type support_categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    display_order?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesCreateInput = {
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    created_at?: Date | string
  }

  export type support_repliesUncheckedCreateInput = {
    id?: number
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    created_at?: Date | string
  }

  export type support_repliesUpdateInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesCreateManyInput = {
    id?: number
    ticket_id: number
    sender_id: string
    sender_name: string
    sender_type: string
    content: string
    is_internal?: boolean
    created_at?: Date | string
  }

  export type support_repliesUpdateManyMutationInput = {
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type support_repliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticket_id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_internal?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type group_managementCreateInput = {
    group: string
    server?: number | null
    auth_mode?: number | null
    auth_password_min?: number | null
    currency?: string | null
    is_active?: boolean | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    dedicated_name?: string | null
    account_type?: string | null
    leverage?: number | null
    min_deposit?: Decimal | DecimalJsLike | number | string | null
    spread?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementUncheckedCreateInput = {
    id?: number
    group: string
    server?: number | null
    auth_mode?: number | null
    auth_password_min?: number | null
    currency?: string | null
    is_active?: boolean | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    dedicated_name?: string | null
    account_type?: string | null
    leverage?: number | null
    min_deposit?: Decimal | DecimalJsLike | number | string | null
    spread?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementUpdateInput = {
    group?: StringFieldUpdateOperationsInput | string
    server?: NullableIntFieldUpdateOperationsInput | number | null
    auth_mode?: NullableIntFieldUpdateOperationsInput | number | null
    auth_password_min?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dedicated_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    min_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group?: StringFieldUpdateOperationsInput | string
    server?: NullableIntFieldUpdateOperationsInput | number | null
    auth_mode?: NullableIntFieldUpdateOperationsInput | number | null
    auth_password_min?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dedicated_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    min_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementCreateManyInput = {
    id?: number
    group: string
    server?: number | null
    auth_mode?: number | null
    auth_password_min?: number | null
    currency?: string | null
    is_active?: boolean | null
    synced_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    dedicated_name?: string | null
    account_type?: string | null
    leverage?: number | null
    min_deposit?: Decimal | DecimalJsLike | number | string | null
    spread?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementUpdateManyMutationInput = {
    group?: StringFieldUpdateOperationsInput | string
    server?: NullableIntFieldUpdateOperationsInput | number | null
    auth_mode?: NullableIntFieldUpdateOperationsInput | number | null
    auth_password_min?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dedicated_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    min_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type group_managementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group?: StringFieldUpdateOperationsInput | string
    server?: NullableIntFieldUpdateOperationsInput | number | null
    auth_mode?: NullableIntFieldUpdateOperationsInput | number | null
    auth_password_min?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dedicated_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    min_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SymbolGroupAccessCreateInput = {
    symbol: string
    group_name: string
    is_allowed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SymbolGroupAccessUncheckedCreateInput = {
    id?: number
    symbol: string
    group_name: string
    is_allowed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SymbolGroupAccessUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    group_name?: StringFieldUpdateOperationsInput | string
    is_allowed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymbolGroupAccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    group_name?: StringFieldUpdateOperationsInput | string
    is_allowed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymbolGroupAccessCreateManyInput = {
    id?: number
    symbol: string
    group_name: string
    is_allowed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SymbolGroupAccessUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    group_name?: StringFieldUpdateOperationsInput | string
    is_allowed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymbolGroupAccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    group_name?: StringFieldUpdateOperationsInput | string
    is_allowed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt: Date | string
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateInput = {
    id: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt: Date | string
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id: string
    userId: string
    type: string
    amount: number
    status?: string
    currency?: string
    paymentMethod?: string | null
    transactionId?: string | null
    description?: string | null
    metadata?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    updatedAt: Date | string
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_transactionsCreateInput = {
    id?: bigint | number
    admin_id: number
    user_id?: string | null
    mt5_account_id?: string | null
    mt5_login: string
    operation_type: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    comment?: string | null
    external_transaction_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type admin_transactionsUncheckedCreateInput = {
    id?: bigint | number
    admin_id: number
    user_id?: string | null
    mt5_account_id?: string | null
    mt5_login: string
    operation_type: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    comment?: string | null
    external_transaction_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type admin_transactionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    admin_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_transactionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    admin_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_transactionsCreateManyInput = {
    id?: bigint | number
    admin_id: number
    user_id?: string | null
    mt5_account_id?: string | null
    mt5_login: string
    operation_type: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    comment?: string | null
    external_transaction_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    error_message?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type admin_transactionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    admin_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_transactionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    admin_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    external_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type countriesCreateInput = {
    code: string
    country?: string | null
    country_code?: string | null
  }

  export type countriesUncheckedCreateInput = {
    code: string
    country?: string | null
    country_code?: string | null
  }

  export type countriesUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesCreateManyInput = {
    code: string
    country?: string | null
    country_code?: string | null
  }

  export type countriesUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type country_adminsCreateInput = {
    name: string
    email: string
    status?: string | null
    country_code?: string | null
    features?: string | null
    created_at?: Date | string | null
  }

  export type country_adminsUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    status?: string | null
    country_code?: string | null
    features?: string | null
    created_at?: Date | string | null
  }

  export type country_adminsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type country_adminsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type country_adminsCreateManyInput = {
    id?: number
    name: string
    email: string
    status?: string | null
    country_code?: string | null
    features?: string | null
    created_at?: Date | string | null
  }

  export type country_adminsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type country_adminsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type email_templatesCreateInput = {
    name: string
    description?: string | null
    html_code: string
    variables?: email_templatesCreatevariablesInput | string[]
    is_default?: boolean | null
    preview_image_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    created_by?: string | null
  }

  export type email_templatesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    html_code: string
    variables?: email_templatesCreatevariablesInput | string[]
    is_default?: boolean | null
    preview_image_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    created_by?: string | null
  }

  export type email_templatesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    html_code?: StringFieldUpdateOperationsInput | string
    variables?: email_templatesUpdatevariablesInput | string[]
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preview_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type email_templatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    html_code?: StringFieldUpdateOperationsInput | string
    variables?: email_templatesUpdatevariablesInput | string[]
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preview_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type email_templatesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    html_code: string
    variables?: email_templatesCreatevariablesInput | string[]
    is_default?: boolean | null
    preview_image_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    created_by?: string | null
  }

  export type email_templatesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    html_code?: StringFieldUpdateOperationsInput | string
    variables?: email_templatesUpdatevariablesInput | string[]
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preview_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type email_templatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    html_code?: StringFieldUpdateOperationsInput | string
    variables?: email_templatesUpdatevariablesInput | string[]
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    preview_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_client_linkingCreateInput = {
    user_id: string
    user_name: string
    user_email: string
    user_account_id?: string | null
    current_ib_id?: number | null
    current_ib_name?: string | null
    current_ib_code?: string | null
    assigned_ib_id: number
    assigned_ib_name: string
    assigned_ib_code?: string | null
    assigned_ib_email?: string | null
    status?: string | null
    direct_volume_lots?: Decimal | DecimalJsLike | number | string | null
    direct_commission?: Decimal | DecimalJsLike | number | string | null
    linked_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    created_by?: number | null
  }

  export type ib_client_linkingUncheckedCreateInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    user_account_id?: string | null
    current_ib_id?: number | null
    current_ib_name?: string | null
    current_ib_code?: string | null
    assigned_ib_id: number
    assigned_ib_name: string
    assigned_ib_code?: string | null
    assigned_ib_email?: string | null
    status?: string | null
    direct_volume_lots?: Decimal | DecimalJsLike | number | string | null
    direct_commission?: Decimal | DecimalJsLike | number | string | null
    linked_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    created_by?: number | null
  }

  export type ib_client_linkingUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    current_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_id?: IntFieldUpdateOperationsInput | number
    assigned_ib_name?: StringFieldUpdateOperationsInput | string
    assigned_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    direct_volume_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direct_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    linked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ib_client_linkingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    current_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_id?: IntFieldUpdateOperationsInput | number
    assigned_ib_name?: StringFieldUpdateOperationsInput | string
    assigned_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    direct_volume_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direct_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    linked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ib_client_linkingCreateManyInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    user_account_id?: string | null
    current_ib_id?: number | null
    current_ib_name?: string | null
    current_ib_code?: string | null
    assigned_ib_id: number
    assigned_ib_name: string
    assigned_ib_code?: string | null
    assigned_ib_email?: string | null
    status?: string | null
    direct_volume_lots?: Decimal | DecimalJsLike | number | string | null
    direct_commission?: Decimal | DecimalJsLike | number | string | null
    linked_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    created_by?: number | null
  }

  export type ib_client_linkingUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    current_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_id?: IntFieldUpdateOperationsInput | number
    assigned_ib_name?: StringFieldUpdateOperationsInput | string
    assigned_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    direct_volume_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direct_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    linked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ib_client_linkingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    current_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    current_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_id?: IntFieldUpdateOperationsInput | number
    assigned_ib_name?: StringFieldUpdateOperationsInput | string
    assigned_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_ib_email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    direct_volume_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    direct_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    linked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ib_client_linking_historyCreateInput = {
    linking_id?: number | null
    user_id: string
    user_name: string
    user_email: string
    from_ib_id?: number | null
    from_ib_name?: string | null
    from_ib_code?: string | null
    to_ib_id: number
    to_ib_name: string
    to_ib_code?: string | null
    action: string
    moved_by?: number | null
    moved_by_name?: string | null
    notes?: string | null
    created_at?: Date | string | null
  }

  export type ib_client_linking_historyUncheckedCreateInput = {
    id?: number
    linking_id?: number | null
    user_id: string
    user_name: string
    user_email: string
    from_ib_id?: number | null
    from_ib_name?: string | null
    from_ib_code?: string | null
    to_ib_id: number
    to_ib_name: string
    to_ib_code?: string | null
    action: string
    moved_by?: number | null
    moved_by_name?: string | null
    notes?: string | null
    created_at?: Date | string | null
  }

  export type ib_client_linking_historyUpdateInput = {
    linking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    from_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    from_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    from_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    to_ib_id?: IntFieldUpdateOperationsInput | number
    to_ib_name?: StringFieldUpdateOperationsInput | string
    to_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    moved_by?: NullableIntFieldUpdateOperationsInput | number | null
    moved_by_name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_client_linking_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    linking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    from_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    from_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    from_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    to_ib_id?: IntFieldUpdateOperationsInput | number
    to_ib_name?: StringFieldUpdateOperationsInput | string
    to_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    moved_by?: NullableIntFieldUpdateOperationsInput | number | null
    moved_by_name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_client_linking_historyCreateManyInput = {
    id?: number
    linking_id?: number | null
    user_id: string
    user_name: string
    user_email: string
    from_ib_id?: number | null
    from_ib_name?: string | null
    from_ib_code?: string | null
    to_ib_id: number
    to_ib_name: string
    to_ib_code?: string | null
    action: string
    moved_by?: number | null
    moved_by_name?: string | null
    notes?: string | null
    created_at?: Date | string | null
  }

  export type ib_client_linking_historyUpdateManyMutationInput = {
    linking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    from_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    from_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    from_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    to_ib_id?: IntFieldUpdateOperationsInput | number
    to_ib_name?: StringFieldUpdateOperationsInput | string
    to_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    moved_by?: NullableIntFieldUpdateOperationsInput | number | null
    moved_by_name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_client_linking_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    linking_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    from_ib_id?: NullableIntFieldUpdateOperationsInput | number | null
    from_ib_name?: NullableStringFieldUpdateOperationsInput | string | null
    from_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    to_ib_id?: IntFieldUpdateOperationsInput | number
    to_ib_name?: StringFieldUpdateOperationsInput | string
    to_ib_code?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    moved_by?: NullableIntFieldUpdateOperationsInput | number | null
    moved_by_name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_commissionCreateInput = {
    ib_request_id: number
    user_id: string
    total_commission?: Decimal | DecimalJsLike | number | string | null
    last_updated?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    total_trades?: number | null
    total_lots?: Decimal | DecimalJsLike | number | string | null
    fixed_commission?: Decimal | DecimalJsLike | number | string | null
    spread_commission?: Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionUncheckedCreateInput = {
    id?: number
    ib_request_id: number
    user_id: string
    total_commission?: Decimal | DecimalJsLike | number | string | null
    last_updated?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    total_trades?: number | null
    total_lots?: Decimal | DecimalJsLike | number | string | null
    fixed_commission?: Decimal | DecimalJsLike | number | string | null
    spread_commission?: Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionUpdateInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    total_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_trades?: NullableIntFieldUpdateOperationsInput | number | null
    total_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    total_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_trades?: NullableIntFieldUpdateOperationsInput | number | null
    total_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionCreateManyInput = {
    id?: number
    ib_request_id: number
    user_id: string
    total_commission?: Decimal | DecimalJsLike | number | string | null
    last_updated?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    total_trades?: number | null
    total_lots?: Decimal | DecimalJsLike | number | string | null
    fixed_commission?: Decimal | DecimalJsLike | number | string | null
    spread_commission?: Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionUpdateManyMutationInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    total_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_trades?: NullableIntFieldUpdateOperationsInput | number | null
    total_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ib_commissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    total_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_trades?: NullableIntFieldUpdateOperationsInput | number | null
    total_lots?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ib_level_up_historyCreateInput = {
    ib_request_id: number
    from_structure_id?: number | null
    to_structure_id: number
    from_structure_name?: string | null
    to_structure_name?: string | null
    trading_volume_at_upgrade?: Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: number | null
    upgraded_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type ib_level_up_historyUncheckedCreateInput = {
    id?: number
    ib_request_id: number
    from_structure_id?: number | null
    to_structure_id: number
    from_structure_name?: string | null
    to_structure_name?: string | null
    trading_volume_at_upgrade?: Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: number | null
    upgraded_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type ib_level_up_historyUpdateInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    from_structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    to_structure_id?: IntFieldUpdateOperationsInput | number
    from_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    to_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    trading_volume_at_upgrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: NullableIntFieldUpdateOperationsInput | number | null
    upgraded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_level_up_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    from_structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    to_structure_id?: IntFieldUpdateOperationsInput | number
    from_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    to_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    trading_volume_at_upgrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: NullableIntFieldUpdateOperationsInput | number | null
    upgraded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_level_up_historyCreateManyInput = {
    id?: number
    ib_request_id: number
    from_structure_id?: number | null
    to_structure_id: number
    from_structure_name?: string | null
    to_structure_name?: string | null
    trading_volume_at_upgrade?: Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: number | null
    upgraded_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type ib_level_up_historyUpdateManyMutationInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    from_structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    to_structure_id?: IntFieldUpdateOperationsInput | number
    from_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    to_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    trading_volume_at_upgrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: NullableIntFieldUpdateOperationsInput | number | null
    upgraded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_level_up_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    from_structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    to_structure_id?: IntFieldUpdateOperationsInput | number
    from_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    to_structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    trading_volume_at_upgrade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    active_clients_at_upgrade?: NullableIntFieldUpdateOperationsInput | number | null
    upgraded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_referralsCreateInput = {
    ib_request_id: number
    user_id?: string | null
    email: string
    referral_code: string
    source?: string | null
    created_at?: Date | string | null
  }

  export type ib_referralsUncheckedCreateInput = {
    id?: number
    ib_request_id: number
    user_id?: string | null
    email: string
    referral_code: string
    source?: string | null
    created_at?: Date | string | null
  }

  export type ib_referralsUpdateInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    referral_code?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_referralsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    referral_code?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_referralsCreateManyInput = {
    id?: number
    ib_request_id: number
    user_id?: string | null
    email: string
    referral_code: string
    source?: string | null
    created_at?: Date | string | null
  }

  export type ib_referralsUpdateManyMutationInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    referral_code?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_referralsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    referral_code?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_reward_claimsCreateInput = {
    ib_request_id: number
    user_id: string
    reward_id: number
    reward_value: string
    reward_description: string
    reward_type: string
    claimant_name: string
    claimant_phone: string
    claimant_email: string
    claimant_address_street?: string | null
    claimant_address_city?: string | null
    claimant_address_state?: string | null
    claimant_address_country?: string | null
    claimant_address_postal_code?: string | null
    status?: string
    total_volume_mln: Decimal | DecimalJsLike | number | string
    admin_notes?: string | null
    claimed_at?: Date | string | null
    updated_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type ib_reward_claimsUncheckedCreateInput = {
    id?: number
    ib_request_id: number
    user_id: string
    reward_id: number
    reward_value: string
    reward_description: string
    reward_type: string
    claimant_name: string
    claimant_phone: string
    claimant_email: string
    claimant_address_street?: string | null
    claimant_address_city?: string | null
    claimant_address_state?: string | null
    claimant_address_country?: string | null
    claimant_address_postal_code?: string | null
    status?: string
    total_volume_mln: Decimal | DecimalJsLike | number | string
    admin_notes?: string | null
    claimed_at?: Date | string | null
    updated_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type ib_reward_claimsUpdateInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    reward_id?: IntFieldUpdateOperationsInput | number
    reward_value?: StringFieldUpdateOperationsInput | string
    reward_description?: StringFieldUpdateOperationsInput | string
    reward_type?: StringFieldUpdateOperationsInput | string
    claimant_name?: StringFieldUpdateOperationsInput | string
    claimant_phone?: StringFieldUpdateOperationsInput | string
    claimant_email?: StringFieldUpdateOperationsInput | string
    claimant_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total_volume_mln?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    claimed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_reward_claimsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    reward_id?: IntFieldUpdateOperationsInput | number
    reward_value?: StringFieldUpdateOperationsInput | string
    reward_description?: StringFieldUpdateOperationsInput | string
    reward_type?: StringFieldUpdateOperationsInput | string
    claimant_name?: StringFieldUpdateOperationsInput | string
    claimant_phone?: StringFieldUpdateOperationsInput | string
    claimant_email?: StringFieldUpdateOperationsInput | string
    claimant_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total_volume_mln?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    claimed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_reward_claimsCreateManyInput = {
    id?: number
    ib_request_id: number
    user_id: string
    reward_id: number
    reward_value: string
    reward_description: string
    reward_type: string
    claimant_name: string
    claimant_phone: string
    claimant_email: string
    claimant_address_street?: string | null
    claimant_address_city?: string | null
    claimant_address_state?: string | null
    claimant_address_country?: string | null
    claimant_address_postal_code?: string | null
    status?: string
    total_volume_mln: Decimal | DecimalJsLike | number | string
    admin_notes?: string | null
    claimed_at?: Date | string | null
    updated_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type ib_reward_claimsUpdateManyMutationInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    reward_id?: IntFieldUpdateOperationsInput | number
    reward_value?: StringFieldUpdateOperationsInput | string
    reward_description?: StringFieldUpdateOperationsInput | string
    reward_type?: StringFieldUpdateOperationsInput | string
    claimant_name?: StringFieldUpdateOperationsInput | string
    claimant_phone?: StringFieldUpdateOperationsInput | string
    claimant_email?: StringFieldUpdateOperationsInput | string
    claimant_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total_volume_mln?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    claimed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_reward_claimsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    reward_id?: IntFieldUpdateOperationsInput | number
    reward_value?: StringFieldUpdateOperationsInput | string
    reward_description?: StringFieldUpdateOperationsInput | string
    reward_type?: StringFieldUpdateOperationsInput | string
    claimant_name?: StringFieldUpdateOperationsInput | string
    claimant_phone?: StringFieldUpdateOperationsInput | string
    claimant_email?: StringFieldUpdateOperationsInput | string
    claimant_address_street?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_city?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_state?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_country?: NullableStringFieldUpdateOperationsInput | string | null
    claimant_address_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total_volume_mln?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    claimed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_withdrawal_requestsCreateInput = {
    ib_request_id: number
    amount: Decimal | DecimalJsLike | number | string
    method: string
    account_details?: string | null
    status?: string
    created_at?: Date | string | null
    transaction_id?: string | null
    updated_at?: Date | string | null
  }

  export type ib_withdrawal_requestsUncheckedCreateInput = {
    id?: number
    ib_request_id: number
    amount: Decimal | DecimalJsLike | number | string
    method: string
    account_details?: string | null
    status?: string
    created_at?: Date | string | null
    transaction_id?: string | null
    updated_at?: Date | string | null
  }

  export type ib_withdrawal_requestsUpdateInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    account_details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_withdrawal_requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    account_details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_withdrawal_requestsCreateManyInput = {
    id?: number
    ib_request_id: number
    amount: Decimal | DecimalJsLike | number | string
    method: string
    account_details?: string | null
    status?: string
    created_at?: Date | string | null
    transaction_id?: string | null
    updated_at?: Date | string | null
  }

  export type ib_withdrawal_requestsUpdateManyMutationInput = {
    ib_request_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    account_details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_withdrawal_requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ib_request_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    account_details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sent_emailsCreateInput = {
    recipient_email: string
    recipient_name?: string | null
    subject: string
    content_body: string
    is_html?: boolean | null
    recipient_type?: string | null
    status?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_id?: string | null
    attachments_count?: number | null
  }

  export type sent_emailsUncheckedCreateInput = {
    id?: number
    recipient_email: string
    recipient_name?: string | null
    subject: string
    content_body: string
    is_html?: boolean | null
    recipient_type?: string | null
    status?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_id?: string | null
    attachments_count?: number | null
  }

  export type sent_emailsUpdateInput = {
    recipient_email?: StringFieldUpdateOperationsInput | string
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content_body?: StringFieldUpdateOperationsInput | string
    is_html?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recipient_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sent_emailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipient_email?: StringFieldUpdateOperationsInput | string
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content_body?: StringFieldUpdateOperationsInput | string
    is_html?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recipient_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sent_emailsCreateManyInput = {
    id?: number
    recipient_email: string
    recipient_name?: string | null
    subject: string
    content_body: string
    is_html?: boolean | null
    recipient_type?: string | null
    status?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_id?: string | null
    attachments_count?: number | null
  }

  export type sent_emailsUpdateManyMutationInput = {
    recipient_email?: StringFieldUpdateOperationsInput | string
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content_body?: StringFieldUpdateOperationsInput | string
    is_html?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recipient_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sent_emailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipient_email?: StringFieldUpdateOperationsInput | string
    recipient_name?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    content_body?: StringFieldUpdateOperationsInput | string
    is_html?: NullableBoolFieldUpdateOperationsInput | boolean | null
    recipient_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments_count?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type symbols_with_categoriesCreateInput = {
    symbol: string
    pair?: string | null
    group_name?: string | null
    category?: string | null
    pip_per_lot?: Decimal | DecimalJsLike | number | string | null
    pip_value?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    contract_size?: number | null
    digits?: number | null
    spread?: Decimal | DecimalJsLike | number | string | null
    profit_mode?: string | null
    is_override?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbols_with_categoriesUncheckedCreateInput = {
    id?: number
    symbol: string
    pair?: string | null
    group_name?: string | null
    category?: string | null
    pip_per_lot?: Decimal | DecimalJsLike | number | string | null
    pip_value?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    contract_size?: number | null
    digits?: number | null
    spread?: Decimal | DecimalJsLike | number | string | null
    profit_mode?: string | null
    is_override?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbols_with_categoriesUpdateInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    pair?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    pip_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pip_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    is_override?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbols_with_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    pair?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    pip_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pip_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    is_override?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbols_with_categoriesCreateManyInput = {
    id?: number
    symbol: string
    pair?: string | null
    group_name?: string | null
    category?: string | null
    pip_per_lot?: Decimal | DecimalJsLike | number | string | null
    pip_value?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    contract_size?: number | null
    digits?: number | null
    spread?: Decimal | DecimalJsLike | number | string | null
    profit_mode?: string | null
    is_override?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type symbols_with_categoriesUpdateManyMutationInput = {
    symbol?: StringFieldUpdateOperationsInput | string
    pair?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    pip_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pip_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    is_override?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type symbols_with_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    pair?: NullableStringFieldUpdateOperationsInput | string | null
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    pip_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pip_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contract_size?: NullableIntFieldUpdateOperationsInput | number | null
    digits?: NullableIntFieldUpdateOperationsInput | number | null
    spread?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profit_mode?: NullableStringFieldUpdateOperationsInput | string | null
    is_override?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateInput = {
    id: string
    code: string
    name: string
    phoneCode?: string | null
    currency?: string | null
    region?: string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CountryUncheckedCreateInput = {
    id: string
    code: string
    name: string
    phoneCode?: string | null
    currency?: string | null
    region?: string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateManyInput = {
    id: string
    code: string
    name: string
    phoneCode?: string | null
    currency?: string | null
    region?: string | null
    isActive?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuggestionCreateInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    comment: string
    remarks?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSuggestionsInput
  }

  export type SuggestionUncheckedCreateInput = {
    id?: string
    userId: string
    userName?: string | null
    userEmail?: string | null
    comment: string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type SuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type SuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionCreateManyInput = {
    id?: string
    userId: string
    userName?: string | null
    userEmail?: string | null
    comment: string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type SuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceAlertCreateInput = {
    id?: string
    symbol: string
    targetPrice: number
    condition: string
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPriceAlertsInput
  }

  export type PriceAlertUncheckedCreateInput = {
    id?: string
    userId: string
    symbol: string
    targetPrice: number
    condition: string
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPriceAlertsNestedInput
  }

  export type PriceAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceAlertCreateManyInput = {
    id?: string
    userId: string
    symbol: string
    targetPrice: number
    condition: string
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type DefaultMT5AccountNullableScalarRelationFilter = {
    is?: DefaultMT5AccountWhereInput | null
    isNot?: DefaultMT5AccountWhereInput | null
  }

  export type DepositListRelationFilter = {
    every?: DepositWhereInput
    some?: DepositWhereInput
    none?: DepositWhereInput
  }

  export type KYCNullableScalarRelationFilter = {
    is?: KYCWhereInput | null
    isNot?: KYCWhereInput | null
  }

  export type MT5AccountListRelationFilter = {
    every?: MT5AccountWhereInput
    some?: MT5AccountWhereInput
    none?: MT5AccountWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type TerminalSettingsNullableScalarRelationFilter = {
    is?: TerminalSettingsWhereInput | null
    isNot?: TerminalSettingsWhereInput | null
  }

  export type UserFavoriteListRelationFilter = {
    every?: UserFavoriteWhereInput
    some?: UserFavoriteWhereInput
    none?: UserFavoriteWhereInput
  }

  export type UserLoginLogListRelationFilter = {
    every?: UserLoginLogWhereInput
    some?: UserLoginLogWhereInput
    none?: UserLoginLogWhereInput
  }

  export type SuggestionListRelationFilter = {
    every?: SuggestionWhereInput
    some?: SuggestionWhereInput
    none?: SuggestionWhereInput
  }

  export type PriceAlertListRelationFilter = {
    every?: PriceAlertWhereInput
    some?: PriceAlertWhereInput
    none?: PriceAlertWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepositOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuggestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type KYCCountOrderByAggregateInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrder
    addressReference?: SortOrder
    amlReference?: SortOrder
    documentSubmittedAt?: SortOrder
    addressSubmittedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type KYCMaxOrderByAggregateInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrder
    addressReference?: SortOrder
    amlReference?: SortOrder
    documentSubmittedAt?: SortOrder
    addressSubmittedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type KYCMinOrderByAggregateInput = {
    id?: SortOrder
    isDocumentVerified?: SortOrder
    isAddressVerified?: SortOrder
    verificationStatus?: SortOrder
    documentReference?: SortOrder
    addressReference?: SortOrder
    amlReference?: SortOrder
    documentSubmittedAt?: SortOrder
    addressSubmittedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DefaultMT5AccountListRelationFilter = {
    every?: DefaultMT5AccountWhereInput
    some?: DefaultMT5AccountWhereInput
    none?: DefaultMT5AccountWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MT5TransactionListRelationFilter = {
    every?: MT5TransactionWhereInput
    some?: MT5TransactionWhereInput
    none?: MT5TransactionWhereInput
  }

  export type DefaultMT5AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MT5AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    leverage?: SortOrder
    nameOnAccount?: SortOrder
    package?: SortOrder
    group?: SortOrder
    balance?: SortOrder
    credit?: SortOrder
    currency?: SortOrder
    equity?: SortOrder
    lastSyncedAt?: SortOrder
    margin?: SortOrder
    marginFree?: SortOrder
    marginLevel?: SortOrder
    profit?: SortOrder
    archived?: SortOrder
    archived_at?: SortOrder
  }

  export type MT5AccountAvgOrderByAggregateInput = {
    leverage?: SortOrder
    balance?: SortOrder
    credit?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    marginFree?: SortOrder
    marginLevel?: SortOrder
    profit?: SortOrder
  }

  export type MT5AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    leverage?: SortOrder
    nameOnAccount?: SortOrder
    package?: SortOrder
    group?: SortOrder
    balance?: SortOrder
    credit?: SortOrder
    currency?: SortOrder
    equity?: SortOrder
    lastSyncedAt?: SortOrder
    margin?: SortOrder
    marginFree?: SortOrder
    marginLevel?: SortOrder
    profit?: SortOrder
    archived?: SortOrder
    archived_at?: SortOrder
  }

  export type MT5AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    leverage?: SortOrder
    nameOnAccount?: SortOrder
    package?: SortOrder
    group?: SortOrder
    balance?: SortOrder
    credit?: SortOrder
    currency?: SortOrder
    equity?: SortOrder
    lastSyncedAt?: SortOrder
    margin?: SortOrder
    marginFree?: SortOrder
    marginLevel?: SortOrder
    profit?: SortOrder
    archived?: SortOrder
    archived_at?: SortOrder
  }

  export type MT5AccountSumOrderByAggregateInput = {
    leverage?: SortOrder
    balance?: SortOrder
    credit?: SortOrder
    equity?: SortOrder
    margin?: SortOrder
    marginFree?: SortOrder
    marginLevel?: SortOrder
    profit?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MT5AccountScalarRelationFilter = {
    is?: MT5AccountWhereInput
    isNot?: MT5AccountWhereInput
  }

  export type MT5TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    comment?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    userId?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MT5TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    comment?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    userId?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    comment?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    userId?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MT5TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type CregisDepositNullableScalarRelationFilter = {
    is?: CregisDepositWhereInput | null
    isNot?: CregisDepositWhereInput | null
  }

  export type DepositCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrder
    transactionHash?: SortOrder
    proofFileUrl?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    depositAddress?: SortOrder
    externalTransactionId?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DepositMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrder
    transactionHash?: SortOrder
    proofFileUrl?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    depositAddress?: SortOrder
    externalTransactionId?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentMethod?: SortOrder
    transactionHash?: SortOrder
    proofFileUrl?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    depositAddress?: SortOrder
    externalTransactionId?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepositSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DepositScalarRelationFilter = {
    is?: DepositWhereInput
    isNot?: DepositWhereInput
  }

  export type CregisDepositCountOrderByAggregateInput = {
    id?: SortOrder
    depositId?: SortOrder
    cregisOrderId?: SortOrder
    cregisStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentUrl?: SortOrder
    qrCodeUrl?: SortOrder
    expiresAt?: SortOrder
    webhookData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CregisDepositAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CregisDepositMaxOrderByAggregateInput = {
    id?: SortOrder
    depositId?: SortOrder
    cregisOrderId?: SortOrder
    cregisStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentUrl?: SortOrder
    qrCodeUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CregisDepositMinOrderByAggregateInput = {
    id?: SortOrder
    depositId?: SortOrder
    cregisOrderId?: SortOrder
    cregisStatus?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentUrl?: SortOrder
    qrCodeUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CregisDepositSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type WithdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    walletAddress?: SortOrder
    walletId?: SortOrder
    mt5AccountId?: SortOrder
  }

  export type WithdrawalAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WithdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    walletAddress?: SortOrder
    walletId?: SortOrder
    mt5AccountId?: SortOrder
  }

  export type WithdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    bankDetails?: SortOrder
    cryptoAddress?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    externalTransactionId?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    walletAddress?: SortOrder
    walletId?: SortOrder
    mt5AccountId?: SortOrder
  }

  export type WithdrawalSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletNumber?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletNumber?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    walletNumber?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    description?: SortOrder
    mt5AccountId?: SortOrder
    withdrawalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    description?: SortOrder
    mt5AccountId?: SortOrder
    withdrawalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    description?: SortOrder
    mt5AccountId?: SortOrder
    withdrawalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    methodType?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    ifscSwiftCode?: SortOrder
    accountType?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    methodType?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    ifscSwiftCode?: SortOrder
    accountType?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    network?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    methodType?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    ifscSwiftCode?: SortOrder
    accountType?: SortOrder
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type DefaultMT5AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultMT5AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DefaultMT5AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mt5AccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InstrumentCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    group?: SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    path?: SortOrder
    accountGroup?: SortOrder
    isin?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    currencyProfit?: SortOrder
    currencyMargin?: SortOrder
    point?: SortOrder
    multiply?: SortOrder
    tickSize?: SortOrder
    tickValue?: SortOrder
    volumeLimit?: SortOrder
    marginInitial?: SortOrder
    marginMaintenance?: SortOrder
    tradeMode?: SortOrder
    tradeFlags?: SortOrder
    calcMode?: SortOrder
    execMode?: SortOrder
    swapLong?: SortOrder
    swapShort?: SortOrder
    swapMode?: SortOrder
  }

  export type InstrumentAvgOrderByAggregateInput = {
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    point?: SortOrder
    multiply?: SortOrder
    tickSize?: SortOrder
    tickValue?: SortOrder
    volumeLimit?: SortOrder
    marginInitial?: SortOrder
    marginMaintenance?: SortOrder
    tradeMode?: SortOrder
    tradeFlags?: SortOrder
    calcMode?: SortOrder
    execMode?: SortOrder
    swapLong?: SortOrder
    swapShort?: SortOrder
    swapMode?: SortOrder
  }

  export type InstrumentMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    group?: SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    path?: SortOrder
    accountGroup?: SortOrder
    isin?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    currencyProfit?: SortOrder
    currencyMargin?: SortOrder
    point?: SortOrder
    multiply?: SortOrder
    tickSize?: SortOrder
    tickValue?: SortOrder
    volumeLimit?: SortOrder
    marginInitial?: SortOrder
    marginMaintenance?: SortOrder
    tradeMode?: SortOrder
    tradeFlags?: SortOrder
    calcMode?: SortOrder
    execMode?: SortOrder
    swapLong?: SortOrder
    swapShort?: SortOrder
    swapMode?: SortOrder
  }

  export type InstrumentMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    group?: SortOrder
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    isActive?: SortOrder
    tradingHours?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    path?: SortOrder
    accountGroup?: SortOrder
    isin?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    currencyProfit?: SortOrder
    currencyMargin?: SortOrder
    point?: SortOrder
    multiply?: SortOrder
    tickSize?: SortOrder
    tickValue?: SortOrder
    volumeLimit?: SortOrder
    marginInitial?: SortOrder
    marginMaintenance?: SortOrder
    tradeMode?: SortOrder
    tradeFlags?: SortOrder
    calcMode?: SortOrder
    execMode?: SortOrder
    swapLong?: SortOrder
    swapShort?: SortOrder
    swapMode?: SortOrder
  }

  export type InstrumentSumOrderByAggregateInput = {
    digits?: SortOrder
    contractSize?: SortOrder
    minVolume?: SortOrder
    maxVolume?: SortOrder
    volumeStep?: SortOrder
    spread?: SortOrder
    sector?: SortOrder
    industry?: SortOrder
    point?: SortOrder
    multiply?: SortOrder
    tickSize?: SortOrder
    tickValue?: SortOrder
    volumeLimit?: SortOrder
    marginInitial?: SortOrder
    marginMaintenance?: SortOrder
    tradeMode?: SortOrder
    tradeFlags?: SortOrder
    calcMode?: SortOrder
    execMode?: SortOrder
    swapLong?: SortOrder
    swapShort?: SortOrder
    swapMode?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    deviceName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    lastActivity?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    deviceName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    lastActivity?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revoked?: SortOrder
    deviceName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    lastActivity?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type InstrumentScalarRelationFilter = {
    is?: InstrumentWhereInput
    isNot?: InstrumentWhereInput
  }

  export type MT5AccountNullableScalarRelationFilter = {
    is?: MT5AccountWhereInput | null
    isNot?: MT5AccountWhereInput | null
  }

  export type UserFavoriteUserIdInstrumentIdMt5AccountIdCompoundUniqueInput = {
    userId: string
    instrumentId: string
    mt5AccountId: string
  }

  export type UserFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    mt5AccountId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    mt5AccountId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instrumentId?: SortOrder
    mt5AccountId?: SortOrder
    sortOrder?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserLoginLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    user_agent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    createdAt?: SortOrder
  }

  export type UserLoginLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    user_agent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    createdAt?: SortOrder
  }

  export type UserLoginLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    user_agent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    createdAt?: SortOrder
  }

  export type TerminalSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    showOnChart?: SortOrder
    showSignals?: SortOrder
    showHMR?: SortOrder
    showPriceAlerts?: SortOrder
    showOpenPositions?: SortOrder
    showTPSL?: SortOrder
    showEconomicCalendar?: SortOrder
    economicCalendarHighImpact?: SortOrder
    economicCalendarMiddleImpact?: SortOrder
    economicCalendarLowImpact?: SortOrder
    economicCalendarLowestImpact?: SortOrder
    priceAlertSound?: SortOrder
    closingSound?: SortOrder
    autoTPSL?: SortOrder
    openOrderMode?: SortOrder
    priceSource?: SortOrder
    appearance?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    showOnChart?: SortOrder
    showSignals?: SortOrder
    showHMR?: SortOrder
    showPriceAlerts?: SortOrder
    showOpenPositions?: SortOrder
    showTPSL?: SortOrder
    showEconomicCalendar?: SortOrder
    economicCalendarHighImpact?: SortOrder
    economicCalendarMiddleImpact?: SortOrder
    economicCalendarLowImpact?: SortOrder
    economicCalendarLowestImpact?: SortOrder
    priceAlertSound?: SortOrder
    closingSound?: SortOrder
    autoTPSL?: SortOrder
    openOrderMode?: SortOrder
    priceSource?: SortOrder
    appearance?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    showOnChart?: SortOrder
    showSignals?: SortOrder
    showHMR?: SortOrder
    showPriceAlerts?: SortOrder
    showOpenPositions?: SortOrder
    showTPSL?: SortOrder
    showEconomicCalendar?: SortOrder
    economicCalendarHighImpact?: SortOrder
    economicCalendarMiddleImpact?: SortOrder
    economicCalendarLowImpact?: SortOrder
    economicCalendarLowestImpact?: SortOrder
    priceAlertSound?: SortOrder
    closingSound?: SortOrder
    autoTPSL?: SortOrder
    openOrderMode?: SortOrder
    priceSource?: SortOrder
    appearance?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Admin_login_logListRelationFilter = {
    every?: admin_login_logWhereInput
    some?: admin_login_logWhereInput
    none?: admin_login_logWhereInput
  }

  export type Balance_operation_historyListRelationFilter = {
    every?: balance_operation_historyWhereInput
    some?: balance_operation_historyWhereInput
    none?: balance_operation_historyWhereInput
  }

  export type admin_login_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type balance_operation_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    admin_role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type AdminScalarRelationFilter = {
    is?: adminWhereInput
    isNot?: adminWhereInput
  }

  export type admin_login_logCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    location?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    created_at?: SortOrder
  }

  export type admin_login_logAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
  }

  export type admin_login_logMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    location?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    created_at?: SortOrder
  }

  export type admin_login_logMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    location?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    success?: SortOrder
    failure_reason?: SortOrder
    created_at?: SortOrder
  }

  export type admin_login_logSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
  }

  export type balance_operation_historyCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
  }

  export type balance_operation_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    amount?: SortOrder
  }

  export type balance_operation_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
  }

  export type balance_operation_historyMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
  }

  export type balance_operation_historySumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    amount?: SortOrder
  }

  export type Chat_messagesListRelationFilter = {
    every?: chat_messagesWhereInput
    some?: chat_messagesWhereInput
    none?: chat_messagesWhereInput
  }

  export type Chat_participantsListRelationFilter = {
    every?: chat_participantsWhereInput
    some?: chat_participantsWhereInput
    none?: chat_participantsWhereInput
  }

  export type chat_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chat_participantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chat_conversationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
    tags?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsAvgOrderByAggregateInput = {
    id?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    admin_id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    subject?: SortOrder
    last_message_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type chat_conversationsSumOrderByAggregateInput = {
    id?: SortOrder
    unread_count_admin?: SortOrder
    unread_count_user?: SortOrder
  }

  export type Chat_conversationsNullableScalarRelationFilter = {
    is?: chat_conversationsWhereInput | null
    isNot?: chat_conversationsWhereInput | null
  }

  export type chat_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chat_messagesAvgOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type chat_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chat_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    message_type?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chat_messagesSumOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type chat_participantsConversation_idUser_idCompoundUniqueInput = {
    conversation_id: number
    user_id: string
  }

  export type chat_participantsCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrder
    joined_at?: SortOrder
    left_at?: SortOrder
    is_active?: SortOrder
  }

  export type chat_participantsAvgOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type chat_participantsMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrder
    joined_at?: SortOrder
    left_at?: SortOrder
    is_active?: SortOrder
  }

  export type chat_participantsMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_type?: SortOrder
    role?: SortOrder
    joined_at?: SortOrder
    left_at?: SortOrder
    is_active?: SortOrder
  }

  export type chat_participantsSumOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type group_commission_structuresGroup_idStructure_nameCompoundUniqueInput = {
    group_id: string
    structure_name: string
  }

  export type group_commission_structuresGroup_idLevel_orderCompoundUniqueInput = {
    group_id: string
    level_order: number
  }

  export type group_commission_structuresCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrder
    max_trading_volume?: SortOrder
    min_active_clients?: SortOrder
  }

  export type group_commission_structuresAvgOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrder
    max_trading_volume?: SortOrder
    min_active_clients?: SortOrder
  }

  export type group_commission_structuresMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrder
    max_trading_volume?: SortOrder
    min_active_clients?: SortOrder
  }

  export type group_commission_structuresMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrder
    max_trading_volume?: SortOrder
    min_active_clients?: SortOrder
  }

  export type group_commission_structuresSumOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    level_order?: SortOrder
    min_trading_volume?: SortOrder
    max_trading_volume?: SortOrder
    min_active_clients?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ib_adminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_adminAvgOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type ib_adminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_adminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_adminSumOrderByAggregateInput = {
    id?: SortOrder
    login_attempts?: SortOrder
  }

  export type Ib_group_assignmentsListRelationFilter = {
    every?: ib_group_assignmentsWhereInput
    some?: ib_group_assignmentsWhereInput
    none?: ib_group_assignmentsWhereInput
  }

  export type ib_group_assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ib_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrder
    approved_at?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    admin_comments?: SortOrder
    group_id?: SortOrder
    structure_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    referral_code?: SortOrder
    referred_by?: SortOrder
    country?: SortOrder
  }

  export type ib_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    structure_id?: SortOrder
    referred_by?: SortOrder
  }

  export type ib_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrder
    approved_at?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    admin_comments?: SortOrder
    group_id?: SortOrder
    structure_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    referral_code?: SortOrder
    referred_by?: SortOrder
    country?: SortOrder
  }

  export type ib_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    status?: SortOrder
    ib_type?: SortOrder
    submitted_at?: SortOrder
    approved_at?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    admin_comments?: SortOrder
    group_id?: SortOrder
    structure_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    referral_code?: SortOrder
    referred_by?: SortOrder
    country?: SortOrder
  }

  export type ib_requestsSumOrderByAggregateInput = {
    id?: SortOrder
    usd_per_lot?: SortOrder
    spread_percentage_per_lot?: SortOrder
    structure_id?: SortOrder
    referred_by?: SortOrder
  }

  export type manual_gatewayCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrder
    qr_code_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vpa_address?: SortOrder
    crypto_address?: SortOrder
    bank_name?: SortOrder
    account_name?: SortOrder
    account_number?: SortOrder
    ifsc_code?: SortOrder
    swift_code?: SortOrder
    account_type?: SortOrder
    country_code?: SortOrder
  }

  export type manual_gatewayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type manual_gatewayMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrder
    qr_code_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vpa_address?: SortOrder
    crypto_address?: SortOrder
    bank_name?: SortOrder
    account_name?: SortOrder
    account_number?: SortOrder
    ifsc_code?: SortOrder
    swift_code?: SortOrder
    account_type?: SortOrder
    country_code?: SortOrder
  }

  export type manual_gatewayMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    details?: SortOrder
    icon_url?: SortOrder
    qr_code_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    vpa_address?: SortOrder
    crypto_address?: SortOrder
    bank_name?: SortOrder
    account_name?: SortOrder
    account_number?: SortOrder
    ifsc_code?: SortOrder
    swift_code?: SortOrder
    account_type?: SortOrder
    country_code?: SortOrder
  }

  export type manual_gatewaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mt5_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mt5_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mt5_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mt5_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mt5_groupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type payment_gatewayCountOrderByAggregateInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type payment_gatewayMaxOrderByAggregateInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewayMinOrderByAggregateInput = {
    id?: SortOrder
    wallet_name?: SortOrder
    deposit_wallet_address?: SortOrder
    api_key?: SortOrder
    secret_key?: SortOrder
    gateway_type?: SortOrder
    is_active?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_gatewaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type symbolsCountOrderByAggregateInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrder
    symbol_type?: SortOrder
    group_name?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    profit_mode?: SortOrder
    enable?: SortOrder
    swap_mode?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
    swap3_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbolsAvgOrderByAggregateInput = {
    id?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
  }

  export type symbolsMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrder
    symbol_type?: SortOrder
    group_name?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    profit_mode?: SortOrder
    enable?: SortOrder
    swap_mode?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
    swap3_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbolsMinOrderByAggregateInput = {
    id?: SortOrder
    symbol_name?: SortOrder
    description?: SortOrder
    symbol_type?: SortOrder
    group_name?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    profit_mode?: SortOrder
    enable?: SortOrder
    swap_mode?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
    swap3_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbolsSumOrderByAggregateInput = {
    id?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    contract_size?: SortOrder
    swap_long?: SortOrder
    swap_short?: SortOrder
  }

  export type Ib_requestsNullableScalarRelationFilter = {
    is?: ib_requestsWhereInput | null
    isNot?: ib_requestsWhereInput | null
  }

  export type ib_group_assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    group_id?: SortOrder
    group_name?: SortOrder
    structure_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_group_assignmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    structure_id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
  }

  export type ib_group_assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    group_id?: SortOrder
    group_name?: SortOrder
    structure_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_group_assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    group_id?: SortOrder
    group_name?: SortOrder
    structure_id?: SortOrder
    structure_name?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_group_assignmentsSumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    structure_id?: SortOrder
    usd_per_lot?: SortOrder
    spread_share_percentage?: SortOrder
  }

  export type ib_trade_historyCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    ib_request_id?: SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    synced_at?: SortOrder
    group_id?: SortOrder
  }

  export type ib_trade_historyAvgOrderByAggregateInput = {
    ib_request_id?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
  }

  export type ib_trade_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    ib_request_id?: SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    synced_at?: SortOrder
    group_id?: SortOrder
  }

  export type ib_trade_historyMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    account_id?: SortOrder
    user_id?: SortOrder
    ib_request_id?: SortOrder
    symbol?: SortOrder
    order_type?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    synced_at?: SortOrder
    group_id?: SortOrder
  }

  export type ib_trade_historySumOrderByAggregateInput = {
    ib_request_id?: SortOrder
    volume_lots?: SortOrder
    open_price?: SortOrder
    close_price?: SortOrder
    profit?: SortOrder
    ib_commission?: SortOrder
    take_profit?: SortOrder
    stop_loss?: SortOrder
  }

  export type support_ticketsCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ticket_type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    account_number?: SortOrder
    tags?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
  }

  export type support_ticketsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type support_ticketsMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ticket_type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
  }

  export type support_ticketsMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_no?: SortOrder
    parent_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    ticket_type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assigned_to?: SortOrder
    account_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_reply_at?: SortOrder
    closed_at?: SortOrder
    closed_by?: SortOrder
  }

  export type support_ticketsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type support_ticket_repliesCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    attachments?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
  }

  export type support_ticket_repliesMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_read?: SortOrder
  }

  export type support_ticket_repliesSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    reply_id?: SortOrder
  }

  export type support_articlesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrder
  }

  export type support_articlesAvgOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
  }

  export type support_articlesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    category?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrder
  }

  export type support_articlesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    category?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    is_published?: SortOrder
    author_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    published_at?: SortOrder
  }

  export type support_articlesSumOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
  }

  export type support_faqCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqAvgOrderByAggregateInput = {
    id?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
  }

  export type support_faqMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_faqSumOrderByAggregateInput = {
    id?: SortOrder
    helpful_count?: SortOrder
    not_helpful_count?: SortOrder
    display_order?: SortOrder
  }

  export type support_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    display_order?: SortOrder
  }

  export type support_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    display_order?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type support_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    display_order?: SortOrder
  }

  export type support_repliesCountOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesAvgOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
  }

  export type support_repliesMaxOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesMinOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
    sender_id?: SortOrder
    sender_name?: SortOrder
    sender_type?: SortOrder
    content?: SortOrder
    is_internal?: SortOrder
    created_at?: SortOrder
  }

  export type support_repliesSumOrderByAggregateInput = {
    id?: SortOrder
    ticket_id?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type group_managementCountOrderByAggregateInput = {
    id?: SortOrder
    group?: SortOrder
    server?: SortOrder
    auth_mode?: SortOrder
    auth_password_min?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dedicated_name?: SortOrder
    account_type?: SortOrder
    leverage?: SortOrder
    min_deposit?: SortOrder
    spread?: SortOrder
    commission?: SortOrder
  }

  export type group_managementAvgOrderByAggregateInput = {
    id?: SortOrder
    server?: SortOrder
    auth_mode?: SortOrder
    auth_password_min?: SortOrder
    leverage?: SortOrder
    min_deposit?: SortOrder
    spread?: SortOrder
    commission?: SortOrder
  }

  export type group_managementMaxOrderByAggregateInput = {
    id?: SortOrder
    group?: SortOrder
    server?: SortOrder
    auth_mode?: SortOrder
    auth_password_min?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dedicated_name?: SortOrder
    account_type?: SortOrder
    leverage?: SortOrder
    min_deposit?: SortOrder
    spread?: SortOrder
    commission?: SortOrder
  }

  export type group_managementMinOrderByAggregateInput = {
    id?: SortOrder
    group?: SortOrder
    server?: SortOrder
    auth_mode?: SortOrder
    auth_password_min?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    synced_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dedicated_name?: SortOrder
    account_type?: SortOrder
    leverage?: SortOrder
    min_deposit?: SortOrder
    spread?: SortOrder
    commission?: SortOrder
  }

  export type group_managementSumOrderByAggregateInput = {
    id?: SortOrder
    server?: SortOrder
    auth_mode?: SortOrder
    auth_password_min?: SortOrder
    leverage?: SortOrder
    min_deposit?: SortOrder
    spread?: SortOrder
    commission?: SortOrder
  }

  export type SymbolGroupAccessSymbolGroup_nameCompoundUniqueInput = {
    symbol: string
    group_name: string
  }

  export type SymbolGroupAccessCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    group_name?: SortOrder
    is_allowed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SymbolGroupAccessAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SymbolGroupAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    group_name?: SortOrder
    is_allowed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SymbolGroupAccessMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    group_name?: SortOrder
    is_allowed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SymbolGroupAccessSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    depositId?: SortOrder
    withdrawalId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type admin_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    user_id?: SortOrder
    mt5_account_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    external_transaction_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type admin_transactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    amount?: SortOrder
  }

  export type admin_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    user_id?: SortOrder
    mt5_account_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    external_transaction_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type admin_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    user_id?: SortOrder
    mt5_account_id?: SortOrder
    mt5_login?: SortOrder
    operation_type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    external_transaction_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type admin_transactionsSumOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    amount?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type countriesCountOrderByAggregateInput = {
    code?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
  }

  export type countriesMaxOrderByAggregateInput = {
    code?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
  }

  export type countriesMinOrderByAggregateInput = {
    code?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
  }

  export type country_adminsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    country_code?: SortOrder
    features?: SortOrder
    created_at?: SortOrder
  }

  export type country_adminsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type country_adminsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    country_code?: SortOrder
    features?: SortOrder
    created_at?: SortOrder
  }

  export type country_adminsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    country_code?: SortOrder
    features?: SortOrder
    created_at?: SortOrder
  }

  export type country_adminsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type email_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    html_code?: SortOrder
    variables?: SortOrder
    is_default?: SortOrder
    preview_image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type email_templatesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type email_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    html_code?: SortOrder
    is_default?: SortOrder
    preview_image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type email_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    html_code?: SortOrder
    is_default?: SortOrder
    preview_image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type email_templatesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ib_client_linkingUser_idAssigned_ib_idStatusCompoundUniqueInput = {
    user_id: string
    assigned_ib_id: number
    status: string
  }

  export type ib_client_linkingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    user_account_id?: SortOrder
    current_ib_id?: SortOrder
    current_ib_name?: SortOrder
    current_ib_code?: SortOrder
    assigned_ib_id?: SortOrder
    assigned_ib_name?: SortOrder
    assigned_ib_code?: SortOrder
    assigned_ib_email?: SortOrder
    status?: SortOrder
    direct_volume_lots?: SortOrder
    direct_commission?: SortOrder
    linked_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type ib_client_linkingAvgOrderByAggregateInput = {
    id?: SortOrder
    current_ib_id?: SortOrder
    assigned_ib_id?: SortOrder
    direct_volume_lots?: SortOrder
    direct_commission?: SortOrder
    created_by?: SortOrder
  }

  export type ib_client_linkingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    user_account_id?: SortOrder
    current_ib_id?: SortOrder
    current_ib_name?: SortOrder
    current_ib_code?: SortOrder
    assigned_ib_id?: SortOrder
    assigned_ib_name?: SortOrder
    assigned_ib_code?: SortOrder
    assigned_ib_email?: SortOrder
    status?: SortOrder
    direct_volume_lots?: SortOrder
    direct_commission?: SortOrder
    linked_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type ib_client_linkingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    user_account_id?: SortOrder
    current_ib_id?: SortOrder
    current_ib_name?: SortOrder
    current_ib_code?: SortOrder
    assigned_ib_id?: SortOrder
    assigned_ib_name?: SortOrder
    assigned_ib_code?: SortOrder
    assigned_ib_email?: SortOrder
    status?: SortOrder
    direct_volume_lots?: SortOrder
    direct_commission?: SortOrder
    linked_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type ib_client_linkingSumOrderByAggregateInput = {
    id?: SortOrder
    current_ib_id?: SortOrder
    assigned_ib_id?: SortOrder
    direct_volume_lots?: SortOrder
    direct_commission?: SortOrder
    created_by?: SortOrder
  }

  export type ib_client_linking_historyCountOrderByAggregateInput = {
    id?: SortOrder
    linking_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    from_ib_id?: SortOrder
    from_ib_name?: SortOrder
    from_ib_code?: SortOrder
    to_ib_id?: SortOrder
    to_ib_name?: SortOrder
    to_ib_code?: SortOrder
    action?: SortOrder
    moved_by?: SortOrder
    moved_by_name?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type ib_client_linking_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    linking_id?: SortOrder
    from_ib_id?: SortOrder
    to_ib_id?: SortOrder
    moved_by?: SortOrder
  }

  export type ib_client_linking_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    linking_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    from_ib_id?: SortOrder
    from_ib_name?: SortOrder
    from_ib_code?: SortOrder
    to_ib_id?: SortOrder
    to_ib_name?: SortOrder
    to_ib_code?: SortOrder
    action?: SortOrder
    moved_by?: SortOrder
    moved_by_name?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type ib_client_linking_historyMinOrderByAggregateInput = {
    id?: SortOrder
    linking_id?: SortOrder
    user_id?: SortOrder
    user_name?: SortOrder
    user_email?: SortOrder
    from_ib_id?: SortOrder
    from_ib_name?: SortOrder
    from_ib_code?: SortOrder
    to_ib_id?: SortOrder
    to_ib_name?: SortOrder
    to_ib_code?: SortOrder
    action?: SortOrder
    moved_by?: SortOrder
    moved_by_name?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type ib_client_linking_historySumOrderByAggregateInput = {
    id?: SortOrder
    linking_id?: SortOrder
    from_ib_id?: SortOrder
    to_ib_id?: SortOrder
    moved_by?: SortOrder
  }

  export type ib_commissionIb_request_idUser_idCompoundUniqueInput = {
    ib_request_id: number
    user_id: string
  }

  export type ib_commissionCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    total_commission?: SortOrder
    last_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total_trades?: SortOrder
    total_lots?: SortOrder
    fixed_commission?: SortOrder
    spread_commission?: SortOrder
  }

  export type ib_commissionAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    total_commission?: SortOrder
    total_trades?: SortOrder
    total_lots?: SortOrder
    fixed_commission?: SortOrder
    spread_commission?: SortOrder
  }

  export type ib_commissionMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    total_commission?: SortOrder
    last_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total_trades?: SortOrder
    total_lots?: SortOrder
    fixed_commission?: SortOrder
    spread_commission?: SortOrder
  }

  export type ib_commissionMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    total_commission?: SortOrder
    last_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    total_trades?: SortOrder
    total_lots?: SortOrder
    fixed_commission?: SortOrder
    spread_commission?: SortOrder
  }

  export type ib_commissionSumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    total_commission?: SortOrder
    total_trades?: SortOrder
    total_lots?: SortOrder
    fixed_commission?: SortOrder
    spread_commission?: SortOrder
  }

  export type ib_level_up_historyCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrder
    to_structure_id?: SortOrder
    from_structure_name?: SortOrder
    to_structure_name?: SortOrder
    trading_volume_at_upgrade?: SortOrder
    active_clients_at_upgrade?: SortOrder
    upgraded_at?: SortOrder
    created_at?: SortOrder
  }

  export type ib_level_up_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrder
    to_structure_id?: SortOrder
    trading_volume_at_upgrade?: SortOrder
    active_clients_at_upgrade?: SortOrder
  }

  export type ib_level_up_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrder
    to_structure_id?: SortOrder
    from_structure_name?: SortOrder
    to_structure_name?: SortOrder
    trading_volume_at_upgrade?: SortOrder
    active_clients_at_upgrade?: SortOrder
    upgraded_at?: SortOrder
    created_at?: SortOrder
  }

  export type ib_level_up_historyMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrder
    to_structure_id?: SortOrder
    from_structure_name?: SortOrder
    to_structure_name?: SortOrder
    trading_volume_at_upgrade?: SortOrder
    active_clients_at_upgrade?: SortOrder
    upgraded_at?: SortOrder
    created_at?: SortOrder
  }

  export type ib_level_up_historySumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    from_structure_id?: SortOrder
    to_structure_id?: SortOrder
    trading_volume_at_upgrade?: SortOrder
    active_clients_at_upgrade?: SortOrder
  }

  export type ib_referralsCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    referral_code?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type ib_referralsAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
  }

  export type ib_referralsMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    referral_code?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type ib_referralsMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    email?: SortOrder
    referral_code?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type ib_referralsSumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
  }

  export type ib_reward_claimsIb_request_idReward_idCompoundUniqueInput = {
    ib_request_id: number
    reward_id: number
  }

  export type ib_reward_claimsCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    reward_value?: SortOrder
    reward_description?: SortOrder
    reward_type?: SortOrder
    claimant_name?: SortOrder
    claimant_phone?: SortOrder
    claimant_email?: SortOrder
    claimant_address_street?: SortOrder
    claimant_address_city?: SortOrder
    claimant_address_state?: SortOrder
    claimant_address_country?: SortOrder
    claimant_address_postal_code?: SortOrder
    status?: SortOrder
    total_volume_mln?: SortOrder
    admin_notes?: SortOrder
    claimed_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type ib_reward_claimsAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    reward_id?: SortOrder
    total_volume_mln?: SortOrder
  }

  export type ib_reward_claimsMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    reward_value?: SortOrder
    reward_description?: SortOrder
    reward_type?: SortOrder
    claimant_name?: SortOrder
    claimant_phone?: SortOrder
    claimant_email?: SortOrder
    claimant_address_street?: SortOrder
    claimant_address_city?: SortOrder
    claimant_address_state?: SortOrder
    claimant_address_country?: SortOrder
    claimant_address_postal_code?: SortOrder
    status?: SortOrder
    total_volume_mln?: SortOrder
    admin_notes?: SortOrder
    claimed_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type ib_reward_claimsMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    user_id?: SortOrder
    reward_id?: SortOrder
    reward_value?: SortOrder
    reward_description?: SortOrder
    reward_type?: SortOrder
    claimant_name?: SortOrder
    claimant_phone?: SortOrder
    claimant_email?: SortOrder
    claimant_address_street?: SortOrder
    claimant_address_city?: SortOrder
    claimant_address_state?: SortOrder
    claimant_address_country?: SortOrder
    claimant_address_postal_code?: SortOrder
    status?: SortOrder
    total_volume_mln?: SortOrder
    admin_notes?: SortOrder
    claimed_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type ib_reward_claimsSumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    reward_id?: SortOrder
    total_volume_mln?: SortOrder
  }

  export type ib_withdrawal_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    account_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    transaction_id?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_withdrawal_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
  }

  export type ib_withdrawal_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    account_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    transaction_id?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_withdrawal_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    account_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    transaction_id?: SortOrder
    updated_at?: SortOrder
  }

  export type ib_withdrawal_requestsSumOrderByAggregateInput = {
    id?: SortOrder
    ib_request_id?: SortOrder
    amount?: SortOrder
  }

  export type sent_emailsCountOrderByAggregateInput = {
    id?: SortOrder
    recipient_email?: SortOrder
    recipient_name?: SortOrder
    subject?: SortOrder
    content_body?: SortOrder
    is_html?: SortOrder
    recipient_type?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    admin_id?: SortOrder
    attachments_count?: SortOrder
  }

  export type sent_emailsAvgOrderByAggregateInput = {
    id?: SortOrder
    attachments_count?: SortOrder
  }

  export type sent_emailsMaxOrderByAggregateInput = {
    id?: SortOrder
    recipient_email?: SortOrder
    recipient_name?: SortOrder
    subject?: SortOrder
    content_body?: SortOrder
    is_html?: SortOrder
    recipient_type?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    admin_id?: SortOrder
    attachments_count?: SortOrder
  }

  export type sent_emailsMinOrderByAggregateInput = {
    id?: SortOrder
    recipient_email?: SortOrder
    recipient_name?: SortOrder
    subject?: SortOrder
    content_body?: SortOrder
    is_html?: SortOrder
    recipient_type?: SortOrder
    status?: SortOrder
    error_message?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    admin_id?: SortOrder
    attachments_count?: SortOrder
  }

  export type sent_emailsSumOrderByAggregateInput = {
    id?: SortOrder
    attachments_count?: SortOrder
  }

  export type symbols_with_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    pair?: SortOrder
    group_name?: SortOrder
    category?: SortOrder
    pip_per_lot?: SortOrder
    pip_value?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    contract_size?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    profit_mode?: SortOrder
    is_override?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbols_with_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    pip_per_lot?: SortOrder
    pip_value?: SortOrder
    commission?: SortOrder
    contract_size?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
  }

  export type symbols_with_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    pair?: SortOrder
    group_name?: SortOrder
    category?: SortOrder
    pip_per_lot?: SortOrder
    pip_value?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    contract_size?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    profit_mode?: SortOrder
    is_override?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbols_with_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    pair?: SortOrder
    group_name?: SortOrder
    category?: SortOrder
    pip_per_lot?: SortOrder
    pip_value?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    contract_size?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
    profit_mode?: SortOrder
    is_override?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type symbols_with_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    pip_per_lot?: SortOrder
    pip_value?: SortOrder
    commission?: SortOrder
    contract_size?: SortOrder
    digits?: SortOrder
    spread?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phoneCode?: SortOrder
    currency?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phoneCode?: SortOrder
    currency?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    phoneCode?: SortOrder
    currency?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    comment?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    comment?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    comment?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    targetPrice?: SortOrder
    condition?: SortOrder
    isActive?: SortOrder
    isTriggered?: SortOrder
    triggeredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceAlertAvgOrderByAggregateInput = {
    targetPrice?: SortOrder
  }

  export type PriceAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    targetPrice?: SortOrder
    condition?: SortOrder
    isActive?: SortOrder
    isTriggered?: SortOrder
    triggeredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    symbol?: SortOrder
    targetPrice?: SortOrder
    condition?: SortOrder
    isActive?: SortOrder
    isTriggered?: SortOrder
    triggeredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceAlertSumOrderByAggregateInput = {
    targetPrice?: SortOrder
  }

  export type UserCreatetwoFactorBackupCodesInput = {
    set: string[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type DefaultMT5AccountCreateNestedOneWithoutUserInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    connect?: DefaultMT5AccountWhereUniqueInput
  }

  export type DepositCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type KYCCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    connect?: KYCWhereUniqueInput
  }

  export type MT5AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type TerminalSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<TerminalSettingsCreateWithoutUserInput, TerminalSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: TerminalSettingsCreateOrConnectWithoutUserInput
    connect?: TerminalSettingsWhereUniqueInput
  }

  export type UserFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type UserLoginLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginLogCreateWithoutUserInput, UserLoginLogUncheckedCreateWithoutUserInput> | UserLoginLogCreateWithoutUserInput[] | UserLoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginLogCreateOrConnectWithoutUserInput | UserLoginLogCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginLogCreateManyUserInputEnvelope
    connect?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
  }

  export type SuggestionCreateNestedManyWithoutUserInput = {
    create?: XOR<SuggestionCreateWithoutUserInput, SuggestionUncheckedCreateWithoutUserInput> | SuggestionCreateWithoutUserInput[] | SuggestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutUserInput | SuggestionCreateOrConnectWithoutUserInput[]
    createMany?: SuggestionCreateManyUserInputEnvelope
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
  }

  export type PriceAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<PriceAlertCreateWithoutUserInput, PriceAlertUncheckedCreateWithoutUserInput> | PriceAlertCreateWithoutUserInput[] | PriceAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutUserInput | PriceAlertCreateOrConnectWithoutUserInput[]
    createMany?: PriceAlertCreateManyUserInputEnvelope
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    connect?: DefaultMT5AccountWhereUniqueInput
  }

  export type DepositUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type KYCUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    connect?: KYCWhereUniqueInput
  }

  export type MT5AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type TerminalSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TerminalSettingsCreateWithoutUserInput, TerminalSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: TerminalSettingsCreateOrConnectWithoutUserInput
    connect?: TerminalSettingsWhereUniqueInput
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type UserLoginLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginLogCreateWithoutUserInput, UserLoginLogUncheckedCreateWithoutUserInput> | UserLoginLogCreateWithoutUserInput[] | UserLoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginLogCreateOrConnectWithoutUserInput | UserLoginLogCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginLogCreateManyUserInputEnvelope
    connect?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
  }

  export type SuggestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SuggestionCreateWithoutUserInput, SuggestionUncheckedCreateWithoutUserInput> | SuggestionCreateWithoutUserInput[] | SuggestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutUserInput | SuggestionCreateOrConnectWithoutUserInput[]
    createMany?: SuggestionCreateManyUserInputEnvelope
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
  }

  export type PriceAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PriceAlertCreateWithoutUserInput, PriceAlertUncheckedCreateWithoutUserInput> | PriceAlertCreateWithoutUserInput[] | PriceAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutUserInput | PriceAlertCreateOrConnectWithoutUserInput[]
    createMany?: PriceAlertCreateManyUserInputEnvelope
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdatetwoFactorBackupCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAdminInput | ActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAdminInput | ActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAdminInput | ActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type DefaultMT5AccountUpdateOneWithoutUserNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    upsert?: DefaultMT5AccountUpsertWithoutUserInput
    disconnect?: DefaultMT5AccountWhereInput | boolean
    delete?: DefaultMT5AccountWhereInput | boolean
    connect?: DefaultMT5AccountWhereUniqueInput
    update?: XOR<XOR<DefaultMT5AccountUpdateToOneWithWhereWithoutUserInput, DefaultMT5AccountUpdateWithoutUserInput>, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type DepositUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutUserInput | DepositUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutUserInput | DepositUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutUserInput | DepositUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type KYCUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    upsert?: KYCUpsertWithoutUserInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutUserInput, KYCUpdateWithoutUserInput>, KYCUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountUpsertWithWhereUniqueWithoutUserInput | MT5AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    set?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    disconnect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    delete?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    update?: MT5AccountUpdateWithWhereUniqueWithoutUserInput | MT5AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountUpdateManyWithWhereWithoutUserInput | MT5AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type TerminalSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<TerminalSettingsCreateWithoutUserInput, TerminalSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: TerminalSettingsCreateOrConnectWithoutUserInput
    upsert?: TerminalSettingsUpsertWithoutUserInput
    disconnect?: TerminalSettingsWhereInput | boolean
    delete?: TerminalSettingsWhereInput | boolean
    connect?: TerminalSettingsWhereUniqueInput
    update?: XOR<XOR<TerminalSettingsUpdateToOneWithWhereWithoutUserInput, TerminalSettingsUpdateWithoutUserInput>, TerminalSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserLoginLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginLogCreateWithoutUserInput, UserLoginLogUncheckedCreateWithoutUserInput> | UserLoginLogCreateWithoutUserInput[] | UserLoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginLogCreateOrConnectWithoutUserInput | UserLoginLogCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginLogUpsertWithWhereUniqueWithoutUserInput | UserLoginLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginLogCreateManyUserInputEnvelope
    set?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    disconnect?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    delete?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    connect?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    update?: UserLoginLogUpdateWithWhereUniqueWithoutUserInput | UserLoginLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginLogUpdateManyWithWhereWithoutUserInput | UserLoginLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginLogScalarWhereInput | UserLoginLogScalarWhereInput[]
  }

  export type SuggestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SuggestionCreateWithoutUserInput, SuggestionUncheckedCreateWithoutUserInput> | SuggestionCreateWithoutUserInput[] | SuggestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutUserInput | SuggestionCreateOrConnectWithoutUserInput[]
    upsert?: SuggestionUpsertWithWhereUniqueWithoutUserInput | SuggestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SuggestionCreateManyUserInputEnvelope
    set?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    disconnect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    delete?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    update?: SuggestionUpdateWithWhereUniqueWithoutUserInput | SuggestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SuggestionUpdateManyWithWhereWithoutUserInput | SuggestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
  }

  export type PriceAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<PriceAlertCreateWithoutUserInput, PriceAlertUncheckedCreateWithoutUserInput> | PriceAlertCreateWithoutUserInput[] | PriceAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutUserInput | PriceAlertCreateOrConnectWithoutUserInput[]
    upsert?: PriceAlertUpsertWithWhereUniqueWithoutUserInput | PriceAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PriceAlertCreateManyUserInputEnvelope
    set?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    disconnect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    delete?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    update?: PriceAlertUpdateWithWhereUniqueWithoutUserInput | PriceAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PriceAlertUpdateManyWithWhereWithoutUserInput | PriceAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput> | ActivityLogCreateWithoutAdminInput[] | ActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAdminInput | ActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAdminInput | ActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ActivityLogCreateManyAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAdminInput | ActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAdminInput | ActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutUserInput
    upsert?: DefaultMT5AccountUpsertWithoutUserInput
    disconnect?: DefaultMT5AccountWhereInput | boolean
    delete?: DefaultMT5AccountWhereInput | boolean
    connect?: DefaultMT5AccountWhereUniqueInput
    update?: XOR<XOR<DefaultMT5AccountUpdateToOneWithWhereWithoutUserInput, DefaultMT5AccountUpdateWithoutUserInput>, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type DepositUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput> | DepositCreateWithoutUserInput[] | DepositUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutUserInput | DepositCreateOrConnectWithoutUserInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutUserInput | DepositUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepositCreateManyUserInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutUserInput | DepositUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutUserInput | DepositUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type KYCUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCCreateOrConnectWithoutUserInput
    upsert?: KYCUpsertWithoutUserInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutUserInput, KYCUpdateWithoutUserInput>, KYCUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput> | MT5AccountCreateWithoutUserInput[] | MT5AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserInput | MT5AccountCreateOrConnectWithoutUserInput[]
    upsert?: MT5AccountUpsertWithWhereUniqueWithoutUserInput | MT5AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MT5AccountCreateManyUserInputEnvelope
    set?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    disconnect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    delete?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    connect?: MT5AccountWhereUniqueInput | MT5AccountWhereUniqueInput[]
    update?: MT5AccountUpdateWithWhereUniqueWithoutUserInput | MT5AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MT5AccountUpdateManyWithWhereWithoutUserInput | MT5AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TerminalSettingsCreateWithoutUserInput, TerminalSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: TerminalSettingsCreateOrConnectWithoutUserInput
    upsert?: TerminalSettingsUpsertWithoutUserInput
    disconnect?: TerminalSettingsWhereInput | boolean
    delete?: TerminalSettingsWhereInput | boolean
    connect?: TerminalSettingsWhereUniqueInput
    update?: XOR<XOR<TerminalSettingsUpdateToOneWithWhereWithoutUserInput, TerminalSettingsUpdateWithoutUserInput>, TerminalSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserLoginLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginLogCreateWithoutUserInput, UserLoginLogUncheckedCreateWithoutUserInput> | UserLoginLogCreateWithoutUserInput[] | UserLoginLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginLogCreateOrConnectWithoutUserInput | UserLoginLogCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginLogUpsertWithWhereUniqueWithoutUserInput | UserLoginLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginLogCreateManyUserInputEnvelope
    set?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    disconnect?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    delete?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    connect?: UserLoginLogWhereUniqueInput | UserLoginLogWhereUniqueInput[]
    update?: UserLoginLogUpdateWithWhereUniqueWithoutUserInput | UserLoginLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginLogUpdateManyWithWhereWithoutUserInput | UserLoginLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginLogScalarWhereInput | UserLoginLogScalarWhereInput[]
  }

  export type SuggestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SuggestionCreateWithoutUserInput, SuggestionUncheckedCreateWithoutUserInput> | SuggestionCreateWithoutUserInput[] | SuggestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutUserInput | SuggestionCreateOrConnectWithoutUserInput[]
    upsert?: SuggestionUpsertWithWhereUniqueWithoutUserInput | SuggestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SuggestionCreateManyUserInputEnvelope
    set?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    disconnect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    delete?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    update?: SuggestionUpdateWithWhereUniqueWithoutUserInput | SuggestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SuggestionUpdateManyWithWhereWithoutUserInput | SuggestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
  }

  export type PriceAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PriceAlertCreateWithoutUserInput, PriceAlertUncheckedCreateWithoutUserInput> | PriceAlertCreateWithoutUserInput[] | PriceAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceAlertCreateOrConnectWithoutUserInput | PriceAlertCreateOrConnectWithoutUserInput[]
    upsert?: PriceAlertUpsertWithWhereUniqueWithoutUserInput | PriceAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PriceAlertCreateManyUserInputEnvelope
    set?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    disconnect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    delete?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    connect?: PriceAlertWhereUniqueInput | PriceAlertWhereUniqueInput[]
    update?: PriceAlertUpdateWithWhereUniqueWithoutUserInput | PriceAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PriceAlertUpdateManyWithWhereWithoutUserInput | PriceAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutKycInput = {
    create?: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutKycNestedInput = {
    create?: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycInput
    upsert?: UserUpsertWithoutKycInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycInput, UserUpdateWithoutKycInput>, UserUncheckedUpdateWithoutKycInput>
  }

  export type DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
  }

  export type DepositCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMt5AccountsInput = {
    create?: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMt5AccountsInput
    connect?: UserWhereUniqueInput
  }

  export type MT5TransactionCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutMT5AccountInput = {
    create?: XOR<UserFavoriteCreateWithoutMT5AccountInput, UserFavoriteUncheckedCreateWithoutMT5AccountInput> | UserFavoriteCreateWithoutMT5AccountInput[] | UserFavoriteUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMT5AccountInput | UserFavoriteCreateOrConnectWithoutMT5AccountInput[]
    createMany?: UserFavoriteCreateManyMT5AccountInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
  }

  export type DepositUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
  }

  export type MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutMT5AccountInput = {
    create?: XOR<UserFavoriteCreateWithoutMT5AccountInput, UserFavoriteUncheckedCreateWithoutMT5AccountInput> | UserFavoriteCreateWithoutMT5AccountInput[] | UserFavoriteUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMT5AccountInput | UserFavoriteCreateOrConnectWithoutMT5AccountInput[]
    createMany?: UserFavoriteCreateManyMT5AccountInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    upsert?: DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    set?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    disconnect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    delete?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    update?: DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput[]
    updateMany?: DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput | DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput[]
    deleteMany?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
  }

  export type DepositUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutMt5AccountInput | DepositUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutMt5AccountInput | DepositUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutMt5AccountInput | DepositUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type UserUpdateOneWithoutMt5AccountsNestedInput = {
    create?: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMt5AccountsInput
    upsert?: UserUpsertWithoutMt5AccountsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMt5AccountsInput, UserUpdateWithoutMt5AccountsInput>, UserUncheckedUpdateWithoutMt5AccountsInput>
  }

  export type MT5TransactionUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    upsert?: MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    set?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    disconnect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    delete?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    update?: MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput | MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutMT5AccountNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutMT5AccountInput, UserFavoriteUncheckedCreateWithoutMT5AccountInput> | UserFavoriteCreateWithoutMT5AccountInput[] | UserFavoriteUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMT5AccountInput | UserFavoriteCreateOrConnectWithoutMT5AccountInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutMT5AccountInput | UserFavoriteUpsertWithWhereUniqueWithoutMT5AccountInput[]
    createMany?: UserFavoriteCreateManyMT5AccountInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutMT5AccountInput | UserFavoriteUpdateWithWhereUniqueWithoutMT5AccountInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutMT5AccountInput | UserFavoriteUpdateManyWithWhereWithoutMT5AccountInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput = {
    create?: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput> | DefaultMT5AccountCreateWithoutMT5AccountInput[] | DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput | DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput[]
    upsert?: DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput[]
    createMany?: DefaultMT5AccountCreateManyMT5AccountInputEnvelope
    set?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    disconnect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    delete?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    connect?: DefaultMT5AccountWhereUniqueInput | DefaultMT5AccountWhereUniqueInput[]
    update?: DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput | DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput[]
    updateMany?: DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput | DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput[]
    deleteMany?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
  }

  export type DepositUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput> | DepositCreateWithoutMt5AccountInput[] | DepositUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: DepositCreateOrConnectWithoutMt5AccountInput | DepositCreateOrConnectWithoutMt5AccountInput[]
    upsert?: DepositUpsertWithWhereUniqueWithoutMt5AccountInput | DepositUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: DepositCreateManyMt5AccountInputEnvelope
    set?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    disconnect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    delete?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    connect?: DepositWhereUniqueInput | DepositWhereUniqueInput[]
    update?: DepositUpdateWithWhereUniqueWithoutMt5AccountInput | DepositUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: DepositUpdateManyWithWhereWithoutMt5AccountInput | DepositUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: DepositScalarWhereInput | DepositScalarWhereInput[]
  }

  export type MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput = {
    create?: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput> | MT5TransactionCreateWithoutMt5AccountInput[] | MT5TransactionUncheckedCreateWithoutMt5AccountInput[]
    connectOrCreate?: MT5TransactionCreateOrConnectWithoutMt5AccountInput | MT5TransactionCreateOrConnectWithoutMt5AccountInput[]
    upsert?: MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput[]
    createMany?: MT5TransactionCreateManyMt5AccountInputEnvelope
    set?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    disconnect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    delete?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    connect?: MT5TransactionWhereUniqueInput | MT5TransactionWhereUniqueInput[]
    update?: MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput | MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput[]
    updateMany?: MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput | MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput[]
    deleteMany?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutMT5AccountNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutMT5AccountInput, UserFavoriteUncheckedCreateWithoutMT5AccountInput> | UserFavoriteCreateWithoutMT5AccountInput[] | UserFavoriteUncheckedCreateWithoutMT5AccountInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutMT5AccountInput | UserFavoriteCreateOrConnectWithoutMT5AccountInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutMT5AccountInput | UserFavoriteUpsertWithWhereUniqueWithoutMT5AccountInput[]
    createMany?: UserFavoriteCreateManyMT5AccountInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutMT5AccountInput | UserFavoriteUpdateWithWhereUniqueWithoutMT5AccountInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutMT5AccountInput | UserFavoriteUpdateManyWithWhereWithoutMT5AccountInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type MT5AccountCreateNestedOneWithoutMt5TransactionsInput = {
    create?: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutMt5TransactionsInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MT5AccountUpdateOneRequiredWithoutMt5TransactionsNestedInput = {
    create?: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutMt5TransactionsInput
    upsert?: MT5AccountUpsertWithoutMt5TransactionsInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutMt5TransactionsInput, MT5AccountUpdateWithoutMt5TransactionsInput>, MT5AccountUncheckedUpdateWithoutMt5TransactionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type MT5AccountCreateNestedOneWithoutDepositsInput = {
    create?: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDepositsInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDepositsInput = {
    create?: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositsInput
    connect?: UserWhereUniqueInput
  }

  export type CregisDepositCreateNestedOneWithoutDepositInput = {
    create?: XOR<CregisDepositCreateWithoutDepositInput, CregisDepositUncheckedCreateWithoutDepositInput>
    connectOrCreate?: CregisDepositCreateOrConnectWithoutDepositInput
    connect?: CregisDepositWhereUniqueInput
  }

  export type CregisDepositUncheckedCreateNestedOneWithoutDepositInput = {
    create?: XOR<CregisDepositCreateWithoutDepositInput, CregisDepositUncheckedCreateWithoutDepositInput>
    connectOrCreate?: CregisDepositCreateOrConnectWithoutDepositInput
    connect?: CregisDepositWhereUniqueInput
  }

  export type MT5AccountUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDepositsInput
    upsert?: MT5AccountUpsertWithoutDepositsInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutDepositsInput, MT5AccountUpdateWithoutDepositsInput>, MT5AccountUncheckedUpdateWithoutDepositsInput>
  }

  export type UserUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositsInput
    upsert?: UserUpsertWithoutDepositsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepositsInput, UserUpdateWithoutDepositsInput>, UserUncheckedUpdateWithoutDepositsInput>
  }

  export type CregisDepositUpdateOneWithoutDepositNestedInput = {
    create?: XOR<CregisDepositCreateWithoutDepositInput, CregisDepositUncheckedCreateWithoutDepositInput>
    connectOrCreate?: CregisDepositCreateOrConnectWithoutDepositInput
    upsert?: CregisDepositUpsertWithoutDepositInput
    disconnect?: CregisDepositWhereInput | boolean
    delete?: CregisDepositWhereInput | boolean
    connect?: CregisDepositWhereUniqueInput
    update?: XOR<XOR<CregisDepositUpdateToOneWithWhereWithoutDepositInput, CregisDepositUpdateWithoutDepositInput>, CregisDepositUncheckedUpdateWithoutDepositInput>
  }

  export type CregisDepositUncheckedUpdateOneWithoutDepositNestedInput = {
    create?: XOR<CregisDepositCreateWithoutDepositInput, CregisDepositUncheckedCreateWithoutDepositInput>
    connectOrCreate?: CregisDepositCreateOrConnectWithoutDepositInput
    upsert?: CregisDepositUpsertWithoutDepositInput
    disconnect?: CregisDepositWhereInput | boolean
    delete?: CregisDepositWhereInput | boolean
    connect?: CregisDepositWhereUniqueInput
    update?: XOR<XOR<CregisDepositUpdateToOneWithWhereWithoutDepositInput, CregisDepositUpdateWithoutDepositInput>, CregisDepositUncheckedUpdateWithoutDepositInput>
  }

  export type DepositCreateNestedOneWithoutCregisDepositInput = {
    create?: XOR<DepositCreateWithoutCregisDepositInput, DepositUncheckedCreateWithoutCregisDepositInput>
    connectOrCreate?: DepositCreateOrConnectWithoutCregisDepositInput
    connect?: DepositWhereUniqueInput
  }

  export type DepositUpdateOneRequiredWithoutCregisDepositNestedInput = {
    create?: XOR<DepositCreateWithoutCregisDepositInput, DepositUncheckedCreateWithoutCregisDepositInput>
    connectOrCreate?: DepositCreateOrConnectWithoutCregisDepositInput
    upsert?: DepositUpsertWithoutCregisDepositInput
    connect?: DepositWhereUniqueInput
    update?: XOR<XOR<DepositUpdateToOneWithWhereWithoutCregisDepositInput, DepositUpdateWithoutCregisDepositInput>, DepositUncheckedUpdateWithoutCregisDepositInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type MT5AccountCreateNestedOneWithoutDefaultMT5AccountInput = {
    create?: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDefaultMT5AccountInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDefaultMT5AccountInput = {
    create?: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutDefaultMT5AccountInput
    connect?: UserWhereUniqueInput
  }

  export type MT5AccountUpdateOneRequiredWithoutDefaultMT5AccountNestedInput = {
    create?: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutDefaultMT5AccountInput
    upsert?: MT5AccountUpsertWithoutDefaultMT5AccountInput
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutDefaultMT5AccountInput, MT5AccountUpdateWithoutDefaultMT5AccountInput>, MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type UserUpdateOneRequiredWithoutDefaultMT5AccountNestedInput = {
    create?: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutDefaultMT5AccountInput
    upsert?: UserUpsertWithoutDefaultMT5AccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDefaultMT5AccountInput, UserUpdateWithoutDefaultMT5AccountInput>, UserUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type UserFavoriteCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutInstrumentInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserFavoriteUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutInstrumentInput | UserFavoriteUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutInstrumentNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput> | UserFavoriteCreateWithoutInstrumentInput[] | UserFavoriteUncheckedCreateWithoutInstrumentInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutInstrumentInput | UserFavoriteCreateOrConnectWithoutInstrumentInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput[]
    createMany?: UserFavoriteCreateManyInstrumentInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput | UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutInstrumentInput | UserFavoriteUpdateManyWithWhereWithoutInstrumentInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutRefreshTokenNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    upsert?: UserUpsertWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokenInput, UserUpdateWithoutRefreshTokenInput>, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type InstrumentCreateNestedOneWithoutUserFavoriteInput = {
    create?: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: InstrumentCreateOrConnectWithoutUserFavoriteInput
    connect?: InstrumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserFavoriteInput = {
    create?: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavoriteInput
    connect?: UserWhereUniqueInput
  }

  export type MT5AccountCreateNestedOneWithoutUserFavoriteInput = {
    create?: XOR<MT5AccountCreateWithoutUserFavoriteInput, MT5AccountUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserFavoriteInput
    connect?: MT5AccountWhereUniqueInput
  }

  export type InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput = {
    create?: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: InstrumentCreateOrConnectWithoutUserFavoriteInput
    upsert?: InstrumentUpsertWithoutUserFavoriteInput
    connect?: InstrumentWhereUniqueInput
    update?: XOR<XOR<InstrumentUpdateToOneWithWhereWithoutUserFavoriteInput, InstrumentUpdateWithoutUserFavoriteInput>, InstrumentUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type UserUpdateOneRequiredWithoutUserFavoriteNestedInput = {
    create?: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavoriteInput
    upsert?: UserUpsertWithoutUserFavoriteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFavoriteInput, UserUpdateWithoutUserFavoriteInput>, UserUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type MT5AccountUpdateOneWithoutUserFavoriteNestedInput = {
    create?: XOR<MT5AccountCreateWithoutUserFavoriteInput, MT5AccountUncheckedCreateWithoutUserFavoriteInput>
    connectOrCreate?: MT5AccountCreateOrConnectWithoutUserFavoriteInput
    upsert?: MT5AccountUpsertWithoutUserFavoriteInput
    disconnect?: MT5AccountWhereInput | boolean
    delete?: MT5AccountWhereInput | boolean
    connect?: MT5AccountWhereUniqueInput
    update?: XOR<XOR<MT5AccountUpdateToOneWithWhereWithoutUserFavoriteInput, MT5AccountUpdateWithoutUserFavoriteInput>, MT5AccountUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type UserCreateNestedOneWithoutUserLoginLogsInput = {
    create?: XOR<UserCreateWithoutUserLoginLogsInput, UserUncheckedCreateWithoutUserLoginLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLoginLogsNestedInput = {
    create?: XOR<UserCreateWithoutUserLoginLogsInput, UserUncheckedCreateWithoutUserLoginLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginLogsInput
    upsert?: UserUpsertWithoutUserLoginLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLoginLogsInput, UserUpdateWithoutUserLoginLogsInput>, UserUncheckedUpdateWithoutUserLoginLogsInput>
  }

  export type UserCreateNestedOneWithoutTerminalSettingsInput = {
    create?: XOR<UserCreateWithoutTerminalSettingsInput, UserUncheckedCreateWithoutTerminalSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTerminalSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTerminalSettingsNestedInput = {
    create?: XOR<UserCreateWithoutTerminalSettingsInput, UserUncheckedCreateWithoutTerminalSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTerminalSettingsInput
    upsert?: UserUpsertWithoutTerminalSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTerminalSettingsInput, UserUpdateWithoutTerminalSettingsInput>, UserUncheckedUpdateWithoutTerminalSettingsInput>
  }

  export type admin_login_logCreateNestedManyWithoutAdminInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
  }

  export type balance_operation_historyCreateNestedManyWithoutAdminInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
  }

  export type admin_login_logUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
  }

  export type balance_operation_historyUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
  }

  export type admin_login_logUpdateManyWithoutAdminNestedInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    upsert?: admin_login_logUpsertWithWhereUniqueWithoutAdminInput | admin_login_logUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    set?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    disconnect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    delete?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    update?: admin_login_logUpdateWithWhereUniqueWithoutAdminInput | admin_login_logUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: admin_login_logUpdateManyWithWhereWithoutAdminInput | admin_login_logUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
  }

  export type balance_operation_historyUpdateManyWithoutAdminNestedInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    upsert?: balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput | balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    set?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    disconnect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    delete?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    update?: balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput | balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: balance_operation_historyUpdateManyWithWhereWithoutAdminInput | balance_operation_historyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
  }

  export type admin_login_logUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput> | admin_login_logCreateWithoutAdminInput[] | admin_login_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_login_logCreateOrConnectWithoutAdminInput | admin_login_logCreateOrConnectWithoutAdminInput[]
    upsert?: admin_login_logUpsertWithWhereUniqueWithoutAdminInput | admin_login_logUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: admin_login_logCreateManyAdminInputEnvelope
    set?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    disconnect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    delete?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    connect?: admin_login_logWhereUniqueInput | admin_login_logWhereUniqueInput[]
    update?: admin_login_logUpdateWithWhereUniqueWithoutAdminInput | admin_login_logUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: admin_login_logUpdateManyWithWhereWithoutAdminInput | admin_login_logUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
  }

  export type balance_operation_historyUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput> | balance_operation_historyCreateWithoutAdminInput[] | balance_operation_historyUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: balance_operation_historyCreateOrConnectWithoutAdminInput | balance_operation_historyCreateOrConnectWithoutAdminInput[]
    upsert?: balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput | balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: balance_operation_historyCreateManyAdminInputEnvelope
    set?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    disconnect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    delete?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    connect?: balance_operation_historyWhereUniqueInput | balance_operation_historyWhereUniqueInput[]
    update?: balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput | balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: balance_operation_historyUpdateManyWithWhereWithoutAdminInput | balance_operation_historyUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
  }

  export type adminCreateNestedOneWithoutAdmin_login_logInput = {
    create?: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
    connectOrCreate?: adminCreateOrConnectWithoutAdmin_login_logInput
    connect?: adminWhereUniqueInput
  }

  export type adminUpdateOneRequiredWithoutAdmin_login_logNestedInput = {
    create?: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
    connectOrCreate?: adminCreateOrConnectWithoutAdmin_login_logInput
    upsert?: adminUpsertWithoutAdmin_login_logInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutAdmin_login_logInput, adminUpdateWithoutAdmin_login_logInput>, adminUncheckedUpdateWithoutAdmin_login_logInput>
  }

  export type adminCreateNestedOneWithoutBalance_operation_historyInput = {
    create?: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
    connectOrCreate?: adminCreateOrConnectWithoutBalance_operation_historyInput
    connect?: adminWhereUniqueInput
  }

  export type adminUpdateOneRequiredWithoutBalance_operation_historyNestedInput = {
    create?: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
    connectOrCreate?: adminCreateOrConnectWithoutBalance_operation_historyInput
    upsert?: adminUpsertWithoutBalance_operation_historyInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutBalance_operation_historyInput, adminUpdateWithoutBalance_operation_historyInput>, adminUncheckedUpdateWithoutBalance_operation_historyInput>
  }

  export type chat_conversationsCreatetagsInput = {
    set: string[]
  }

  export type chat_messagesCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type chat_participantsCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
  }

  export type chat_messagesUncheckedCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
  }

  export type chat_participantsUncheckedCreateNestedManyWithoutChat_conversationsInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
  }

  export type chat_conversationsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type chat_messagesUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput | chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type chat_participantsUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    set?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    disconnect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    delete?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    update?: chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput | chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
  }

  export type chat_messagesUncheckedUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput> | chat_messagesCreateWithoutChat_conversationsInput[] | chat_messagesUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_messagesCreateOrConnectWithoutChat_conversationsInput | chat_messagesCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_messagesCreateManyChat_conversationsInputEnvelope
    set?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    disconnect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    delete?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    connect?: chat_messagesWhereUniqueInput | chat_messagesWhereUniqueInput[]
    update?: chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput | chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
  }

  export type chat_participantsUncheckedUpdateManyWithoutChat_conversationsNestedInput = {
    create?: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput> | chat_participantsCreateWithoutChat_conversationsInput[] | chat_participantsUncheckedCreateWithoutChat_conversationsInput[]
    connectOrCreate?: chat_participantsCreateOrConnectWithoutChat_conversationsInput | chat_participantsCreateOrConnectWithoutChat_conversationsInput[]
    upsert?: chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput[]
    createMany?: chat_participantsCreateManyChat_conversationsInputEnvelope
    set?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    disconnect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    delete?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    connect?: chat_participantsWhereUniqueInput | chat_participantsWhereUniqueInput[]
    update?: chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput | chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput[]
    updateMany?: chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput | chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput[]
    deleteMany?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
  }

  export type chat_conversationsCreateNestedOneWithoutChat_messagesInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_messagesInput
    connect?: chat_conversationsWhereUniqueInput
  }

  export type chat_conversationsUpdateOneWithoutChat_messagesNestedInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_messagesInput
    upsert?: chat_conversationsUpsertWithoutChat_messagesInput
    disconnect?: chat_conversationsWhereInput | boolean
    delete?: chat_conversationsWhereInput | boolean
    connect?: chat_conversationsWhereUniqueInput
    update?: XOR<XOR<chat_conversationsUpdateToOneWithWhereWithoutChat_messagesInput, chat_conversationsUpdateWithoutChat_messagesInput>, chat_conversationsUncheckedUpdateWithoutChat_messagesInput>
  }

  export type chat_conversationsCreateNestedOneWithoutChat_participantsInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_participantsInput
    connect?: chat_conversationsWhereUniqueInput
  }

  export type chat_conversationsUpdateOneWithoutChat_participantsNestedInput = {
    create?: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
    connectOrCreate?: chat_conversationsCreateOrConnectWithoutChat_participantsInput
    upsert?: chat_conversationsUpsertWithoutChat_participantsInput
    disconnect?: chat_conversationsWhereInput | boolean
    delete?: chat_conversationsWhereInput | boolean
    connect?: chat_conversationsWhereUniqueInput
    update?: XOR<XOR<chat_conversationsUpdateToOneWithWhereWithoutChat_participantsInput, chat_conversationsUpdateWithoutChat_participantsInput>, chat_conversationsUncheckedUpdateWithoutChat_participantsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ib_group_assignmentsCreateNestedManyWithoutIb_requestsInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
  }

  export type ib_group_assignmentsUncheckedCreateNestedManyWithoutIb_requestsInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
  }

  export type ib_group_assignmentsUpdateManyWithoutIb_requestsNestedInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    upsert?: ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    set?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    disconnect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    delete?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    update?: ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput[]
    updateMany?: ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput | ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput[]
    deleteMany?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
  }

  export type ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsNestedInput = {
    create?: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput> | ib_group_assignmentsCreateWithoutIb_requestsInput[] | ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput[]
    connectOrCreate?: ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput | ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput[]
    upsert?: ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput[]
    createMany?: ib_group_assignmentsCreateManyIb_requestsInputEnvelope
    set?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    disconnect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    delete?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    connect?: ib_group_assignmentsWhereUniqueInput | ib_group_assignmentsWhereUniqueInput[]
    update?: ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput | ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput[]
    updateMany?: ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput | ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput[]
    deleteMany?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
  }

  export type ib_requestsCreateNestedOneWithoutIb_group_assignmentsInput = {
    create?: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
    connectOrCreate?: ib_requestsCreateOrConnectWithoutIb_group_assignmentsInput
    connect?: ib_requestsWhereUniqueInput
  }

  export type ib_requestsUpdateOneWithoutIb_group_assignmentsNestedInput = {
    create?: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
    connectOrCreate?: ib_requestsCreateOrConnectWithoutIb_group_assignmentsInput
    upsert?: ib_requestsUpsertWithoutIb_group_assignmentsInput
    disconnect?: ib_requestsWhereInput | boolean
    delete?: ib_requestsWhereInput | boolean
    connect?: ib_requestsWhereUniqueInput
    update?: XOR<XOR<ib_requestsUpdateToOneWithWhereWithoutIb_group_assignmentsInput, ib_requestsUpdateWithoutIb_group_assignmentsInput>, ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput>
  }

  export type support_ticketsCreatetagsInput = {
    set: string[]
  }

  export type support_ticketsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type support_ticket_repliesCreateattachmentsInput = {
    set: string[]
  }

  export type support_ticket_repliesUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type support_articlesCreatetagsInput = {
    set: string[]
  }

  export type support_articlesUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type support_faqCreatetagsInput = {
    set: string[]
  }

  export type support_faqUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type email_templatesCreatevariablesInput = {
    set: string[]
  }

  export type email_templatesUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutSuggestionsInput = {
    create?: XOR<UserCreateWithoutSuggestionsInput, UserUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSuggestionsNestedInput = {
    create?: XOR<UserCreateWithoutSuggestionsInput, UserUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuggestionsInput
    upsert?: UserUpsertWithoutSuggestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuggestionsInput, UserUpdateWithoutSuggestionsInput>, UserUncheckedUpdateWithoutSuggestionsInput>
  }

  export type UserCreateNestedOneWithoutPriceAlertsInput = {
    create?: XOR<UserCreateWithoutPriceAlertsInput, UserUncheckedCreateWithoutPriceAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPriceAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPriceAlertsNestedInput = {
    create?: XOR<UserCreateWithoutPriceAlertsInput, UserUncheckedCreateWithoutPriceAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPriceAlertsInput
    upsert?: UserUpsertWithoutPriceAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPriceAlertsInput, UserUpdateWithoutPriceAlertsInput>, UserUncheckedUpdateWithoutPriceAlertsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutAdminInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutAdminInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogCreateManyAdminInputEnvelope = {
    data: ActivityLogCreateManyAdminInput | ActivityLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type DefaultMT5AccountCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MT5Account: MT5AccountCreateNestedOneWithoutDefaultMT5AccountInput
  }

  export type DefaultMT5AccountUncheckedCreateWithoutUserInput = {
    id?: string
    mt5AccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultMT5AccountCreateOrConnectWithoutUserInput = {
    where: DefaultMT5AccountWhereUniqueInput
    create: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
  }

  export type DepositCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutDepositsInput
    cregisDeposit?: CregisDepositCreateNestedOneWithoutDepositInput
  }

  export type DepositUncheckedCreateWithoutUserInput = {
    id?: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cregisDeposit?: CregisDepositUncheckedCreateNestedOneWithoutDepositInput
  }

  export type DepositCreateOrConnectWithoutUserInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput>
  }

  export type DepositCreateManyUserInputEnvelope = {
    data: DepositCreateManyUserInput | DepositCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KYCCreateWithoutUserInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCUncheckedCreateWithoutUserInput = {
    id?: string
    isDocumentVerified?: boolean
    isAddressVerified?: boolean
    verificationStatus?: string
    documentReference?: string | null
    addressReference?: string | null
    amlReference?: string | null
    documentSubmittedAt?: Date | string | null
    addressSubmittedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCCreateOrConnectWithoutUserInput = {
    where: KYCWhereUniqueInput
    create: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountCreateManyUserInputEnvelope = {
    data: MT5AccountCreateManyUserInput | MT5AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    deviceName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastActivity?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    deviceName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastActivity?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TerminalSettingsCreateWithoutUserInput = {
    id?: string
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: string
    priceSource?: string
    appearance?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminalSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    showOnChart?: boolean
    showSignals?: boolean
    showHMR?: boolean
    showPriceAlerts?: boolean
    showOpenPositions?: boolean
    showTPSL?: boolean
    showEconomicCalendar?: boolean
    economicCalendarHighImpact?: boolean
    economicCalendarMiddleImpact?: boolean
    economicCalendarLowImpact?: boolean
    economicCalendarLowestImpact?: boolean
    priceAlertSound?: boolean
    closingSound?: boolean
    autoTPSL?: boolean
    openOrderMode?: string
    priceSource?: string
    appearance?: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminalSettingsCreateOrConnectWithoutUserInput = {
    where: TerminalSettingsWhereUniqueInput
    create: XOR<TerminalSettingsCreateWithoutUserInput, TerminalSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteCreateWithoutUserInput = {
    id?: string
    sortOrder?: number
    addedAt?: Date | string
    Instrument: InstrumentCreateNestedOneWithoutUserFavoriteInput
    MT5Account?: MT5AccountCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    instrumentId: string
    mt5AccountId?: string | null
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteCreateManyUserInputEnvelope = {
    data: UserFavoriteCreateManyUserInput | UserFavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLoginLogCreateWithoutUserInput = {
    id?: string
    user_agent?: string | null
    device?: string | null
    browser?: string | null
    success?: boolean
    failure_reason?: string | null
    createdAt?: Date | string
  }

  export type UserLoginLogUncheckedCreateWithoutUserInput = {
    id?: string
    user_agent?: string | null
    device?: string | null
    browser?: string | null
    success?: boolean
    failure_reason?: string | null
    createdAt?: Date | string
  }

  export type UserLoginLogCreateOrConnectWithoutUserInput = {
    where: UserLoginLogWhereUniqueInput
    create: XOR<UserLoginLogCreateWithoutUserInput, UserLoginLogUncheckedCreateWithoutUserInput>
  }

  export type UserLoginLogCreateManyUserInputEnvelope = {
    data: UserLoginLogCreateManyUserInput | UserLoginLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SuggestionCreateWithoutUserInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    comment: string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type SuggestionUncheckedCreateWithoutUserInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    comment: string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type SuggestionCreateOrConnectWithoutUserInput = {
    where: SuggestionWhereUniqueInput
    create: XOR<SuggestionCreateWithoutUserInput, SuggestionUncheckedCreateWithoutUserInput>
  }

  export type SuggestionCreateManyUserInputEnvelope = {
    data: SuggestionCreateManyUserInput | SuggestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PriceAlertCreateWithoutUserInput = {
    id?: string
    symbol: string
    targetPrice: number
    condition: string
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceAlertUncheckedCreateWithoutUserInput = {
    id?: string
    symbol: string
    targetPrice: number
    condition: string
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PriceAlertCreateOrConnectWithoutUserInput = {
    where: PriceAlertWhereUniqueInput
    create: XOR<PriceAlertCreateWithoutUserInput, PriceAlertUncheckedCreateWithoutUserInput>
  }

  export type PriceAlertCreateManyUserInputEnvelope = {
    data: PriceAlertCreateManyUserInput | PriceAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountType?: StringFilter<"Account"> | string
    balance?: FloatFilter<"Account"> | number
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutAdminInput, ActivityLogUncheckedUpdateWithoutAdminInput>
    create: XOR<ActivityLogCreateWithoutAdminInput, ActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutAdminInput, ActivityLogUncheckedUpdateWithoutAdminInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutAdminInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    adminId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    oldValues?: StringNullableFilter<"ActivityLog"> | string | null
    newValues?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type DefaultMT5AccountUpsertWithoutUserInput = {
    update: XOR<DefaultMT5AccountUpdateWithoutUserInput, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
    create: XOR<DefaultMT5AccountCreateWithoutUserInput, DefaultMT5AccountUncheckedCreateWithoutUserInput>
    where?: DefaultMT5AccountWhereInput
  }

  export type DefaultMT5AccountUpdateToOneWithWhereWithoutUserInput = {
    where?: DefaultMT5AccountWhereInput
    data: XOR<DefaultMT5AccountUpdateWithoutUserInput, DefaultMT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type DefaultMT5AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MT5Account?: MT5AccountUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
  }

  export type DefaultMT5AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpsertWithWhereUniqueWithoutUserInput = {
    where: DepositWhereUniqueInput
    update: XOR<DepositUpdateWithoutUserInput, DepositUncheckedUpdateWithoutUserInput>
    create: XOR<DepositCreateWithoutUserInput, DepositUncheckedCreateWithoutUserInput>
  }

  export type DepositUpdateWithWhereUniqueWithoutUserInput = {
    where: DepositWhereUniqueInput
    data: XOR<DepositUpdateWithoutUserInput, DepositUncheckedUpdateWithoutUserInput>
  }

  export type DepositUpdateManyWithWhereWithoutUserInput = {
    where: DepositScalarWhereInput
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyWithoutUserInput>
  }

  export type DepositScalarWhereInput = {
    AND?: DepositScalarWhereInput | DepositScalarWhereInput[]
    OR?: DepositScalarWhereInput[]
    NOT?: DepositScalarWhereInput | DepositScalarWhereInput[]
    id?: StringFilter<"Deposit"> | string
    userId?: StringFilter<"Deposit"> | string
    mt5AccountId?: StringFilter<"Deposit"> | string
    amount?: FloatFilter<"Deposit"> | number
    currency?: StringFilter<"Deposit"> | string
    method?: StringFilter<"Deposit"> | string
    paymentMethod?: StringNullableFilter<"Deposit"> | string | null
    transactionHash?: StringNullableFilter<"Deposit"> | string | null
    proofFileUrl?: StringNullableFilter<"Deposit"> | string | null
    bankDetails?: StringNullableFilter<"Deposit"> | string | null
    cryptoAddress?: StringNullableFilter<"Deposit"> | string | null
    depositAddress?: StringNullableFilter<"Deposit"> | string | null
    externalTransactionId?: StringNullableFilter<"Deposit"> | string | null
    status?: StringFilter<"Deposit"> | string
    rejectionReason?: StringNullableFilter<"Deposit"> | string | null
    approvedBy?: StringNullableFilter<"Deposit"> | string | null
    approvedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Deposit"> | Date | string | null
    createdAt?: DateTimeFilter<"Deposit"> | Date | string
    updatedAt?: DateTimeFilter<"Deposit"> | Date | string
  }

  export type KYCUpsertWithoutUserInput = {
    update: XOR<KYCUpdateWithoutUserInput, KYCUncheckedUpdateWithoutUserInput>
    create: XOR<KYCCreateWithoutUserInput, KYCUncheckedCreateWithoutUserInput>
    where?: KYCWhereInput
  }

  export type KYCUpdateToOneWithWhereWithoutUserInput = {
    where?: KYCWhereInput
    data: XOR<KYCUpdateWithoutUserInput, KYCUncheckedUpdateWithoutUserInput>
  }

  export type KYCUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDocumentVerified?: BoolFieldUpdateOperationsInput | boolean
    isAddressVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentReference?: NullableStringFieldUpdateOperationsInput | string | null
    addressReference?: NullableStringFieldUpdateOperationsInput | string | null
    amlReference?: NullableStringFieldUpdateOperationsInput | string | null
    documentSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressSubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    update: XOR<MT5AccountUpdateWithoutUserInput, MT5AccountUncheckedUpdateWithoutUserInput>
    create: XOR<MT5AccountCreateWithoutUserInput, MT5AccountUncheckedCreateWithoutUserInput>
  }

  export type MT5AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: MT5AccountWhereUniqueInput
    data: XOR<MT5AccountUpdateWithoutUserInput, MT5AccountUncheckedUpdateWithoutUserInput>
  }

  export type MT5AccountUpdateManyWithWhereWithoutUserInput = {
    where: MT5AccountScalarWhereInput
    data: XOR<MT5AccountUpdateManyMutationInput, MT5AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type MT5AccountScalarWhereInput = {
    AND?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
    OR?: MT5AccountScalarWhereInput[]
    NOT?: MT5AccountScalarWhereInput | MT5AccountScalarWhereInput[]
    id?: StringFilter<"MT5Account"> | string
    accountId?: StringFilter<"MT5Account"> | string
    userId?: StringNullableFilter<"MT5Account"> | string | null
    accountType?: StringFilter<"MT5Account"> | string
    createdAt?: DateTimeFilter<"MT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"MT5Account"> | Date | string
    password?: StringNullableFilter<"MT5Account"> | string | null
    leverage?: IntNullableFilter<"MT5Account"> | number | null
    nameOnAccount?: StringNullableFilter<"MT5Account"> | string | null
    package?: StringNullableFilter<"MT5Account"> | string | null
    group?: StringNullableFilter<"MT5Account"> | string | null
    balance?: FloatNullableFilter<"MT5Account"> | number | null
    credit?: FloatNullableFilter<"MT5Account"> | number | null
    currency?: StringNullableFilter<"MT5Account"> | string | null
    equity?: FloatNullableFilter<"MT5Account"> | number | null
    lastSyncedAt?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
    margin?: FloatNullableFilter<"MT5Account"> | number | null
    marginFree?: FloatNullableFilter<"MT5Account"> | number | null
    marginLevel?: FloatNullableFilter<"MT5Account"> | number | null
    profit?: FloatNullableFilter<"MT5Account"> | number | null
    archived?: BoolFilter<"MT5Account"> | boolean
    archived_at?: DateTimeNullableFilter<"MT5Account"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revoked?: BoolNullableFilter<"RefreshToken"> | boolean | null
    deviceName?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    lastActivity?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type TerminalSettingsUpsertWithoutUserInput = {
    update: XOR<TerminalSettingsUpdateWithoutUserInput, TerminalSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<TerminalSettingsCreateWithoutUserInput, TerminalSettingsUncheckedCreateWithoutUserInput>
    where?: TerminalSettingsWhereInput
  }

  export type TerminalSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: TerminalSettingsWhereInput
    data: XOR<TerminalSettingsUpdateWithoutUserInput, TerminalSettingsUncheckedUpdateWithoutUserInput>
  }

  export type TerminalSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    showOnChart?: BoolFieldUpdateOperationsInput | boolean
    showSignals?: BoolFieldUpdateOperationsInput | boolean
    showHMR?: BoolFieldUpdateOperationsInput | boolean
    showPriceAlerts?: BoolFieldUpdateOperationsInput | boolean
    showOpenPositions?: BoolFieldUpdateOperationsInput | boolean
    showTPSL?: BoolFieldUpdateOperationsInput | boolean
    showEconomicCalendar?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarHighImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarMiddleImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowestImpact?: BoolFieldUpdateOperationsInput | boolean
    priceAlertSound?: BoolFieldUpdateOperationsInput | boolean
    closingSound?: BoolFieldUpdateOperationsInput | boolean
    autoTPSL?: BoolFieldUpdateOperationsInput | boolean
    openOrderMode?: StringFieldUpdateOperationsInput | string
    priceSource?: StringFieldUpdateOperationsInput | string
    appearance?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    showOnChart?: BoolFieldUpdateOperationsInput | boolean
    showSignals?: BoolFieldUpdateOperationsInput | boolean
    showHMR?: BoolFieldUpdateOperationsInput | boolean
    showPriceAlerts?: BoolFieldUpdateOperationsInput | boolean
    showOpenPositions?: BoolFieldUpdateOperationsInput | boolean
    showTPSL?: BoolFieldUpdateOperationsInput | boolean
    showEconomicCalendar?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarHighImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarMiddleImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowImpact?: BoolFieldUpdateOperationsInput | boolean
    economicCalendarLowestImpact?: BoolFieldUpdateOperationsInput | boolean
    priceAlertSound?: BoolFieldUpdateOperationsInput | boolean
    closingSound?: BoolFieldUpdateOperationsInput | boolean
    autoTPSL?: BoolFieldUpdateOperationsInput | boolean
    openOrderMode?: StringFieldUpdateOperationsInput | string
    priceSource?: StringFieldUpdateOperationsInput | string
    appearance?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavoriteScalarWhereInput = {
    AND?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    OR?: UserFavoriteScalarWhereInput[]
    NOT?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    id?: StringFilter<"UserFavorite"> | string
    userId?: StringFilter<"UserFavorite"> | string
    instrumentId?: StringFilter<"UserFavorite"> | string
    mt5AccountId?: StringNullableFilter<"UserFavorite"> | string | null
    sortOrder?: IntFilter<"UserFavorite"> | number
    addedAt?: DateTimeFilter<"UserFavorite"> | Date | string
  }

  export type UserLoginLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLoginLogWhereUniqueInput
    update: XOR<UserLoginLogUpdateWithoutUserInput, UserLoginLogUncheckedUpdateWithoutUserInput>
    create: XOR<UserLoginLogCreateWithoutUserInput, UserLoginLogUncheckedCreateWithoutUserInput>
  }

  export type UserLoginLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLoginLogWhereUniqueInput
    data: XOR<UserLoginLogUpdateWithoutUserInput, UserLoginLogUncheckedUpdateWithoutUserInput>
  }

  export type UserLoginLogUpdateManyWithWhereWithoutUserInput = {
    where: UserLoginLogScalarWhereInput
    data: XOR<UserLoginLogUpdateManyMutationInput, UserLoginLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLoginLogScalarWhereInput = {
    AND?: UserLoginLogScalarWhereInput | UserLoginLogScalarWhereInput[]
    OR?: UserLoginLogScalarWhereInput[]
    NOT?: UserLoginLogScalarWhereInput | UserLoginLogScalarWhereInput[]
    id?: StringFilter<"UserLoginLog"> | string
    userId?: StringFilter<"UserLoginLog"> | string
    user_agent?: StringNullableFilter<"UserLoginLog"> | string | null
    device?: StringNullableFilter<"UserLoginLog"> | string | null
    browser?: StringNullableFilter<"UserLoginLog"> | string | null
    success?: BoolFilter<"UserLoginLog"> | boolean
    failure_reason?: StringNullableFilter<"UserLoginLog"> | string | null
    createdAt?: DateTimeFilter<"UserLoginLog"> | Date | string
  }

  export type SuggestionUpsertWithWhereUniqueWithoutUserInput = {
    where: SuggestionWhereUniqueInput
    update: XOR<SuggestionUpdateWithoutUserInput, SuggestionUncheckedUpdateWithoutUserInput>
    create: XOR<SuggestionCreateWithoutUserInput, SuggestionUncheckedCreateWithoutUserInput>
  }

  export type SuggestionUpdateWithWhereUniqueWithoutUserInput = {
    where: SuggestionWhereUniqueInput
    data: XOR<SuggestionUpdateWithoutUserInput, SuggestionUncheckedUpdateWithoutUserInput>
  }

  export type SuggestionUpdateManyWithWhereWithoutUserInput = {
    where: SuggestionScalarWhereInput
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyWithoutUserInput>
  }

  export type SuggestionScalarWhereInput = {
    AND?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
    OR?: SuggestionScalarWhereInput[]
    NOT?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
    id?: StringFilter<"Suggestion"> | string
    userId?: StringFilter<"Suggestion"> | string
    userName?: StringNullableFilter<"Suggestion"> | string | null
    userEmail?: StringNullableFilter<"Suggestion"> | string | null
    comment?: StringFilter<"Suggestion"> | string
    remarks?: StringNullableFilter<"Suggestion"> | string | null
    createdAt?: DateTimeFilter<"Suggestion"> | Date | string
  }

  export type PriceAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: PriceAlertWhereUniqueInput
    update: XOR<PriceAlertUpdateWithoutUserInput, PriceAlertUncheckedUpdateWithoutUserInput>
    create: XOR<PriceAlertCreateWithoutUserInput, PriceAlertUncheckedCreateWithoutUserInput>
  }

  export type PriceAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: PriceAlertWhereUniqueInput
    data: XOR<PriceAlertUpdateWithoutUserInput, PriceAlertUncheckedUpdateWithoutUserInput>
  }

  export type PriceAlertUpdateManyWithWhereWithoutUserInput = {
    where: PriceAlertScalarWhereInput
    data: XOR<PriceAlertUpdateManyMutationInput, PriceAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type PriceAlertScalarWhereInput = {
    AND?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
    OR?: PriceAlertScalarWhereInput[]
    NOT?: PriceAlertScalarWhereInput | PriceAlertScalarWhereInput[]
    id?: StringFilter<"PriceAlert"> | string
    userId?: StringFilter<"PriceAlert"> | string
    symbol?: StringFilter<"PriceAlert"> | string
    targetPrice?: FloatFilter<"PriceAlert"> | number
    condition?: StringFilter<"PriceAlert"> | string
    isActive?: BoolFilter<"PriceAlert"> | boolean
    isTriggered?: BoolFilter<"PriceAlert"> | boolean
    triggeredAt?: DateTimeNullableFilter<"PriceAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"PriceAlert"> | Date | string
  }

  export type UserCreateWithoutKycInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
  }

  export type UserUpsertWithoutKycInput = {
    update: XOR<UserUpdateWithoutKycInput, UserUncheckedUpdateWithoutKycInput>
    create: XOR<UserCreateWithoutKycInput, UserUncheckedCreateWithoutKycInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycInput, UserUncheckedUpdateWithoutKycInput>
  }

  export type UserUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DefaultMT5AccountCreateWithoutMT5AccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutDefaultMT5AccountInput
  }

  export type DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DefaultMT5AccountCreateOrConnectWithoutMT5AccountInput = {
    where: DefaultMT5AccountWhereUniqueInput
    create: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountCreateManyMT5AccountInputEnvelope = {
    data: DefaultMT5AccountCreateManyMT5AccountInput | DefaultMT5AccountCreateManyMT5AccountInput[]
    skipDuplicates?: boolean
  }

  export type DepositCreateWithoutMt5AccountInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepositsInput
    cregisDeposit?: CregisDepositCreateNestedOneWithoutDepositInput
  }

  export type DepositUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cregisDeposit?: CregisDepositUncheckedCreateNestedOneWithoutDepositInput
  }

  export type DepositCreateOrConnectWithoutMt5AccountInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput>
  }

  export type DepositCreateManyMt5AccountInputEnvelope = {
    data: DepositCreateManyMt5AccountInput | DepositCreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMt5AccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMt5AccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMt5AccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
  }

  export type MT5TransactionCreateWithoutMt5AccountInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionUncheckedCreateWithoutMt5AccountInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MT5TransactionCreateOrConnectWithoutMt5AccountInput = {
    where: MT5TransactionWhereUniqueInput
    create: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput>
  }

  export type MT5TransactionCreateManyMt5AccountInputEnvelope = {
    data: MT5TransactionCreateManyMt5AccountInput | MT5TransactionCreateManyMt5AccountInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutMT5AccountInput = {
    id?: string
    sortOrder?: number
    addedAt?: Date | string
    Instrument: InstrumentCreateNestedOneWithoutUserFavoriteInput
    User: UserCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateWithoutMT5AccountInput = {
    id?: string
    userId: string
    instrumentId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutMT5AccountInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutMT5AccountInput, UserFavoriteUncheckedCreateWithoutMT5AccountInput>
  }

  export type UserFavoriteCreateManyMT5AccountInputEnvelope = {
    data: UserFavoriteCreateManyMT5AccountInput | UserFavoriteCreateManyMT5AccountInput[]
    skipDuplicates?: boolean
  }

  export type DefaultMT5AccountUpsertWithWhereUniqueWithoutMT5AccountInput = {
    where: DefaultMT5AccountWhereUniqueInput
    update: XOR<DefaultMT5AccountUpdateWithoutMT5AccountInput, DefaultMT5AccountUncheckedUpdateWithoutMT5AccountInput>
    create: XOR<DefaultMT5AccountCreateWithoutMT5AccountInput, DefaultMT5AccountUncheckedCreateWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountUpdateWithWhereUniqueWithoutMT5AccountInput = {
    where: DefaultMT5AccountWhereUniqueInput
    data: XOR<DefaultMT5AccountUpdateWithoutMT5AccountInput, DefaultMT5AccountUncheckedUpdateWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountUpdateManyWithWhereWithoutMT5AccountInput = {
    where: DefaultMT5AccountScalarWhereInput
    data: XOR<DefaultMT5AccountUpdateManyMutationInput, DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountInput>
  }

  export type DefaultMT5AccountScalarWhereInput = {
    AND?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
    OR?: DefaultMT5AccountScalarWhereInput[]
    NOT?: DefaultMT5AccountScalarWhereInput | DefaultMT5AccountScalarWhereInput[]
    id?: StringFilter<"DefaultMT5Account"> | string
    userId?: StringFilter<"DefaultMT5Account"> | string
    mt5AccountId?: StringFilter<"DefaultMT5Account"> | string
    createdAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
    updatedAt?: DateTimeFilter<"DefaultMT5Account"> | Date | string
  }

  export type DepositUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: DepositWhereUniqueInput
    update: XOR<DepositUpdateWithoutMt5AccountInput, DepositUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<DepositCreateWithoutMt5AccountInput, DepositUncheckedCreateWithoutMt5AccountInput>
  }

  export type DepositUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: DepositWhereUniqueInput
    data: XOR<DepositUpdateWithoutMt5AccountInput, DepositUncheckedUpdateWithoutMt5AccountInput>
  }

  export type DepositUpdateManyWithWhereWithoutMt5AccountInput = {
    where: DepositScalarWhereInput
    data: XOR<DepositUpdateManyMutationInput, DepositUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type UserUpsertWithoutMt5AccountsInput = {
    update: XOR<UserUpdateWithoutMt5AccountsInput, UserUncheckedUpdateWithoutMt5AccountsInput>
    create: XOR<UserCreateWithoutMt5AccountsInput, UserUncheckedCreateWithoutMt5AccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMt5AccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMt5AccountsInput, UserUncheckedUpdateWithoutMt5AccountsInput>
  }

  export type UserUpdateWithoutMt5AccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMt5AccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5TransactionUpsertWithWhereUniqueWithoutMt5AccountInput = {
    where: MT5TransactionWhereUniqueInput
    update: XOR<MT5TransactionUpdateWithoutMt5AccountInput, MT5TransactionUncheckedUpdateWithoutMt5AccountInput>
    create: XOR<MT5TransactionCreateWithoutMt5AccountInput, MT5TransactionUncheckedCreateWithoutMt5AccountInput>
  }

  export type MT5TransactionUpdateWithWhereUniqueWithoutMt5AccountInput = {
    where: MT5TransactionWhereUniqueInput
    data: XOR<MT5TransactionUpdateWithoutMt5AccountInput, MT5TransactionUncheckedUpdateWithoutMt5AccountInput>
  }

  export type MT5TransactionUpdateManyWithWhereWithoutMt5AccountInput = {
    where: MT5TransactionScalarWhereInput
    data: XOR<MT5TransactionUpdateManyMutationInput, MT5TransactionUncheckedUpdateManyWithoutMt5AccountInput>
  }

  export type MT5TransactionScalarWhereInput = {
    AND?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
    OR?: MT5TransactionScalarWhereInput[]
    NOT?: MT5TransactionScalarWhereInput | MT5TransactionScalarWhereInput[]
    id?: StringFilter<"MT5Transaction"> | string
    type?: StringFilter<"MT5Transaction"> | string
    amount?: FloatFilter<"MT5Transaction"> | number
    status?: StringNullableFilter<"MT5Transaction"> | string | null
    paymentMethod?: StringNullableFilter<"MT5Transaction"> | string | null
    transactionId?: StringNullableFilter<"MT5Transaction"> | string | null
    comment?: StringNullableFilter<"MT5Transaction"> | string | null
    mt5AccountId?: StringFilter<"MT5Transaction"> | string
    createdAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    currency?: StringNullableFilter<"MT5Transaction"> | string | null
    depositId?: StringNullableFilter<"MT5Transaction"> | string | null
    withdrawalId?: StringNullableFilter<"MT5Transaction"> | string | null
    userId?: StringNullableFilter<"MT5Transaction"> | string | null
    processedBy?: StringNullableFilter<"MT5Transaction"> | string | null
    processedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MT5Transaction"> | Date | string | null
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutMT5AccountInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutMT5AccountInput, UserFavoriteUncheckedUpdateWithoutMT5AccountInput>
    create: XOR<UserFavoriteCreateWithoutMT5AccountInput, UserFavoriteUncheckedCreateWithoutMT5AccountInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutMT5AccountInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutMT5AccountInput, UserFavoriteUncheckedUpdateWithoutMT5AccountInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutMT5AccountInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutMT5AccountInput>
  }

  export type MT5AccountCreateWithoutMt5TransactionsInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutMt5TransactionsInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutMt5TransactionsInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
  }

  export type MT5AccountUpsertWithoutMt5TransactionsInput = {
    update: XOR<MT5AccountUpdateWithoutMt5TransactionsInput, MT5AccountUncheckedUpdateWithoutMt5TransactionsInput>
    create: XOR<MT5AccountCreateWithoutMt5TransactionsInput, MT5AccountUncheckedCreateWithoutMt5TransactionsInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutMt5TransactionsInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutMt5TransactionsInput, MT5AccountUncheckedUpdateWithoutMt5TransactionsInput>
  }

  export type MT5AccountUpdateWithoutMt5TransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutMt5TransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutMT5AccountNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5AccountCreateWithoutDepositsInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutDepositsInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutDepositsInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
  }

  export type UserCreateWithoutDepositsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepositsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepositsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
  }

  export type CregisDepositCreateWithoutDepositInput = {
    id?: string
    cregisOrderId: string
    cregisStatus?: string
    amount: number
    currency?: string
    paymentUrl?: string | null
    qrCodeUrl?: string | null
    expiresAt?: Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CregisDepositUncheckedCreateWithoutDepositInput = {
    id?: string
    cregisOrderId: string
    cregisStatus?: string
    amount: number
    currency?: string
    paymentUrl?: string | null
    qrCodeUrl?: string | null
    expiresAt?: Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CregisDepositCreateOrConnectWithoutDepositInput = {
    where: CregisDepositWhereUniqueInput
    create: XOR<CregisDepositCreateWithoutDepositInput, CregisDepositUncheckedCreateWithoutDepositInput>
  }

  export type MT5AccountUpsertWithoutDepositsInput = {
    update: XOR<MT5AccountUpdateWithoutDepositsInput, MT5AccountUncheckedUpdateWithoutDepositsInput>
    create: XOR<MT5AccountCreateWithoutDepositsInput, MT5AccountUncheckedCreateWithoutDepositsInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutDepositsInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutDepositsInput, MT5AccountUncheckedUpdateWithoutDepositsInput>
  }

  export type MT5AccountUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutMT5AccountNestedInput
  }

  export type UserUpsertWithoutDepositsInput = {
    update: XOR<UserUpdateWithoutDepositsInput, UserUncheckedUpdateWithoutDepositsInput>
    create: XOR<UserCreateWithoutDepositsInput, UserUncheckedCreateWithoutDepositsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepositsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepositsInput, UserUncheckedUpdateWithoutDepositsInput>
  }

  export type UserUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepositsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CregisDepositUpsertWithoutDepositInput = {
    update: XOR<CregisDepositUpdateWithoutDepositInput, CregisDepositUncheckedUpdateWithoutDepositInput>
    create: XOR<CregisDepositCreateWithoutDepositInput, CregisDepositUncheckedCreateWithoutDepositInput>
    where?: CregisDepositWhereInput
  }

  export type CregisDepositUpdateToOneWithWhereWithoutDepositInput = {
    where?: CregisDepositWhereInput
    data: XOR<CregisDepositUpdateWithoutDepositInput, CregisDepositUncheckedUpdateWithoutDepositInput>
  }

  export type CregisDepositUpdateWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    cregisOrderId?: StringFieldUpdateOperationsInput | string
    cregisStatus?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CregisDepositUncheckedUpdateWithoutDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    cregisOrderId?: StringFieldUpdateOperationsInput | string
    cregisStatus?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhookData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositCreateWithoutCregisDepositInput = {
    id?: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mt5Account: MT5AccountCreateNestedOneWithoutDepositsInput
    user: UserCreateNestedOneWithoutDepositsInput
  }

  export type DepositUncheckedCreateWithoutCregisDepositInput = {
    id?: string
    userId: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositCreateOrConnectWithoutCregisDepositInput = {
    where: DepositWhereUniqueInput
    create: XOR<DepositCreateWithoutCregisDepositInput, DepositUncheckedCreateWithoutCregisDepositInput>
  }

  export type DepositUpsertWithoutCregisDepositInput = {
    update: XOR<DepositUpdateWithoutCregisDepositInput, DepositUncheckedUpdateWithoutCregisDepositInput>
    create: XOR<DepositCreateWithoutCregisDepositInput, DepositUncheckedCreateWithoutCregisDepositInput>
    where?: DepositWhereInput
  }

  export type DepositUpdateToOneWithWhereWithoutCregisDepositInput = {
    where?: DepositWhereInput
    data: XOR<DepositUpdateWithoutCregisDepositInput, DepositUncheckedUpdateWithoutCregisDepositInput>
  }

  export type DepositUpdateWithoutCregisDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutDepositsNestedInput
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
  }

  export type DepositUncheckedUpdateWithoutCregisDepositInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5AccountCreateWithoutDefaultMT5AccountInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutMT5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutDefaultMT5AccountInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
  }

  export type UserCreateWithoutDefaultMT5AccountInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDefaultMT5AccountInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDefaultMT5AccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
  }

  export type MT5AccountUpsertWithoutDefaultMT5AccountInput = {
    update: XOR<MT5AccountUpdateWithoutDefaultMT5AccountInput, MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput>
    create: XOR<MT5AccountCreateWithoutDefaultMT5AccountInput, MT5AccountUncheckedCreateWithoutDefaultMT5AccountInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutDefaultMT5AccountInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutDefaultMT5AccountInput, MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type MT5AccountUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutMT5AccountNestedInput
  }

  export type UserUpsertWithoutDefaultMT5AccountInput = {
    update: XOR<UserUpdateWithoutDefaultMT5AccountInput, UserUncheckedUpdateWithoutDefaultMT5AccountInput>
    create: XOR<UserCreateWithoutDefaultMT5AccountInput, UserUncheckedCreateWithoutDefaultMT5AccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDefaultMT5AccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDefaultMT5AccountInput, UserUncheckedUpdateWithoutDefaultMT5AccountInput>
  }

  export type UserUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDefaultMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFavoriteCreateWithoutInstrumentInput = {
    id?: string
    sortOrder?: number
    addedAt?: Date | string
    User: UserCreateNestedOneWithoutUserFavoriteInput
    MT5Account?: MT5AccountCreateNestedOneWithoutUserFavoriteInput
  }

  export type UserFavoriteUncheckedCreateWithoutInstrumentInput = {
    id?: string
    userId: string
    mt5AccountId?: string | null
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutInstrumentInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput>
  }

  export type UserFavoriteCreateManyInstrumentInputEnvelope = {
    data: UserFavoriteCreateManyInstrumentInput | UserFavoriteCreateManyInstrumentInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutInstrumentInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutInstrumentInput, UserFavoriteUncheckedUpdateWithoutInstrumentInput>
    create: XOR<UserFavoriteCreateWithoutInstrumentInput, UserFavoriteUncheckedCreateWithoutInstrumentInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutInstrumentInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutInstrumentInput, UserFavoriteUncheckedUpdateWithoutInstrumentInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutInstrumentInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutInstrumentInput>
  }

  export type UserCreateWithoutRefreshTokenInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
  }

  export type UserUpsertWithoutRefreshTokenInput = {
    update: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type UserUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstrumentCreateWithoutUserFavoriteInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    path?: string | null
    accountGroup?: string | null
    isin?: string | null
    sector?: number | null
    industry?: number | null
    country?: string | null
    currency?: string | null
    currencyProfit?: string | null
    currencyMargin?: string | null
    point?: number | null
    multiply?: number | null
    tickSize?: number | null
    tickValue?: number | null
    volumeLimit?: number | null
    marginInitial?: number | null
    marginMaintenance?: number | null
    tradeMode?: number | null
    tradeFlags?: number | null
    calcMode?: number | null
    execMode?: number | null
    swapLong?: number | null
    swapShort?: number | null
    swapMode?: number | null
  }

  export type InstrumentUncheckedCreateWithoutUserFavoriteInput = {
    id: string
    symbol: string
    name?: string | null
    description?: string | null
    category: string
    group?: string | null
    digits?: number
    contractSize?: number
    minVolume?: number
    maxVolume?: number
    volumeStep?: number
    spread?: number
    isActive?: boolean
    tradingHours?: string | null
    lastUpdated: Date | string
    createdAt?: Date | string
    updatedAt: Date | string
    path?: string | null
    accountGroup?: string | null
    isin?: string | null
    sector?: number | null
    industry?: number | null
    country?: string | null
    currency?: string | null
    currencyProfit?: string | null
    currencyMargin?: string | null
    point?: number | null
    multiply?: number | null
    tickSize?: number | null
    tickValue?: number | null
    volumeLimit?: number | null
    marginInitial?: number | null
    marginMaintenance?: number | null
    tradeMode?: number | null
    tradeFlags?: number | null
    calcMode?: number | null
    execMode?: number | null
    swapLong?: number | null
    swapShort?: number | null
    swapMode?: number | null
  }

  export type InstrumentCreateOrConnectWithoutUserFavoriteInput = {
    where: InstrumentWhereUniqueInput
    create: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
  }

  export type UserCreateWithoutUserFavoriteInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserFavoriteInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserFavoriteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
  }

  export type MT5AccountCreateWithoutUserFavoriteInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositCreateNestedManyWithoutMt5AccountInput
    user?: UserCreateNestedOneWithoutMt5AccountsInput
    mt5Transactions?: MT5TransactionCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountUncheckedCreateWithoutUserFavoriteInput = {
    id?: string
    accountId: string
    userId?: string | null
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedManyWithoutMT5AccountInput
    deposits?: DepositUncheckedCreateNestedManyWithoutMt5AccountInput
    mt5Transactions?: MT5TransactionUncheckedCreateNestedManyWithoutMt5AccountInput
  }

  export type MT5AccountCreateOrConnectWithoutUserFavoriteInput = {
    where: MT5AccountWhereUniqueInput
    create: XOR<MT5AccountCreateWithoutUserFavoriteInput, MT5AccountUncheckedCreateWithoutUserFavoriteInput>
  }

  export type InstrumentUpsertWithoutUserFavoriteInput = {
    update: XOR<InstrumentUpdateWithoutUserFavoriteInput, InstrumentUncheckedUpdateWithoutUserFavoriteInput>
    create: XOR<InstrumentCreateWithoutUserFavoriteInput, InstrumentUncheckedCreateWithoutUserFavoriteInput>
    where?: InstrumentWhereInput
  }

  export type InstrumentUpdateToOneWithWhereWithoutUserFavoriteInput = {
    where?: InstrumentWhereInput
    data: XOR<InstrumentUpdateWithoutUserFavoriteInput, InstrumentUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type InstrumentUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: NullableStringFieldUpdateOperationsInput | string | null
    accountGroup?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencyProfit?: NullableStringFieldUpdateOperationsInput | string | null
    currencyMargin?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    multiply?: NullableIntFieldUpdateOperationsInput | number | null
    tickSize?: NullableFloatFieldUpdateOperationsInput | number | null
    tickValue?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    marginInitial?: NullableFloatFieldUpdateOperationsInput | number | null
    marginMaintenance?: NullableFloatFieldUpdateOperationsInput | number | null
    tradeMode?: NullableIntFieldUpdateOperationsInput | number | null
    tradeFlags?: NullableIntFieldUpdateOperationsInput | number | null
    calcMode?: NullableIntFieldUpdateOperationsInput | number | null
    execMode?: NullableIntFieldUpdateOperationsInput | number | null
    swapLong?: NullableFloatFieldUpdateOperationsInput | number | null
    swapShort?: NullableFloatFieldUpdateOperationsInput | number | null
    swapMode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstrumentUncheckedUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    digits?: IntFieldUpdateOperationsInput | number
    contractSize?: FloatFieldUpdateOperationsInput | number
    minVolume?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    volumeStep?: FloatFieldUpdateOperationsInput | number
    spread?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tradingHours?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: NullableStringFieldUpdateOperationsInput | string | null
    accountGroup?: NullableStringFieldUpdateOperationsInput | string | null
    isin?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    currencyProfit?: NullableStringFieldUpdateOperationsInput | string | null
    currencyMargin?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    multiply?: NullableIntFieldUpdateOperationsInput | number | null
    tickSize?: NullableFloatFieldUpdateOperationsInput | number | null
    tickValue?: NullableFloatFieldUpdateOperationsInput | number | null
    volumeLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    marginInitial?: NullableFloatFieldUpdateOperationsInput | number | null
    marginMaintenance?: NullableFloatFieldUpdateOperationsInput | number | null
    tradeMode?: NullableIntFieldUpdateOperationsInput | number | null
    tradeFlags?: NullableIntFieldUpdateOperationsInput | number | null
    calcMode?: NullableIntFieldUpdateOperationsInput | number | null
    execMode?: NullableIntFieldUpdateOperationsInput | number | null
    swapLong?: NullableFloatFieldUpdateOperationsInput | number | null
    swapShort?: NullableFloatFieldUpdateOperationsInput | number | null
    swapMode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutUserFavoriteInput = {
    update: XOR<UserUpdateWithoutUserFavoriteInput, UserUncheckedUpdateWithoutUserFavoriteInput>
    create: XOR<UserCreateWithoutUserFavoriteInput, UserUncheckedCreateWithoutUserFavoriteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFavoriteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFavoriteInput, UserUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type UserUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MT5AccountUpsertWithoutUserFavoriteInput = {
    update: XOR<MT5AccountUpdateWithoutUserFavoriteInput, MT5AccountUncheckedUpdateWithoutUserFavoriteInput>
    create: XOR<MT5AccountCreateWithoutUserFavoriteInput, MT5AccountUncheckedCreateWithoutUserFavoriteInput>
    where?: MT5AccountWhereInput
  }

  export type MT5AccountUpdateToOneWithWhereWithoutUserFavoriteInput = {
    where?: MT5AccountWhereInput
    data: XOR<MT5AccountUpdateWithoutUserFavoriteInput, MT5AccountUncheckedUpdateWithoutUserFavoriteInput>
  }

  export type MT5AccountUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    user?: UserUpdateOneWithoutMt5AccountsNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutUserFavoriteInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
  }

  export type UserCreateWithoutUserLoginLogsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLoginLogsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLoginLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLoginLogsInput, UserUncheckedCreateWithoutUserLoginLogsInput>
  }

  export type UserUpsertWithoutUserLoginLogsInput = {
    update: XOR<UserUpdateWithoutUserLoginLogsInput, UserUncheckedUpdateWithoutUserLoginLogsInput>
    create: XOR<UserCreateWithoutUserLoginLogsInput, UserUncheckedCreateWithoutUserLoginLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLoginLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLoginLogsInput, UserUncheckedUpdateWithoutUserLoginLogsInput>
  }

  export type UserUpdateWithoutUserLoginLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLoginLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTerminalSettingsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTerminalSettingsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTerminalSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTerminalSettingsInput, UserUncheckedCreateWithoutTerminalSettingsInput>
  }

  export type UserUpsertWithoutTerminalSettingsInput = {
    update: XOR<UserUpdateWithoutTerminalSettingsInput, UserUncheckedUpdateWithoutTerminalSettingsInput>
    create: XOR<UserCreateWithoutTerminalSettingsInput, UserUncheckedCreateWithoutTerminalSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTerminalSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTerminalSettingsInput, UserUncheckedUpdateWithoutTerminalSettingsInput>
  }

  export type UserUpdateWithoutTerminalSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTerminalSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type admin_login_logCreateWithoutAdminInput = {
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUncheckedCreateWithoutAdminInput = {
    id?: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type admin_login_logCreateOrConnectWithoutAdminInput = {
    where: admin_login_logWhereUniqueInput
    create: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput>
  }

  export type admin_login_logCreateManyAdminInputEnvelope = {
    data: admin_login_logCreateManyAdminInput | admin_login_logCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type balance_operation_historyCreateWithoutAdminInput = {
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyUncheckedCreateWithoutAdminInput = {
    id?: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyCreateOrConnectWithoutAdminInput = {
    where: balance_operation_historyWhereUniqueInput
    create: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput>
  }

  export type balance_operation_historyCreateManyAdminInputEnvelope = {
    data: balance_operation_historyCreateManyAdminInput | balance_operation_historyCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type admin_login_logUpsertWithWhereUniqueWithoutAdminInput = {
    where: admin_login_logWhereUniqueInput
    update: XOR<admin_login_logUpdateWithoutAdminInput, admin_login_logUncheckedUpdateWithoutAdminInput>
    create: XOR<admin_login_logCreateWithoutAdminInput, admin_login_logUncheckedCreateWithoutAdminInput>
  }

  export type admin_login_logUpdateWithWhereUniqueWithoutAdminInput = {
    where: admin_login_logWhereUniqueInput
    data: XOR<admin_login_logUpdateWithoutAdminInput, admin_login_logUncheckedUpdateWithoutAdminInput>
  }

  export type admin_login_logUpdateManyWithWhereWithoutAdminInput = {
    where: admin_login_logScalarWhereInput
    data: XOR<admin_login_logUpdateManyMutationInput, admin_login_logUncheckedUpdateManyWithoutAdminInput>
  }

  export type admin_login_logScalarWhereInput = {
    AND?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
    OR?: admin_login_logScalarWhereInput[]
    NOT?: admin_login_logScalarWhereInput | admin_login_logScalarWhereInput[]
    id?: IntFilter<"admin_login_log"> | number
    admin_id?: IntFilter<"admin_login_log"> | number
    ip_address?: StringFilter<"admin_login_log"> | string
    user_agent?: StringNullableFilter<"admin_login_log"> | string | null
    location?: StringNullableFilter<"admin_login_log"> | string | null
    device?: StringNullableFilter<"admin_login_log"> | string | null
    browser?: StringNullableFilter<"admin_login_log"> | string | null
    os?: StringNullableFilter<"admin_login_log"> | string | null
    success?: BoolFilter<"admin_login_log"> | boolean
    failure_reason?: StringNullableFilter<"admin_login_log"> | string | null
    created_at?: DateTimeFilter<"admin_login_log"> | Date | string
  }

  export type balance_operation_historyUpsertWithWhereUniqueWithoutAdminInput = {
    where: balance_operation_historyWhereUniqueInput
    update: XOR<balance_operation_historyUpdateWithoutAdminInput, balance_operation_historyUncheckedUpdateWithoutAdminInput>
    create: XOR<balance_operation_historyCreateWithoutAdminInput, balance_operation_historyUncheckedCreateWithoutAdminInput>
  }

  export type balance_operation_historyUpdateWithWhereUniqueWithoutAdminInput = {
    where: balance_operation_historyWhereUniqueInput
    data: XOR<balance_operation_historyUpdateWithoutAdminInput, balance_operation_historyUncheckedUpdateWithoutAdminInput>
  }

  export type balance_operation_historyUpdateManyWithWhereWithoutAdminInput = {
    where: balance_operation_historyScalarWhereInput
    data: XOR<balance_operation_historyUpdateManyMutationInput, balance_operation_historyUncheckedUpdateManyWithoutAdminInput>
  }

  export type balance_operation_historyScalarWhereInput = {
    AND?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
    OR?: balance_operation_historyScalarWhereInput[]
    NOT?: balance_operation_historyScalarWhereInput | balance_operation_historyScalarWhereInput[]
    id?: IntFilter<"balance_operation_history"> | number
    admin_id?: IntFilter<"balance_operation_history"> | number
    mt5_login?: StringFilter<"balance_operation_history"> | string
    operation_type?: StringFilter<"balance_operation_history"> | string
    amount?: FloatFilter<"balance_operation_history"> | number
    currency?: StringFilter<"balance_operation_history"> | string
    description?: StringNullableFilter<"balance_operation_history"> | string | null
    status?: StringFilter<"balance_operation_history"> | string
    error_message?: StringNullableFilter<"balance_operation_history"> | string | null
    ip_address?: StringNullableFilter<"balance_operation_history"> | string | null
    user_agent?: StringNullableFilter<"balance_operation_history"> | string | null
    created_at?: DateTimeFilter<"balance_operation_history"> | Date | string
  }

  export type adminCreateWithoutAdmin_login_logInput = {
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance_operation_history?: balance_operation_historyCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutAdmin_login_logInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    balance_operation_history?: balance_operation_historyUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutAdmin_login_logInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
  }

  export type adminUpsertWithoutAdmin_login_logInput = {
    update: XOR<adminUpdateWithoutAdmin_login_logInput, adminUncheckedUpdateWithoutAdmin_login_logInput>
    create: XOR<adminCreateWithoutAdmin_login_logInput, adminUncheckedCreateWithoutAdmin_login_logInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutAdmin_login_logInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutAdmin_login_logInput, adminUncheckedUpdateWithoutAdmin_login_logInput>
  }

  export type adminUpdateWithoutAdmin_login_logInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance_operation_history?: balance_operation_historyUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutAdmin_login_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance_operation_history?: balance_operation_historyUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateWithoutBalance_operation_historyInput = {
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateWithoutBalance_operation_historyInput = {
    id?: number
    username: string
    email: string
    password_hash: string
    admin_role?: string | null
    is_active?: boolean | null
    last_login?: Date | string | null
    login_attempts?: number | null
    locked_until?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    admin_login_log?: admin_login_logUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminCreateOrConnectWithoutBalance_operation_historyInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
  }

  export type adminUpsertWithoutBalance_operation_historyInput = {
    update: XOR<adminUpdateWithoutBalance_operation_historyInput, adminUncheckedUpdateWithoutBalance_operation_historyInput>
    create: XOR<adminCreateWithoutBalance_operation_historyInput, adminUncheckedCreateWithoutBalance_operation_historyInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutBalance_operation_historyInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutBalance_operation_historyInput, adminUncheckedUpdateWithoutBalance_operation_historyInput>
  }

  export type adminUpdateWithoutBalance_operation_historyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateWithoutBalance_operation_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_role?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: NullableIntFieldUpdateOperationsInput | number | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_login_log?: admin_login_logUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type chat_messagesCreateWithoutChat_conversationsInput = {
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesUncheckedCreateWithoutChat_conversationsInput = {
    id?: number
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_messagesCreateOrConnectWithoutChat_conversationsInput = {
    where: chat_messagesWhereUniqueInput
    create: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_messagesCreateManyChat_conversationsInputEnvelope = {
    data: chat_messagesCreateManyChat_conversationsInput | chat_messagesCreateManyChat_conversationsInput[]
    skipDuplicates?: boolean
  }

  export type chat_participantsCreateWithoutChat_conversationsInput = {
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsUncheckedCreateWithoutChat_conversationsInput = {
    id?: number
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_participantsCreateOrConnectWithoutChat_conversationsInput = {
    where: chat_participantsWhereUniqueInput
    create: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_participantsCreateManyChat_conversationsInputEnvelope = {
    data: chat_participantsCreateManyChat_conversationsInput | chat_participantsCreateManyChat_conversationsInput[]
    skipDuplicates?: boolean
  }

  export type chat_messagesUpsertWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_messagesWhereUniqueInput
    update: XOR<chat_messagesUpdateWithoutChat_conversationsInput, chat_messagesUncheckedUpdateWithoutChat_conversationsInput>
    create: XOR<chat_messagesCreateWithoutChat_conversationsInput, chat_messagesUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_messagesUpdateWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_messagesWhereUniqueInput
    data: XOR<chat_messagesUpdateWithoutChat_conversationsInput, chat_messagesUncheckedUpdateWithoutChat_conversationsInput>
  }

  export type chat_messagesUpdateManyWithWhereWithoutChat_conversationsInput = {
    where: chat_messagesScalarWhereInput
    data: XOR<chat_messagesUpdateManyMutationInput, chat_messagesUncheckedUpdateManyWithoutChat_conversationsInput>
  }

  export type chat_messagesScalarWhereInput = {
    AND?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    OR?: chat_messagesScalarWhereInput[]
    NOT?: chat_messagesScalarWhereInput | chat_messagesScalarWhereInput[]
    id?: IntFilter<"chat_messages"> | number
    conversation_id?: IntNullableFilter<"chat_messages"> | number | null
    sender_id?: StringFilter<"chat_messages"> | string
    sender_name?: StringFilter<"chat_messages"> | string
    sender_type?: StringFilter<"chat_messages"> | string
    message_type?: StringNullableFilter<"chat_messages"> | string | null
    content?: StringFilter<"chat_messages"> | string
    metadata?: JsonNullableFilter<"chat_messages">
    is_read?: BoolNullableFilter<"chat_messages"> | boolean | null
    read_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    created_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"chat_messages"> | Date | string | null
  }

  export type chat_participantsUpsertWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_participantsWhereUniqueInput
    update: XOR<chat_participantsUpdateWithoutChat_conversationsInput, chat_participantsUncheckedUpdateWithoutChat_conversationsInput>
    create: XOR<chat_participantsCreateWithoutChat_conversationsInput, chat_participantsUncheckedCreateWithoutChat_conversationsInput>
  }

  export type chat_participantsUpdateWithWhereUniqueWithoutChat_conversationsInput = {
    where: chat_participantsWhereUniqueInput
    data: XOR<chat_participantsUpdateWithoutChat_conversationsInput, chat_participantsUncheckedUpdateWithoutChat_conversationsInput>
  }

  export type chat_participantsUpdateManyWithWhereWithoutChat_conversationsInput = {
    where: chat_participantsScalarWhereInput
    data: XOR<chat_participantsUpdateManyMutationInput, chat_participantsUncheckedUpdateManyWithoutChat_conversationsInput>
  }

  export type chat_participantsScalarWhereInput = {
    AND?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
    OR?: chat_participantsScalarWhereInput[]
    NOT?: chat_participantsScalarWhereInput | chat_participantsScalarWhereInput[]
    id?: IntFilter<"chat_participants"> | number
    conversation_id?: IntNullableFilter<"chat_participants"> | number | null
    user_id?: StringFilter<"chat_participants"> | string
    user_name?: StringFilter<"chat_participants"> | string
    user_type?: StringFilter<"chat_participants"> | string
    role?: StringNullableFilter<"chat_participants"> | string | null
    joined_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    left_at?: DateTimeNullableFilter<"chat_participants"> | Date | string | null
    is_active?: BoolNullableFilter<"chat_participants"> | boolean | null
  }

  export type chat_conversationsCreateWithoutChat_messagesInput = {
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_participants?: chat_participantsCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUncheckedCreateWithoutChat_messagesInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_participants?: chat_participantsUncheckedCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsCreateOrConnectWithoutChat_messagesInput = {
    where: chat_conversationsWhereUniqueInput
    create: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
  }

  export type chat_conversationsUpsertWithoutChat_messagesInput = {
    update: XOR<chat_conversationsUpdateWithoutChat_messagesInput, chat_conversationsUncheckedUpdateWithoutChat_messagesInput>
    create: XOR<chat_conversationsCreateWithoutChat_messagesInput, chat_conversationsUncheckedCreateWithoutChat_messagesInput>
    where?: chat_conversationsWhereInput
  }

  export type chat_conversationsUpdateToOneWithWhereWithoutChat_messagesInput = {
    where?: chat_conversationsWhereInput
    data: XOR<chat_conversationsUpdateWithoutChat_messagesInput, chat_conversationsUncheckedUpdateWithoutChat_messagesInput>
  }

  export type chat_conversationsUpdateWithoutChat_messagesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_participants?: chat_participantsUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsUncheckedUpdateWithoutChat_messagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_participants?: chat_participantsUncheckedUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsCreateWithoutChat_participantsInput = {
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsUncheckedCreateWithoutChat_participantsInput = {
    id?: number
    user_id: string
    user_name: string
    user_email: string
    admin_id?: string | null
    status?: string | null
    priority?: string | null
    subject?: string | null
    last_message_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    closed_at?: Date | string | null
    closed_by?: string | null
    tags?: chat_conversationsCreatetagsInput | string[]
    unread_count_admin?: number | null
    unread_count_user?: number | null
    chat_messages?: chat_messagesUncheckedCreateNestedManyWithoutChat_conversationsInput
  }

  export type chat_conversationsCreateOrConnectWithoutChat_participantsInput = {
    where: chat_conversationsWhereUniqueInput
    create: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
  }

  export type chat_conversationsUpsertWithoutChat_participantsInput = {
    update: XOR<chat_conversationsUpdateWithoutChat_participantsInput, chat_conversationsUncheckedUpdateWithoutChat_participantsInput>
    create: XOR<chat_conversationsCreateWithoutChat_participantsInput, chat_conversationsUncheckedCreateWithoutChat_participantsInput>
    where?: chat_conversationsWhereInput
  }

  export type chat_conversationsUpdateToOneWithWhereWithoutChat_participantsInput = {
    where?: chat_conversationsWhereInput
    data: XOR<chat_conversationsUpdateWithoutChat_participantsInput, chat_conversationsUncheckedUpdateWithoutChat_participantsInput>
  }

  export type chat_conversationsUpdateWithoutChat_participantsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUpdateManyWithoutChat_conversationsNestedInput
  }

  export type chat_conversationsUncheckedUpdateWithoutChat_participantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    admin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_by?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: chat_conversationsUpdatetagsInput | string[]
    unread_count_admin?: NullableIntFieldUpdateOperationsInput | number | null
    unread_count_user?: NullableIntFieldUpdateOperationsInput | number | null
    chat_messages?: chat_messagesUncheckedUpdateManyWithoutChat_conversationsNestedInput
  }

  export type ib_group_assignmentsCreateWithoutIb_requestsInput = {
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput = {
    id?: number
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsCreateOrConnectWithoutIb_requestsInput = {
    where: ib_group_assignmentsWhereUniqueInput
    create: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsCreateManyIb_requestsInputEnvelope = {
    data: ib_group_assignmentsCreateManyIb_requestsInput | ib_group_assignmentsCreateManyIb_requestsInput[]
    skipDuplicates?: boolean
  }

  export type ib_group_assignmentsUpsertWithWhereUniqueWithoutIb_requestsInput = {
    where: ib_group_assignmentsWhereUniqueInput
    update: XOR<ib_group_assignmentsUpdateWithoutIb_requestsInput, ib_group_assignmentsUncheckedUpdateWithoutIb_requestsInput>
    create: XOR<ib_group_assignmentsCreateWithoutIb_requestsInput, ib_group_assignmentsUncheckedCreateWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsUpdateWithWhereUniqueWithoutIb_requestsInput = {
    where: ib_group_assignmentsWhereUniqueInput
    data: XOR<ib_group_assignmentsUpdateWithoutIb_requestsInput, ib_group_assignmentsUncheckedUpdateWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsUpdateManyWithWhereWithoutIb_requestsInput = {
    where: ib_group_assignmentsScalarWhereInput
    data: XOR<ib_group_assignmentsUpdateManyMutationInput, ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsInput>
  }

  export type ib_group_assignmentsScalarWhereInput = {
    AND?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
    OR?: ib_group_assignmentsScalarWhereInput[]
    NOT?: ib_group_assignmentsScalarWhereInput | ib_group_assignmentsScalarWhereInput[]
    id?: IntFilter<"ib_group_assignments"> | number
    ib_request_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    group_id?: StringFilter<"ib_group_assignments"> | string
    group_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    structure_id?: IntNullableFilter<"ib_group_assignments"> | number | null
    structure_name?: StringNullableFilter<"ib_group_assignments"> | string | null
    usd_per_lot?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFilter<"ib_group_assignments"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ib_group_assignments"> | Date | string | null
  }

  export type ib_requestsCreateWithoutIb_group_assignmentsInput = {
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    referral_code?: string | null
    referred_by?: number | null
    country?: string | null
  }

  export type ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput = {
    id?: number
    full_name: string
    email: string
    password_hash: string
    status?: string
    ib_type?: string
    submitted_at?: Date | string | null
    approved_at?: Date | string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: Decimal | DecimalJsLike | number | string | null
    admin_comments?: string | null
    group_id?: string | null
    structure_id?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    referral_code?: string | null
    referred_by?: number | null
    country?: string | null
  }

  export type ib_requestsCreateOrConnectWithoutIb_group_assignmentsInput = {
    where: ib_requestsWhereUniqueInput
    create: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
  }

  export type ib_requestsUpsertWithoutIb_group_assignmentsInput = {
    update: XOR<ib_requestsUpdateWithoutIb_group_assignmentsInput, ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput>
    create: XOR<ib_requestsCreateWithoutIb_group_assignmentsInput, ib_requestsUncheckedCreateWithoutIb_group_assignmentsInput>
    where?: ib_requestsWhereInput
  }

  export type ib_requestsUpdateToOneWithWhereWithoutIb_group_assignmentsInput = {
    where?: ib_requestsWhereInput
    data: XOR<ib_requestsUpdateWithoutIb_group_assignmentsInput, ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput>
  }

  export type ib_requestsUpdateWithoutIb_group_assignmentsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ib_requestsUncheckedUpdateWithoutIb_group_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ib_type?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usd_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spread_percentage_per_lot?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    admin_comments?: NullableStringFieldUpdateOperationsInput | string | null
    group_id?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableIntFieldUpdateOperationsInput | number | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSuggestionsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuggestionsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    priceAlerts?: PriceAlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuggestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuggestionsInput, UserUncheckedCreateWithoutSuggestionsInput>
  }

  export type UserUpsertWithoutSuggestionsInput = {
    update: XOR<UserUpdateWithoutSuggestionsInput, UserUncheckedUpdateWithoutSuggestionsInput>
    create: XOR<UserCreateWithoutSuggestionsInput, UserUncheckedCreateWithoutSuggestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuggestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuggestionsInput, UserUncheckedUpdateWithoutSuggestionsInput>
  }

  export type UserUpdateWithoutSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    priceAlerts?: PriceAlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPriceAlertsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountCreateNestedOneWithoutUserInput
    deposits?: DepositCreateNestedManyWithoutUserInput
    kyc?: KYCCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogCreateNestedManyWithoutUserInput
    suggestions?: SuggestionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPriceAlertsInput = {
    id?: string
    clientId?: string
    email: string
    password: string
    name?: string | null
    phone?: string | null
    country?: string | null
    createdAt?: Date | string
    emailVerified?: boolean
    lastLoginAt?: Date | string | null
    role?: string
    status?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: UserCreatetwoFactorBackupCodesInput | string[]
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutAdminInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedCreateNestedOneWithoutUserInput
    deposits?: DepositUncheckedCreateNestedManyWithoutUserInput
    kyc?: KYCUncheckedCreateNestedOneWithoutUserInput
    mt5Accounts?: MT5AccountUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    terminalSettings?: TerminalSettingsUncheckedCreateNestedOneWithoutUserInput
    UserFavorite?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    userLoginLogs?: UserLoginLogUncheckedCreateNestedManyWithoutUserInput
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPriceAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPriceAlertsInput, UserUncheckedCreateWithoutPriceAlertsInput>
  }

  export type UserUpsertWithoutPriceAlertsInput = {
    update: XOR<UserUpdateWithoutPriceAlertsInput, UserUncheckedUpdateWithoutPriceAlertsInput>
    create: XOR<UserCreateWithoutPriceAlertsInput, UserUncheckedCreateWithoutPriceAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPriceAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPriceAlertsInput, UserUncheckedUpdateWithoutPriceAlertsInput>
  }

  export type UserUpdateWithoutPriceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUpdateOneWithoutUserNestedInput
    deposits?: DepositUpdateManyWithoutUserNestedInput
    kyc?: KYCUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPriceAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: UserUpdatetwoFactorBackupCodesInput | string[]
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateOneWithoutUserNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutUserNestedInput
    kyc?: KYCUncheckedUpdateOneWithoutUserNestedInput
    mt5Accounts?: MT5AccountUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    terminalSettings?: TerminalSettingsUncheckedUpdateOneWithoutUserNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    userLoginLogs?: UserLoginLogUncheckedUpdateManyWithoutUserNestedInput
    suggestions?: SuggestionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountType: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogCreateManyAdminInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValues?: string | null
    newValues?: string | null
    createdAt?: Date | string
  }

  export type DepositCreateManyUserInput = {
    id?: string
    mt5AccountId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5AccountCreateManyUserInput = {
    id?: string
    accountId: string
    accountType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    leverage?: number | null
    nameOnAccount?: string | null
    package?: string | null
    group?: string | null
    balance?: number | null
    credit?: number | null
    currency?: string | null
    equity?: number | null
    lastSyncedAt?: Date | string | null
    margin?: number | null
    marginFree?: number | null
    marginLevel?: number | null
    profit?: number | null
    archived?: boolean
    archived_at?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    revoked?: boolean | null
    deviceName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    lastActivity?: Date | string | null
  }

  export type UserFavoriteCreateManyUserInput = {
    id?: string
    instrumentId: string
    mt5AccountId?: string | null
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserLoginLogCreateManyUserInput = {
    id?: string
    user_agent?: string | null
    device?: string | null
    browser?: string | null
    success?: boolean
    failure_reason?: string | null
    createdAt?: Date | string
  }

  export type SuggestionCreateManyUserInput = {
    id?: string
    userName?: string | null
    userEmail?: string | null
    comment: string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type PriceAlertCreateManyUserInput = {
    id?: string
    symbol: string
    targetPrice: number
    condition: string
    isActive?: boolean
    isTriggered?: boolean
    triggeredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mt5Account?: MT5AccountUpdateOneRequiredWithoutDepositsNestedInput
    cregisDeposit?: CregisDepositUpdateOneWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cregisDeposit?: CregisDepositUncheckedUpdateOneWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DefaultMT5Account?: DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountNestedInput
    deposits?: DepositUncheckedUpdateManyWithoutMt5AccountNestedInput
    mt5Transactions?: MT5TransactionUncheckedUpdateManyWithoutMt5AccountNestedInput
    UserFavorite?: UserFavoriteUncheckedUpdateManyWithoutMT5AccountNestedInput
  }

  export type MT5AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    leverage?: NullableIntFieldUpdateOperationsInput | number | null
    nameOnAccount?: NullableStringFieldUpdateOperationsInput | string | null
    package?: NullableStringFieldUpdateOperationsInput | string | null
    group?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    equity?: NullableFloatFieldUpdateOperationsInput | number | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    margin?: NullableFloatFieldUpdateOperationsInput | number | null
    marginFree?: NullableFloatFieldUpdateOperationsInput | number | null
    marginLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archived_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revoked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instrument?: InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput
    MT5Account?: MT5AccountUpdateOneWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    targetPrice?: FloatFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isTriggered?: BoolFieldUpdateOperationsInput | boolean
    triggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountCreateManyMT5AccountInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepositCreateManyMt5AccountInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    method: string
    paymentMethod?: string | null
    transactionHash?: string | null
    proofFileUrl?: string | null
    bankDetails?: string | null
    cryptoAddress?: string | null
    depositAddress?: string | null
    externalTransactionId?: string | null
    status?: string
    rejectionReason?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MT5TransactionCreateManyMt5AccountInput = {
    id?: string
    type: string
    amount: number
    status?: string | null
    paymentMethod?: string | null
    transactionId?: string | null
    comment?: string | null
    createdAt?: Date | string | null
    currency?: string | null
    depositId?: string | null
    withdrawalId?: string | null
    userId?: string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserFavoriteCreateManyMT5AccountInput = {
    id?: string
    userId: string
    instrumentId: string
    sortOrder?: number
    addedAt?: Date | string
  }

  export type DefaultMT5AccountUpdateWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutDefaultMT5AccountNestedInput
  }

  export type DefaultMT5AccountUncheckedUpdateWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DefaultMT5AccountUncheckedUpdateManyWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepositsNestedInput
    cregisDeposit?: CregisDepositUpdateOneWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cregisDeposit?: CregisDepositUncheckedUpdateOneWithoutDepositNestedInput
  }

  export type DepositUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    proofFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bankDetails?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoAddress?: NullableStringFieldUpdateOperationsInput | string | null
    depositAddress?: NullableStringFieldUpdateOperationsInput | string | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MT5TransactionUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionUncheckedUpdateWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MT5TransactionUncheckedUpdateManyWithoutMt5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    depositId?: NullableStringFieldUpdateOperationsInput | string | null
    withdrawalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserFavoriteUpdateWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instrument?: InstrumentUpdateOneRequiredWithoutUserFavoriteNestedInput
    User?: UserUpdateOneRequiredWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutMT5AccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instrumentId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInstrumentInput = {
    id?: string
    userId: string
    mt5AccountId?: string | null
    sortOrder?: number
    addedAt?: Date | string
  }

  export type UserFavoriteUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserFavoriteNestedInput
    MT5Account?: MT5AccountUpdateOneWithoutUserFavoriteNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutInstrumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mt5AccountId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logCreateManyAdminInput = {
    id?: number
    ip_address: string
    user_agent?: string | null
    location?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    success?: boolean
    failure_reason?: string | null
    created_at?: Date | string
  }

  export type balance_operation_historyCreateManyAdminInput = {
    id?: number
    mt5_login: string
    operation_type: string
    amount: number
    currency?: string
    description?: string | null
    status?: string
    error_message?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
  }

  export type admin_login_logUpdateWithoutAdminInput = {
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_login_logUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip_address?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    failure_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUpdateWithoutAdminInput = {
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balance_operation_historyUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    mt5_login?: StringFieldUpdateOperationsInput | string
    operation_type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chat_messagesCreateManyChat_conversationsInput = {
    id?: number
    sender_id: string
    sender_name: string
    sender_type: string
    message_type?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: boolean | null
    read_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type chat_participantsCreateManyChat_conversationsInput = {
    id?: number
    user_id: string
    user_name: string
    user_type: string
    role?: string | null
    joined_at?: Date | string | null
    left_at?: Date | string | null
    is_active?: boolean | null
  }

  export type chat_messagesUpdateWithoutChat_conversationsInput = {
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesUncheckedUpdateWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_messagesUncheckedUpdateManyWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_name?: StringFieldUpdateOperationsInput | string
    sender_type?: StringFieldUpdateOperationsInput | string
    message_type?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chat_participantsUpdateWithoutChat_conversationsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsUncheckedUpdateWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chat_participantsUncheckedUpdateManyWithoutChat_conversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ib_group_assignmentsCreateManyIb_requestsInput = {
    id?: number
    group_id: string
    group_name?: string | null
    structure_id?: number | null
    structure_name?: string | null
    usd_per_lot?: Decimal | DecimalJsLike | number | string
    spread_share_percentage?: Decimal | DecimalJsLike | number | string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ib_group_assignmentsUpdateWithoutIb_requestsInput = {
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsUncheckedUpdateWithoutIb_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ib_group_assignmentsUncheckedUpdateManyWithoutIb_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    group_name?: NullableStringFieldUpdateOperationsInput | string | null
    structure_id?: NullableIntFieldUpdateOperationsInput | number | null
    structure_name?: NullableStringFieldUpdateOperationsInput | string | null
    usd_per_lot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spread_share_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}